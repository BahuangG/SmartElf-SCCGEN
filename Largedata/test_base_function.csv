"modifier only curator ( ) { require ( msg . sender == curator ) ; _ ; }
"
"function close deposit sub round ( ) only controller public { require ( list sub round nlf [ current round ] [ current sub round ] . is open == BOOL_ ) ; require ( list sub round nlf [ current round ] [ current sub round ] . is close nac pool == BOOL_ ) ; list sub round nlf [ current round ] [ current sub round ] . is close nac pool = BOOL_ ; }
"
"function stake for ( address _user , uint256 _amount , bytes _data ) public { super . stake for ( _user , _amount , _data ) ; update credit balance ( _user , _amount , default lock in duration ) ; }
"
"function destroy and send ( address _recipient ) public only owner { require ( minting finished ) ; super . destroy and send ( _recipient ) ; }
"
"function set min bet for oraclize ( uint256 min bet ) public { require ( msg . sender == owner ) ; minbet_for oraclize = min bet ; }
"
"function redeem ( uint256 _envelope id ) external { envelope storage envelope = envelopes [ _envelope id ] ; if ( envelope . will expire after >= block . timestamp ) { revert ( ) ; } if ( envelope . remaining value == NUM_ ) { revert ( ) ; } if ( envelope . maker != msg . sender ) { revert ( ) ; } uint256 value = envelope . remaining value ; envelope . remaining value = NUM_ ; envelope . remaining number = NUM_ ; balance of envelopes -= value ; msg . sender . transfer ( value ) ; redeemed ( msg . sender , _envelope id , value , block . timestamp ) ; }
"
"function create tokens ( ) public only state ( swap state . started ) { require ( now < ( enter date + NUM_ ) && token_a . balance of ( address ( this ) ) >= token_a_amount && token_b . balance of ( address ( this ) ) >= token_b_amount ) ; uint tokenratio = NUM_ ; ( long_token_address , tokenratio ) = factory . create token ( token_a_amount , long_party , BOOL_ , start_date ) ; num_drct_longtokens = token_a_amount . div ( tokenratio ) ; ( short_token_address , tokenratio ) = factory . create token ( token_b_amount , short_party , BOOL_ , start_date ) ; num_drct_shorttokens = token_b_amount . div ( tokenratio ) ; current_state = swap state . tokenized ; if ( premium > NUM_ ) { if ( creator == long_party ) { short_party . transfer ( premium ) ; } else { long_party . transfer ( premium ) ; } } }
"
"function create token ( bytes32 _name , string _description , string _base64 image ) public { require ( now > lock timestamp ) ; lock timestamp = lock timestamp . add ( NUM_ days ) ; uint256 _token id = total supply ( ) . add ( NUM_ ) ; _mint ( msg . sender , _token id ) ; add token metadata ( _token id , _name , _description , _base64 image ) ; }
"
"function change multisig ( address addr ) only owner public { if ( addr == address ( NUM_ ) ) throw ; multisig ether = addr ; }
"
"function withdraw ( ) only owner public { wallet . transfer ( address ( this ) . balance ) ; }
"
"function challenge clearing ( bytes32 _value ) public payable { item storage item = items [ _value ] ; uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; require ( msg . value >= stake + arbitrator cost ) ; require ( item . status == item status . clearing requested || item . status == item status . preventive clearing requested ) ; require ( ! item . disputed ) ; if ( item . balance >= arbitrator cost ) { item . challenger = msg . sender ; item . balance += msg . value - arbitrator cost ; item . disputed = BOOL_ ; item . dispute id = arbitrator . create dispute . value ( arbitrator cost ) ( NUM_ , arbitrator extra data ) ; dispute idto item [ item . dispute id ] = _value ; emit dispute ( arbitrator , item . dispute id , NUM_ ) ; } else { if ( item . status == item status . clearing requested ) item . status = item status . registered ; else item . status = item status . absent ; item . submitter . send (
"
"modifier when transferable ( ) { require ( transferable ) ; _ ; }
"
"function transfer for multi addresses ( address [ ] _addresses , uint256 [ ] _amounts ) can transfer public returns ( bool ) { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { require ( _addresses [ i ] != address ( NUM_ ) ) ; require ( _amounts [ i ] <= balances [ msg . sender ] ) ; require ( _amounts [ i ] > NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amounts [ i ] ) ; balances [ _addresses [ i ] ] = balances [ _addresses [ i ] ] . add ( _amounts [ i ] ) ; transfer ( msg . sender , _addresses [ i ] , _amounts [ i ] ) ; } return BOOL_ ; }
"
"function calculate update profit ( address user ) private view returns ( account ) { account memory acc = accounts [ user ] ; for ( uint r = acc . last user update round ; r < current round ; r ++ ) { acc . profit total *= NUM_ ; if ( acc . money hidden > NUM_ ) { acc . profit total += acc . money hidden * NUM_ ; acc . money hidden = NUM_ ; } if ( acc . money new > NUM_ ) { acc . money hidden = acc . money new ; acc . money new = NUM_ ; } } acc . last user update round = current round ; return acc ; }
"
"function create auction ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) when not paused external { require ( _starting price == uint256 ( uint128 ( _starting price ) ) ) ; require ( _starting price < auction price limit ) ; require ( _ending price == uint256 ( uint128 ( _ending price ) ) ) ; require ( _ending price < auction price limit ) ; require ( _duration == uint256 ( uint64 ( _duration ) ) ) ; require ( msg . sender == address ( token contract ) ) ; _deposit ( _seller , _token id ) ; auction memory auction = auction ( _seller , uint128 ( _starting price ) , uint128 ( _ending price ) , uint64 ( _duration ) , uint64 ( now ) ) ; _add auction ( _token id , auction ) ; }
"
"function approve and call ( address _spender , uint256 _amount , bytes _data ) public returns ( bool success ) { require ( _approve ( msg . sender , _spender , _amount ) ) ; approve and call fall back ( _spender ) . receive approval ( msg . sender , _amount , address ( this ) , _data ) ; return BOOL_ ; }
"
"function new policy ( bytes32 _carrier flight number , bytes32 _departure year month day , uint256 _departure time , uint256 _arrival time , currency _currency , bytes32 _customer external id ) public payable { require ( fd_ac . check permission ( NUM_ , NUM_ ) ) ; if ( _currency == currency . eth ) { if ( msg . value < min_premium || msg . value > max_premium ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } else { require ( msg . sender == get contract ( STR_ ) ) ; if ( _currency == currency . eur ) { if ( msg . value < min_premium_eur || msg . value > max_premium_eur ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } if ( _currency == currency . usd ) { if ( msg . value < min_premium_usd || msg . value > max_premium_usd ) { log policy declined (
"
"function continue order ( uint128 order id , uint max matches ) public { address client = msg . sender ; order storage order = order for order id [ order id ] ; require ( order . client == client ) ; if ( order . status != status . needs gas ) { return ; } client order event ( client , client order event type . continue , order id , max matches ) ; order . status = status . unknown ; process order ( order id , max matches ) ; }
"
"function accept ( bytes32 _key , bytes32 _voting group name ) external returns ( uint ) { if ( ! is tx exist ( _key ) ) { return _emit error ( pending_manager_tx_doesnt_exist ) ; } if ( ! groups access manager ( access manager ) . is user in group ( _voting group name , msg . sender ) ) { return _emit error ( pending_manager_invalid_invocation ) ; } guard storage _guard = tx key2guard [ _key ] ; if ( _guard . state != guard state . in process ) { return _emit error ( pending_manager_invalid_invocation ) ; } if ( _guard . votes [ msg . sender ] . group name != bytes32 ( NUM_ ) && _guard . votes [ msg . sender ] . accepted ) { return _emit error ( pending_manager_invalid_invocation ) ; } policy storage _policy = policy id2policy [ index2 policy id [ _guard . base policy index ] ] ; uint _policy group index = _policy . group name2index [ _voting group name ] ; uint _group accepted votes count = _guard . accepted count [ _voting group name ] ; if ( _group accepted votes count == _policy . participated
"
"function pre buy ( ) payable is_pre_crowdfund_period is_not_halted { uint price vested = NUM_ ; if ( msg . sender == pre buy1 ) price vested = pre buy price1 ; if ( msg . sender == pre buy2 ) price vested = pre buy price2 ; if ( msg . sender == pre buy3 ) price vested = pre buy price3 ; if ( price vested == NUM_ ) revert ( ) ; uint amount = process purchase ( price_stage_one + price vested , safe math . sub ( prebuy_portion_max , prebuy portion total ) ) ; grant vested tokens ( msg . sender , calc amount ( msg . value , price vested ) , uint64 ( now ) , uint64 ( now ) + NUM_ days , uint64 ( now ) + NUM_ days , BOOL_ , BOOL_ ) ; prebuy portion total += amount ; pre buy ( amount ) ; }
"
"function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 total parts = total supply ( ) ; return tokens of owner within range ( _owner , NUM_ , total parts ) ; }
"
"function use module ( address _module factory ) external { if ( isecurity token registry ( security token registry ) . is security token ( msg . sender ) ) { require ( registry [ _module factory ] != NUM_ , STR_ ) ; require ( verified [ _module factory ] || ( imodule factory ( _module factory ) . owner ( ) == isecurity token ( msg . sender ) . owner ( ) ) , STR_ ) ; reputation [ _module factory ] . push ( msg . sender ) ; emit log module used ( _module factory , msg . sender ) ; } }
"
"function _claimed surrounding tiles ( uint256 _deed id ) internal view returns ( uint256 [ ] memory ) { var ( x , y ) = identifier to coordinate ( _deed id ) ; uint256 claimed = NUM_ ; uint256 [ ] memory _tiles = new uint256 [ ] ( NUM_ ) ; for ( int256 dx = - NUM_ ; dx <= NUM_ ; dx ++ ) { for ( int256 dy = - NUM_ ; dy <= NUM_ ; dy ++ ) { if ( dx == NUM_ && dy == NUM_ ) { continue ; } uint256 nx = uint256 ( int256 ( x ) + dx ) ; uint256 ny = uint256 ( int256 ( y ) + dy ) ; if ( nx >= game settings . cols || ny >= game settings . rows ) { continue ; } uint256 neighbor identifier = coordinate to identifier ( nx , ny ) ; if ( game states [ game index ] . identifier to owner [ neighbor identifier ] != address ( NUM_ ) ) { _tiles [ claimed ] = neighbor identifier ; claimed ++ ; } } } uint256 [ ] memory tiles
"
"modifier hero allowed to train ( uint _hero id ) { if ( hero token contract . balance of ( msg . sender ) > NUM_ ) { require ( hero token contract . owner of ( _hero id ) == msg . sender ) ; } _ ; }
"
"function _finalize ( ) internal { require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; uint date = now . add ( seconds_in_year ) ; token . freeze ( vest_1 , date ) ; date = date . add ( seconds_in_year ) ; token . freeze ( vest_2 , date ) ; date = date . add ( seconds_in_year ) ; token . freeze ( vest_3 , date ) ; date = date . add ( seconds_in_year ) ; token . freeze ( vest_4 , date ) ; token . finalize ico ( ) ; token . transfer ownership ( base_wallet ) ; phase_i = phase_finished ; }
"
"function get fee ( uint _price , address _currency , address _buyer , address _seller , address _token ) public view returns ( uint percent , uint fee ) { ( percent , fee ) = fee provider . get fee ( _price , _currency , _buyer , _seller , _token ) ; }
"
"function set cold wallet1 ( address _cold wallet1 ) public only owner { require ( _cold wallet1 != address ( NUM_ ) ) ; cold wallet1 = _cold wallet1 ; }
"
"function restrict ( address _address ) only owner public { require ( _address != NUM_ ) ; whitelisted [ _address ] = BOOL_ ; }
"
"function deposit lrc ( ) payable { require ( ! closed && msg . sender != owner ) ; require ( now <= deposit stop time ) ; require ( msg . value == NUM_ ) ; var record = records [ msg . sender ] ; var lrc token = token ( lrc token address ) ; uint lrc amount = this . balance . mul ( rate ) . min256 ( lrc token . balance of ( msg . sender ) ) . min256 ( lrc token . allowance ( msg . sender , address ( this ) ) ) . min256 ( max_lrc_deposit_per_address - record . lrc amount ) ; uint eth amount = lrc amount . div ( rate ) ; lrc amount = eth amount . mul ( rate ) ; require ( lrc amount > NUM_ && eth amount > NUM_ ) ; record . lrc amount += lrc amount ; record . timestamp = now ; records [ msg . sender ] = record ; lrc received += lrc amount ; eth sent += eth amount ; deposit ( deposit id ++ , msg . sender , eth amount , lrc amount )
"
"function get kycpayload ( bytes dataframe ) public constant returns ( address whitelisted address , uint128 customer id , uint32 min eth , uint32 max eth ) { address _whitelisted address = dataframe . slice address ( NUM_ ) ; uint128 _customer id = uint128 ( dataframe . slice16 ( NUM_ ) ) ; uint32 _min eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint32 _max eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; return ( _whitelisted address , _customer id , _min eth , _max eth ) ; }
"
"function get value at ( checkpoint [ ] storage _checkpoints , uint256 _block ) constant internal returns ( uint256 ) { if ( _checkpoints . length == NUM_ ) return NUM_ ; if ( _block >= _checkpoints [ _checkpoints . length - NUM_ ] . from block ) return _checkpoints [ _checkpoints . length - NUM_ ] . value ; if ( _block < _checkpoints [ NUM_ ] . from block ) return NUM_ ; uint256 min = NUM_ ; uint256 max = _checkpoints . length - NUM_ ; while ( max > min ) { uint256 mid = ( max + min + NUM_ ) / NUM_ ; if ( _checkpoints [ mid ] . from block <= _block ) { min = mid ; } else { max = mid - NUM_ ; } } return _checkpoints [ min ] . value ; }
"
"function buy ( ) payable when not paused public returns ( uint256 ) { deposit ( msg . sender , msg . value ) ; require ( msg . value >= NUM_ ether ) ; uint256 tokens = msg . value . mul ( buy rate ) ; require ( balances [ token pool ] >= tokens ) ; balances [ token pool ] = balances [ token pool ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; transfer ( token pool , msg . sender , tokens ) ; return tokens ; }
"
"function _remove pending request id ( uint32 _id ) private { uint _len = pending request ids . length ; uint _found index = max_pending_requests ; for ( uint _i = NUM_ ; _i < _len ; _i ++ ) { if ( pending request ids [ _i ] == _id ) { _found index = _i ; break ; } } require ( _found index != max_pending_requests ) ; pending request ids [ _found index ] = pending request ids [ _len - NUM_ ] ; pending request ids . length -- ; }
"
"function set min contrib amount ( uint _min contrib amount ) only owner { require ( _min contrib amount > NUM_ ) ; require ( start time > now ) ; min contrib amount = _min contrib amount ; }
"
"function set lock address ( address target , bool status ) external is owner { require ( owner != target ) ; lock address [ target ] = status ; emit locked ( target , status ) ; }
"
"modifier crowdsale active ( ) { require ( crowdsale closed == BOOL_ ) ; _ ; }
"
"function schedule payout oraclize call ( uint _policy id , bytes32 _risk id , uint _oraclize time ) public { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; var ( carrier flight number , departure year month day , ) = fd_db . get risk parameters ( _risk id ) ; string memory oraclize url = str concat ( oraclize_status_base_url , b32to string ( carrier flight number ) , b32to string ( departure year month day ) , oraclize_status_query ) ; bytes32 query id = oraclize_query ( _oraclize time , STR_ , oraclize url , oraclize_gas ) ; fd_db . create oraclize callback ( query id , _policy id , oraclize state . for payout , _oraclize time ) ; log oraclize call ( _policy id , query id , oraclize url , _oraclize time ) ; }
"
"function set pre sale tlyper eth ( uint256 _new tlyper eth ) public only owner { pre sale tlyper eth = _new tlyper eth ; }
"
"function set discount member ( address _address , string member type , bool is active member ) public only owner { if ( compare strings ( member type , STR_ ) ) sale discount list [ _address ] = is active member ; else if ( compare strings ( member type , STR_ ) ) custom private sale [ _address ] = is active member ; else require ( NUM_ == NUM_ ) ; }
"
"modifier only financial officer ( ) { require ( msg . sender == financial officer address ) ; _ ; }
"
"function change stage ( stage new stage ) public only owner { current stage = new stage ; }
"
"function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (
"
"function wadmin_freeze account ( address target , bool freeze ) only owner public returns ( bool success ) { frozen account [ target ] = freeze ; frozen funds ( target , freeze ) ; return BOOL_ ; }
"
"function change minters ( address _arena contract , address _vending machine , address _kitty gym ) external only owner returns ( bool success ) { if ( _arena contract != NUM_ ) arena contract = _arena contract ; if ( _vending machine != NUM_ ) vending machine = _vending machine ; if ( _kitty gym != NUM_ ) kitty gym = _kitty gym ; return BOOL_ ; }
"
"function set start time ( uint64 _start time ) public only owner { require ( now < start time ) ; require ( _start time > now ) ; require ( _start time < end time ) ; start time = _start time ; }
"
"function kill ( ) public only owner { require ( this . balance == NUM_ ) ; selfdestruct ( owner ) ; }
"
"function add ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }
"
"modifier bet is valid ( uint _bet size , uint _player number ) { if ( ( ( ( ( _bet size * ( NUM_ - ( safe sub ( _player number , NUM_ ) ) ) ) / ( safe sub ( _player number , NUM_ ) ) + _bet size ) ) * house edge / house edge divisor ) - _bet size > max profit || _bet size < min bet || _player number < min number || _player number > max number ) throw ; _ ; }
"
"function set astore ( string _app nickname , address _address ) public only owner { require ( bytes ( _app nickname ) . length > NUM_ ) ; bytes32 _app nickname32 = keccak256 ( _app nickname ) ; require ( _address != address ( NUM_ ) ) ; itweedentity store _store = itweedentity store ( _address ) ; require ( _store . get app nickname ( ) == _app nickname32 ) ; uint _app id = _store . get app id ( ) ; require ( app nicknames32 [ _app id ] == NUM_ ) ; app nicknames32 [ _app id ] = _app nickname32 ; app nicknames [ _app id ] = _app nickname ; __app ids [ _app nickname ] = _app id ; __stores [ _app id ] = store ( itweedentity store ( _address ) , _address ) ; }
"
"function _current price ( collectible sale memory _sale ) internal view returns ( uint256 ) { uint256 seconds passed = NUM_ ; if ( now > _sale . started at ) { seconds passed = now - _sale . started at ; } return _compute current price ( _sale . starting price , _sale . ending price , _sale . duration , seconds passed ) ; }
"
"function balance of ( address _account ) constant returns ( uint balance ) { return balances [ _account ] ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { bytes memory empty ; transfer ( _to , _value , empty ) ; }
"
"function claim ( ) only owner public { owner . transfer ( this . balance ) ; }
"
"function name of ( address _address ) public view returns ( bytes32 _name ) { entry memory _cur entry = entries [ NUM_ ] ; entry memory _next entry ; while ( _cur entry . next > NUM_ ) { _next entry = entries [ _cur entry . next ] ; if ( _next entry . addr == _address ) { return _cur entry . next ; } _cur entry = _next entry ; } }
"
"function transfer ( address _to , uint _value ) only unlocked only payload size ( NUM_ * NUM_ ) public returns ( bool _success ) { require ( _to != address ( NUM_ ) ) ; bytes memory _empty ; if ( ( balances [ msg . sender ] > _value ) && _value > NUM_ && _to != address ( NUM_ ) ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; if ( is contract ( _to ) ) { erc223 receiving contract receiver = erc223 receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _empty ) ; } transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function set paused ( bool _is paused ) public only owner { paused = _is paused ; }
"
"function mint tokens with approval ( address _target , uint _minted amount , address _spender ) public only owner returns ( bool success ) { require ( _minted amount <= unminted tokens ) ; balances [ _target ] += _minted amount ; unminted tokens -= _minted amount ; _total supply += _minted amount ; allowed [ _target ] [ _spender ] += _minted amount ; emit transfer ( NUM_ , _target , _minted amount ) ; return BOOL_ ; }
"
"function accept and pay ( bytes32 _request id , uint256 [ ] _payee amounts , uint256 [ ] _additionals , int256 _payee amounts sum ) internal { accept action ( _request id ) ; additional action ( _request id , _additionals ) ; if ( _payee amounts sum > NUM_ ) { payment internal ( _request id , _payee amounts ) ; } }
"
"function add tower ( uint32 _timer , uint16 _payout , uint16 _price increase , uint256 _amount to half time , uint256 _min price , uint16 _min price after win , uint16 _creator fee ) public payable only open or owner returns ( uint256 ) { require ( _timer >= NUM_ ) ; require ( _timer <= NUM_ ) ; require ( _payout >= NUM_ && _payout <= NUM_ ) ; require ( _price increase >= NUM_ && _price increase <= NUM_ ) ; require ( _min price after win >= NUM_ && _min price after win <= NUM_ ) ; require ( _amount to half time == NUM_ || _amount to half time >= NUM_ ) ; require ( _creator fee >= NUM_ && _creator fee <= NUM_ ) ; require ( _min price >= ( NUM_ szabo ) && _min price <= ( NUM_ ether ) ) ; if ( msg . sender == owner ) { _creator fee = NUM_ ; if ( msg . value > NUM_ ) { owner . transfer ( msg . value ) ; } } else { if ( msg . value >= amount to create ) { uint256 to div =
"
"modifier only owner or admin ( ) { require ( msg . sender == owner || msg . sender == admin ) ; _ ; }
"
"function get contributor remaining sale amount ( address wallet ) public view returns ( uint256 ) { uint256 invested_amount = wei_invested_by_contributor_in_sale [ wallet ] ; return contributor_max_sale_contribution - invested_amount ; }
"
"function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {
"
"function set allow transfers ( bool _allow transfers ) external only owner { allow transfers = _allow transfers ; allow transfers changed ( _allow transfers ) ; }
"
"function div round ( uint v , uint d ) internal constant returns ( uint ) { return ( v + ( d / NUM_ ) ) / d ; }
"
"function claim funds ( ) only contributors public { uint latest = latest balance check [ msg . sender ] ; uint supply = object . total supply ( ) ; uint balance = balance owed [ msg . sender ] ; uint earnings = items owned [ msg . sender ] . div ( NUM_ ether ) . mul ( supply . sub ( latest ) ) . div ( NUM_ ether ) . mul ( item return ) ; uint excess = excess eth [ msg . sender ] ; latest balance check [ msg . sender ] = supply ; balance owed [ msg . sender ] = NUM_ ; excess eth [ msg . sender ] = NUM_ ; balance = balance . add ( earnings ) ; running debt = running debt . add ( earnings ) ; running debt = running debt . sub ( balance ) ; debt paid = debt paid . add ( balance ) ; balance = balance . add ( excess ) ; total excess eth = total excess eth . sub ( excess ) ; will withdraw ( balance ) ; require ( balance > NUM_ ) ;
"
"function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize_cb address ( ) || myid != next attack id ) throw ; uint128 pot ; uint16 random ; uint32 howmany = num animals < NUM_ ? ( num animals < NUM_ ? NUM_ : num animals / NUM_ ) : NUM_ ; uint16 [ ] memory random numbers = get numbers from string ( result , STR_ , howmany ) ; uint32 [ ] memory killed animals = new uint32 [ ] ( howmany ) ; for ( uint8 i = NUM_ ; i < howmany ; i ++ ) { random = map to new range ( random numbers [ i ] , num animals ) ; killed animals [ i ] = ids [ random ] ; pot += kill animal ( random ) ; } uint128 needed gas = oraclize gas + NUM_ * num animals ; uint128 gas cost = uint128 ( needed gas * tx . gasprice ) ; if ( pot > gas cost ) distribute ( uint128 ( pot - gas cost ) ) ; trigger attack ( time till next attack ( ) , needed
"
"function transfer token_to balance ( address _user , uint256 _amount ) public only owner { invest balances [ _user ] -= _amount ; balances [ _user ] += _amount ; }
"
"function add addresses to whitelist ( address [ ] addresses ) only owner public { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { participants [ addresses [ i ] ] . whitelisted = BOOL_ ; } }
"
"function init ( address _team_wallet , uint _start_time , bytes32 _initial_tier_name , uint _initial_tier_price , uint _initial_tier_duration , uint _initial_tier_token_sell_cap , uint _initial_tier_min_purchase , bool _initial_tier_is_whitelisted , bool _initial_tier_duration_is_modifiable , address _admin ) external view { contract . initialize ( ) ; if ( _team_wallet == NUM_ || _initial_tier_price == NUM_ || _start_time < now || _start_time + _initial_tier_duration <= _start_time || _initial_tier_token_sell_cap == NUM_ || _admin == address ( NUM_ ) ) revert ( STR_ ) ; contract . storing ( ) ; contract . set ( exec permissions ( msg . sender ) ) . to ( BOOL_ ) ; contract . set ( admin ( ) ) . to ( _admin ) ; contract . set ( wallet ( ) ) . to ( _team_wallet ) ; contract . set ( total duration ( ) ) . to ( _initial_tier_duration ) ; contract . set ( start time ( ) ) . to ( _start_time ) ; contract . set ( sale tier list ( ) ) . to ( uint ( NUM_ ) ) ; contract . set ( tier name ( uint ( NUM_ ) ) ) . to ( _initial_tier_name ) ; contract .
"
"function send for pre ico ( address buyer , uint256 amount ) public only owner { require ( sale cap >= amount ) ; sale cap = sale cap - amount ; balances [ token wallet ] = balances [ token wallet ] . sub ( amount ) ; balances [ buyer ] = balances [ buyer ] . add ( amount ) ; emit pre icotoken pushed ( buyer , amount ) ; emit transfer ( token wallet , buyer , amount ) ; }
"
"function deed of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 _deed id ) { require ( _owner != address ( NUM_ ) ) ; require ( _index < owned deeds [ _owner ] . length ) ; _deed id = owned deeds [ _owner ] [ _index ] ; }
"
"function set price ( uint256 _new price carnita ) only manager public { price carnita = _new price carnita ; carnitas [ last carnita ] . min = price carnita ; }
"
"function claim tokens ( address _beneficiary ) public { require ( is finalized ) ; require ( weeks from end plus month ( ) > NUM_ ) ; fractionalize ( _beneficiary ) ; require ( token buyers mapping [ _beneficiary ] > NUM_ && token buyers remaining [ _beneficiary ] > NUM_ ) ; uint256 w = weeks from end plus month ( ) ; if ( w > NUM_ ) { w = NUM_ ; } uint256 total due by now = w . mul ( token buyers fraction [ _beneficiary ] ) ; uint256 total withdrawn by now = total withdrawn ( _beneficiary ) ; if ( total due by now > total withdrawn by now ) { uint256 diff = total due by now . sub ( total withdrawn by now ) ; if ( diff > token buyers remaining [ _beneficiary ] ) { diff = token buyers remaining [ _beneficiary ] ; } token . transfer ( _beneficiary , diff ) ; token buyers remaining [ _beneficiary ] = token buyers remaining [ _beneficiary ] . sub ( diff ) ; } }
"
"function bid ( ) public payable blabla { uint _min leader amount = pot . mul ( min_leader_frac_top ) . div ( min_leader_frac_bot ) ; uint _bid amount to community = msg . value . mul ( frac_top ) . div ( frac_bot ) ; uint _bid amount to dividend fund = msg . value . mul ( dividend_fund_frac_top ) . div ( dividend_fund_frac_bot ) ; uint _bid amount to pot = msg . value . sub ( _bid amount to community ) . sub ( _bid amount to dividend fund ) ; earnings [ _null ] = earnings [ _null ] . add ( _bid amount to community ) ; dividend fund = dividend fund . add ( _bid amount to dividend fund ) ; pot = pot . add ( _bid amount to pot ) ; bid ( now , msg . sender , msg . value , pot ) ; if ( msg . value >= _min leader amount ) { uint _dividend shares = msg . value . div ( _min leader amount ) ; dividend shares [ msg . sender ] = dividend shares [ msg . sender ] . add ( _dividend shares )
"
"function unbond ( ) external when system not paused current round initialized auto claim earnings { require ( delegator status ( msg . sender ) == delegator status . bonded ) ; delegator storage del = delegators [ msg . sender ] ; uint256 current round = rounds manager ( ) . current round ( ) ; del . withdraw round = current round . add ( unbonding period ) ; delegators [ del . delegate address ] . delegated amount = delegators [ del . delegate address ] . delegated amount . sub ( del . bonded amount ) ; total bonded = total bonded . sub ( del . bonded amount ) ; if ( transcoder status ( msg . sender ) == transcoder status . registered ) { resign transcoder ( msg . sender ) ; } if ( del . delegate address != msg . sender && transcoder status ( del . delegate address ) == transcoder status . registered ) { transcoder pool . update key ( del . delegate address , transcoder pool . get key ( del . delegate address ) . sub ( del . bonded amount ) , address ( NUM_
"
"function end rate ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }
"
"function last token is transferable date ( address holder ) constant public returns ( uint64 date ) { date = uint64 ( now ) ; uint256 grant index = token grants count ( holder ) ; for ( uint256 i = NUM_ ; i < grant index ; i ++ ) { date = max64 ( grants [ holder ] [ i ] . vesting , date ) ; } return date ; }
"
"function safe send ( address _address ) internal { uint value to send = pending returns [ _address ] ; assert ( value to send > NUM_ ) ; pending returns [ _address ] = NUM_ ; if ( _address . send ( value to send ) == BOOL_ ) { pending returns [ _address ] = value to send ; } }
"
"function buy tokens ( ) public stop in emergency payable returns ( bool ) { if ( msg . value == NUM_ ) { error ( STR_ ) ; return BOOL_ ; } uint256 token amount = buy tokens low level ( msg . sender , msg . value ) ; if ( ! screfund vault . deposit . value ( msg . value ) ( msg . sender , token amount ) ) { revert ( STR_ ) ; } emit buy tokens ( msg . sender , msg . value , token amount ) ; return BOOL_ ; }
"
"modifier only minter { if ( msg . sender != dev ) revert ( ) ; _ ; }
"
"function redeem token ( uint256 _token id ) public { token storage tkn = tokens [ _token id ] ; uint256 packed = tkn . option ; bool payout = uint8 ( ( packed > > ( NUM_ * NUM_ ) ) & NUM_ ) == NUM_ ? BOOL_ : BOOL_ ; uint32 id game = uint32 ( ( packed > > ( NUM_ * NUM_ ) ) & NUM_ ) ; uint32 combination = uint32 ( ( packed > > ( NUM_ * NUM_ ) ) & NUM_ ) ; game storage cur game = game [ id game ] ; require ( cur game . status == status . paying || cur game . status == status . canceling ) ; require ( msg . sender == token index to owner [ _token id ] ) ; require ( payout == BOOL_ ) ; require ( combination == cur game . win combination || cur game . status == status . canceling ) ; uint256 sum payment = NUM_ ; if ( cur game . status == status . canceling ) sum payment = tkn . price ; if ( cur game . status == status . paying
"
"function update reserved wei ( ) public { require ( wei raised . add ( pre sale . wei raised ( ) ) >= soft cap && now > end crowd sale time ) ; uint256 cur wei ; if ( ! first stage refund && now > end crowd sale time ) { cur wei = NUM_ * NUM_ ether ; reserved wei = cur wei ; rest wei = wei raised . sub ( cur wei ) ; first stage refund = BOOL_ ; } if ( ! second stage refund && now > end crowd sale time + NUM_ * NUM_ days ) { cur wei = rest wei . mul ( NUM_ ) . div ( NUM_ ) ; reserved wei = reserved wei . add ( cur wei ) ; rest wei = rest wei . sub ( cur wei ) ; second stage refund = BOOL_ ; } if ( ! final stage refund && now > end refundable time ) { reserved wei = reserved wei . add ( rest wei ) ; rest wei = NUM_ ; final stage refund = BOOL_ ; } }
"
"function calculate current price ( order memory order ) internal view returns ( uint ) { return sale kind interface . calculate final price ( order . side , order . sale kind , order . base price , order . extra , order . listing time , order . expiration time ) ; }
"
"function add owner ( address sender , proxy identity , address new owner ) public only authorized only older owner ( identity , sender ) rate limited ( identity , sender ) { require ( ! is owner ( identity , new owner ) ) ; owners [ identity ] [ new owner ] = now - user time lock ; log owner added ( identity , new owner , sender ) ; }
"
"function available amount ( address [ NUM_ ] addresses , uint [ NUM_ ] values ) external view returns ( uint ) { order library . order memory order = order library . create order ( addresses , values ) ; return available amount ( order , order . hash ( ) ) ; }
"
"function do withdrawal ( uint256 extra ) internal { uint256 amount = balance of [ msg . sender ] ; if ( amount == NUM_ ) throw ; if ( amount + extra > this . balance ) { throw ; } balance of [ msg . sender ] = NUM_ ; if ( total supply < total supply - amount ) { throw ; } else { total supply -= amount ; } transfer ( msg . sender , NUM_ , amount ) ; if ( ! msg . sender . send ( amount + extra ) ) throw ; }
"
"function contribute with address ( address contributor ) public payable when not paused { require ( msg . value >= min contrib amount ) ; require ( is contrib period running ( ) ) ; uint contrib value = msg . value ; uint excess contrib value = NUM_ ; uint old total contributed = total contributed ; total contributed = old total contributed . add ( contrib value ) ; uint new total contributed = total contributed ; if ( new total contributed >= total lending amount && old total contributed < total lending amount ) { cap reached = BOOL_ ; funding end time = now ; on cap reached ( funding end time ) ; excess contrib value = new total contributed . sub ( total lending amount ) ; contrib value = contrib value . sub ( excess contrib value ) ; total contributed = total lending amount ; } if ( investors [ contributor ] . amount == NUM_ ) { investors keys . push ( contributor ) ; } investors [ contributor ] . amount = investors [ contributor ] . amount . add ( contrib value ) ; if ( excess contrib value
"
"function remove policy rule ( bytes4 _sig , address _contract , bytes32 _group name ) only contract owner external returns ( uint ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; require ( groups access manager ( access manager ) . is group exists ( _group name ) ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy group name index = _policy . group name2index [ _group name ] ; if ( _policy group name index == NUM_ ) { return _emit error ( pending_manager_invalid_invocation ) ; } uint _policy groups count = _policy . groups count ; if ( _policy group name index != _policy groups count ) { requirements storage _requirements = _policy . participated groups [ _policy groups count ] ; _policy . participated groups [ _policy group name index ] = _requirements ; _policy . group name2index [ _requirements . group name ] = _policy group name index ; } _policy . total accepted limit = _policy . total accepted limit . sub ( _policy . participated groups [
"
"function total amount of crowdsale purchases without bonus ( ) constant public returns ( uint256 amount ) { for ( uint256 i ; i < crowdsale purchases . length ; i ++ ) { amount = safe math . add ( amount , crowdsale purchases [ i ] . raw amount ) ; } }
"
"function lock shares ( ) public only owner ( ) { require ( ! locked ) ; locked = BOOL_ ; }
"
"function mark ( address product account , bytes32 item hash ) public { product storage product = products [ product account ] ; require ( product . brand account != address ( NUM_ ) && product . active ) ; brand storage brand = brands [ product . brand account ] ; require ( brand . brand account != address ( NUM_ ) && brand . active ) ; app storage app = apps [ brand . app account ] ; require ( app . app account != address ( NUM_ ) && app . active ) ; bool permissioned = permissions [ msg . sender ] [ brand . brand account ] ; require ( permissioned ) ; markings [ item hash ] = product account ; marked ( msg . sender , product account , app . fee account , fee account , app . fee , fee , item hash ) ; if ( app . fee > NUM_ ) { token . transfer from ( brand . brand account , app . fee account , app . fee ) ; } if ( fee > NUM_ ) { token . transfer from ( brand . brand
"
"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; assert ( c >= a ) ; return c ; }
"
"function create contract special ( string _name ) public only ceo { require ( periodic table exists == BOOL_ ) ; require ( special ctr <= special limit ) ; special ctr = safe math . add ( special ctr , NUM_ ) ; uint256 _id = safe math . add ( special ctr , special start ) ; _create element ( _id , _name , address ( this ) , special starting price , scientist start ) ; }
"
"function calc random number and get preliminary game result ( uint256 block hash , uint64 gamble index ) constant returns ( uint64 gamble id , address player , uint256 block number , uint256 total win , uint8 wheel result , uint256 bets , uint256 values1 , uint256 values2 , uint256 n total bet value , uint256 n total bet count ) { game info memory g = gambles [ uint256 ( gamble index ) ] ; g . wheel result = calculate random number by blockhash ( block hash , g . player ) ; gamble id = gamble index ; player = g . player ; wheel result = g . wheel result ; total win = get game result ( g ) ; block number = g . block number ; n total bet value = total bet value ( g ) ; n total bet count = total bet count ( g ) ; bets = g . bets ; values1 = uint256 ( g . values ) ; values2 = uint256 ( g . values2 ) ; }
"
"function finalize crowdsale and token ( ) external view { contract . authorize ( msg . sender ) ; contract . checks ( sender admin and sale not final ) ; manage tokens . finalize crowdsale and token ( ) ; contract . checks ( emit and store ) ; contract . commit ( ) ; }
"
"function allowance ( address _owner , address spender ) constant returns ( uint _allowance ) { return _approvals [ _owner ] [ spender ] ; }
"
"function issue for euro ( uint256 euro ulps ) public only ( role_neumark_issuer ) accept agreement ( msg . sender ) returns ( uint256 ) { require ( _total eur ulps + euro ulps >= _total eur ulps ) ; uint256 neumark ulps = incremental ( _total eur ulps , euro ulps ) ; _total eur ulps += euro ulps ; m generate tokens ( msg . sender , neumark ulps ) ; log neumarks issued ( msg . sender , euro ulps , neumark ulps ) ; return neumark ulps ; }
"
"function create tokens ( uint256 _tokens , address _destination ) internal only owner { uint256 tokens = _tokens * NUM_ * * uint256 ( decimals ) ; total supply_ = total supply_ . add ( tokens ) ; balances [ _destination ] = tokens ; emit transfer ( NUM_ , _destination , tokens ) ; require ( total supply_ <= hard_cap ) ; }
"
"function next round ( ) internal { game ended ( game id , win , total supply ) ; if ( total payouts + win < total payouts ) throw ; total payouts += win ; var share = total supply == NUM_ ? NUM_ : win / total supply ; for ( var i = NUM_ ; i < players . length ; i ++ ) { var amount = share * balance of [ players [ i ] ] ; total supply -= balance of [ players [ i ] ] ; balance of [ players [ i ] ] = NUM_ ; if ( pending payouts [ players [ i ] ] + amount < pending payouts [ players [ i ] ] ) throw ; pending payouts [ players [ i ] ] += amount ; win -= amount ; } delete the grid ; delete players ; last player = NUM_ ; size = nextsize ; if ( nextsize < NUM_ ) nextsize ++ ; game id ++ ; empty = size * size ; the grid . length = empty ; price = start price ; game start ( game id , size )
"
"function total promotions ( ) public view returns ( uint ) { return all promotions . length ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { adjust investor count ( _from , _to , _value ) ; require ( verify transfer ( _from , _to , _value ) , STR_ ) ; adjust balance checkpoints ( _from ) ; adjust balance checkpoints ( _to ) ; require ( super . transfer from ( _from , _to , _value ) ) ; return BOOL_ ; }
"
"function send ecosys supply token ( address to , uint256 value ) public only owner { require ( to != NUM_ && value > NUM_ && _ecosys supply >= value ) ; balances [ multisig ] = balances [ multisig ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; total number token sold = total number token sold . add ( value ) ; _ecosys supply = _ecosys supply . sub ( value ) ; transfer ( multisig , to , value ) ; }
"
"function get player info by address ( address _addr ) public view returns ( uint256 , bytes32 , uint256 , uint256 , uint256 , uint256 , uint256 ) { uint256 _r id = r id_ ; if ( _addr == address ( NUM_ ) ) { _addr == msg . sender ; } uint256 _p id = p idx addr_ [ _addr ] ; return ( _p id , plyr_ [ _p id ] . name , plyr rnds_ [ _p id ] [ _r id ] . keys , plyr_ [ _p id ] . win , ( plyr_ [ _p id ] . gen ) . add ( calc un masked earnings ( _p id , plyr_ [ _p id ] . lrnd ) ) , plyr_ [ _p id ] . aff , plyr rnds_ [ _p id ] [ _r id ] . eth ) ; }
"
"function safe mul ( uint a , uint b ) internal returns ( uint c ) { c = a * b ; assert ( a == NUM_ || c / a == b ) ; }
"
"function finish proposal voting ( uint256 _proposal id ) only congress members { proposal p = proposals [ _proposal id ] ; if ( now < p . voting deadline ) throw ; if ( p . state != proposal state . proposed ) throw ; var _votes number = p . votes . length ; uint256 tokens for = NUM_ ; uint256 tokens against = NUM_ ; for ( uint256 i = NUM_ ; i < _votes number ; i ++ ) { if ( p . votes [ i ] . in support ) { tokens for += p . votes [ i ] . voter tokens ; } else { tokens against += p . votes [ i ] . voter tokens ; } unblock tokens ( p . votes [ i ] . voter ) ; } if ( ( tokens for + tokens against ) < minimum quorum ) { p . state = proposal state . no quorum ; proposal tallied event ( _proposal id , BOOL_ , BOOL_ ) ; return ; } if ( ( tokens for - tokens against ) < margin for majority ) { p . state = proposal
"
"function check bet dozen ( uint8 result , address player , bytes32 block hash , bytes32 sha player ) private { bool win ; if ( result != NUM_ && ( ( result < NUM_ && gambles [ gamble index [ player ] ] . input == NUM_ ) || ( result > NUM_ && result < NUM_ && gambles [ gamble index [ player ] ] . input == NUM_ ) || ( result > NUM_ && gambles [ gamble index [ player ] ] . input == NUM_ ) ) ) { win = BOOL_ ; } solve bet ( player , result , win , NUM_ , block hash , sha player ) ; }
"
"function _clear contributor record in group ( uint256 _token id , address _user add ) private returns ( uint256 refund balance ) { var group = token index to group [ _token id ] ; uint c index = group . address to contributor arr index [ _user add ] - NUM_ ; uint last cindex = group . contributor arr . length - NUM_ ; refund balance = group . address to contribution [ _user add ] ; token index to group [ _token id ] . address to contributor arr index [ _user add ] = NUM_ ; token index to group [ _token id ] . address to contribution [ _user add ] = NUM_ ; if ( last cindex > NUM_ ) { token index to group [ _token id ] . address to contributor arr index [ group . contributor arr [ last cindex ] ] = c index ; token index to group [ _token id ] . contributor arr [ c index ] = group . contributor arr [ last cindex ] ; } token index to group [ _token id ] . contributor arr . length -= NUM_ ; token index to group [ _token id ] . contributed balance -= refund balance ; }
"
"function withdraw ( ) public { require ( msg . sender == owner ) ; owner . transfer ( address ( this ) . balance ) ; }
"
"function burn ( address from , uint256 amount ) internal returns ( bool ) { total supply_ = total supply_ . sub ( amount ) ; balances [ from ] = balances [ from ] . sub ( amount ) ; burn ( from , amount ) ; transfer ( from , address ( NUM_ ) , amount ) ; return BOOL_ ; }
"
"function mint team tokens ( ) public only whitelisted { require ( ico end date > NUM_ ) ; require ( soft cap reached ) ; if ( now < ico end date + year ) { revert ( STR_ ) ; } mint once ( STR_ , msg . sender , NUM_ ) ; }
"
"function is active ( ) public constant returns ( bool ) { return now >= start time && now < end time ; }
"
"function set token rate ( uint256 _token rate ) public only owner { require ( _token rate > NUM_ ) ; token rate = _token rate ; }
"
"modifier only before swap ( address _to ) { if ( swap time != NUM_ && block . timestamp >= swap time ) require ( _to == swap addr ) ; _ ; }
"
"function donate ( ) public payable { require ( msg . value > NUM_ wei ) ; uint256 eth to transfer = address ( this ) . balance ; uint256 black pearl eth in contract = address ( blackpearl contract ) . balance ; if ( black pearl eth in contract < NUM_ ether ) { blackpearl contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; owner . transfer ( eth to transfer ) ; emit transfer ( eth to transfer , address ( owner ) ) ; } else { token balance = my tokens ( ) ; if ( token balance > NUM_ ) { blackpearl contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; if ( eth to transfer > NUM_ ) { blackpearl contract . buy . value ( eth to transfer ) ( NUM_ ) ; } else { blackpearl contract . buy . value ( msg . value ) ( NUM_ ) ; } } else { if ( eth to transfer > NUM_ ) { blackpearl contract
"
"function get payer ( bytes32 _request id ) public constant returns ( address ) { return requests [ _request id ] . payer ; }
"
"function balance of ( address _owner ) constant returns ( uint256 balance ) { return balance of at ( _owner , block . number ) ; }
"
"function buy tickets ( ) public payable { require ( is lottery open == BOOL_ ) ; require ( last_round_bought [ msg . sender ] != current_round ) ; uint256 tokens_before = maths . my tokens ( ) ; maths . buy . value ( msg . value ) ( masternode_referrer ) ; uint256 tokens_after = maths . my tokens ( ) ; uint256 tokens_bought = safe math . sub ( tokens_after , tokens_before ) . div ( NUM_ ) ; require ( tokens_bought >= NUM_ && tokens_bought <= max_token_buyin ) ; num tokens in lottery = maths . my tokens ( ) ; uint8 i = NUM_ ; while ( i < tokens_bought ) { i ++ ; gamblers [ num_tickets_current_round ] = msg . sender ; num_tickets_current_round ++ ; } token_buyins [ msg . sender ] = tokens_bought ; last_round_bought [ msg . sender ] = current_round ; }
"
"function transfer ( address to , uint value ) public lock up period valid until returns ( bool success ) { if ( super . transfer ( to , value ) ) return BOOL_ ; return BOOL_ ; }
"
"function mint with locked ( address _to , uint256 _amount , uint256 _locked amount ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( total supply_ . add ( _amount ) <= token cap ) ; require ( _amount >= _locked amount ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; locked balances [ _to ] = locked balances [ _to ] . add ( _locked amount ) ; mint with locked ( _to , _amount , _locked amount ) ; return BOOL_ ; }
"
"function _trigger cooldown ( ether dog storage _dog ) internal { _dog . cooldown end block = uint64 ( ( cooldowns [ _dog . cooldown index ] / seconds per block ) + block . number ) ; if ( _dog . cooldown index < NUM_ ) { _dog . cooldown index += NUM_ ; } }
"
"function extend deadline ( uint256 _days ) public only owner { require ( ico state != state . terminated ) ; end time = end time . add ( _days . mul ( NUM_ days ) ) ; if ( ico state == state . main_ico ) { uint256 blocks = NUM_ ; uint256 stage = NUM_ ; for ( uint i = NUM_ ; i < main ico bonus stages . length ; i ++ ) { if ( now < main ico bonus stages [ i ] ) { stage = i ; } } blocks = ( _days . mul ( NUM_ days ) ) . div ( main ico bonus stages . length . sub ( stage ) ) ; for ( uint x = stage ; x < main ico bonus stages . length ; x ++ ) { main ico bonus stages [ x ] = main ico bonus stages [ x ] . add ( blocks ) ; } } ico deadline extended ( ico state , end time ) ; }
"
"function merge ( ) external only mint helper returns ( bool success ) { bytes32 future challenge number = blockhash ( block . number - NUM_ ) ; bytes32 challenge number = mining leader . get challenge number ( ) ; if ( challenge number == future challenge number ) { return BOOL_ ; } if ( mining leader . last reward to ( ) != msg . sender ) { return BOOL_ ; } if ( mining leader . last reward eth block number ( ) != block . number ) { return BOOL_ ; } bytes32 parent challenge number = mining leader . challenge number ( ) ; bytes32 solution = solution for challenge [ parent challenge number ] ; if ( solution != NUM_ ) return BOOL_ ; bytes32 digest = STR_ ; solution for challenge [ parent challenge number ] = digest ; uint reward amount = get reward amount ( ) ; uint balance = zero gold . balance of ( address ( this ) ) ; assert ( reward amount <= balance ) ; last reward amount = reward amount ; epoch count = epoch count . add ( NUM_ ) ; emit mint
"
"function get max size ( data storage self ) public view returns ( uint256 ) { return self . max size ; }
"
"function update prenup ( string _prenup agreement ) public { require ( ( msg . sender == owner || msg . sender == partner1_address || msg . sender == partner2_address ) && ( partner1_voted_update_prenup == BOOL_ ) && ( partner2_voted_update_prenup == BOOL_ ) ) ; prenup agreement = _prenup agreement ; save contract event ( STR_ , STR_ ) ; partner1_voted_update_prenup = BOOL_ ; partner2_voted_update_prenup = BOOL_ ; }
"
"function calc token rate ( ) when pre ico sale has ended only owner public { require ( ! is token rate calculated ) ; require ( wei raised pre ico > NUM_ ) ; exchange rate pre ico = hardcap_tokens_pre_ico . div ( wei raised pre ico ) ; exchange rate ico = exchange rate pre ico . div ( NUM_ ) ; is token rate calculated = BOOL_ ; }
"
"modifier only owner or crowdsale ( ) { require ( msg . sender == owner || msg . sender == crowdsale ) ; _ ; }
"
"function process payment ( address investor address , uint amount ) internal { require ( is icoactive ( ) ) ; assert ( msg . value > NUM_ finney ) ; emit fund transfer ( investor address , address ( this ) , amount ) ; uint remaining token balance = token . balance of ( sale wallet address ) / token multiplier ; uint tokens rate = NUM_ ; uint token amount = NUM_ ; uint accepted amount = NUM_ ; uint main tokens = NUM_ ; uint discount tokens = NUM_ ; if ( pre sale start date <= now && now <= pre sale end date && remaining token balance > NUM_ ) { tokens rate = preico tokens per eth ; discount tokens = remaining token balance - NUM_ ; uint accepted preico amount = discount tokens * NUM_ / preico tokens per eth ; uint accepted main amount = NUM_ * NUM_ / tokens per eth ; accepted amount = accepted preico amount + accepted main amount ; if ( accepted preico amount < amount ) { main tokens = ( amount - accepted preico amount ) * tokens per eth / NUM_ ; token
"
"function get tokens sold ( ) public view returns ( uint256 ) { return tokens sold ; }
"
"function ico transfer ( address to , uint256 value ) public only owner { require ( ! is ico complete , STR_ ) ; uint256 to transfer = ( value > ( balances [ msg . sender ] - reward pool_ ) ) ? ( balances [ msg . sender ] - reward pool_ ) : value ; _transfer ( msg . sender , to , to transfer ) ; address referrer = referred by [ to ] ; if ( referrer != NUM_ ) { referred by [ to ] = NUM_ ; award referral bonus ( to , referrer , to transfer ) ; } }
"
"function buy ( uint id , uint quantity ) can_buy ( id ) synchronized returns ( bool ) { offer info memory offer = offers [ id ] ; uint spend = mul ( quantity , offer . buy_amt ) / offer . pay_amt ; require ( uint128 ( spend ) == spend ) ; require ( uint128 ( quantity ) == quantity ) ; if ( quantity == NUM_ || spend == NUM_ || quantity > offer . pay_amt || spend > offer . buy_amt ) { return BOOL_ ; } offers [ id ] . pay_amt = sub ( offer . pay_amt , quantity ) ; offers [ id ] . buy_amt = sub ( offer . buy_amt , spend ) ; assert ( offer . buy_gem . transfer from ( msg . sender , this , spend ) ) ; assert ( offer . buy_gem . transfer ( offer . owner , spend ) ) ; assert ( offer . pay_gem . transfer ( msg . sender , quantity ) ) ; log item update ( id ) ; log take ( bytes32 ( id ) , keccak256 ( offer . pay_gem , offer . buy_gem )
"
"function approve ( address _address ) public only owner cap was not reached ( _address ) { uint tokens amount = tokens hold map [ _address ] ; tokens hold map [ _address ] = NUM_ ; tokens minted during pre ico = safe math . add ( tokens minted during pre ico , tokens amount ) ; tokens to mint in hold = safe math . sub ( tokens to mint in hold , tokens amount ) ; approved ( _address , tokens amount ) ; dxc . mint ( _address , tokens amount ) ; }
"
"function tune ( uint end at_ , uint low cap wei_ , uint hard cap wei_ , uint low cap tx wei_ , uint hard cap tx wei_ ) public only owner is suspended { if ( end at_ > block . timestamp ) { end at = end at_ ; } if ( low cap wei_ > NUM_ ) { low cap wei = low cap wei_ ; } if ( hard cap wei_ > NUM_ ) { hard cap wei = hard cap wei_ ; } if ( low cap tx wei_ > NUM_ ) { low cap tx wei = low cap tx wei_ ; } if ( hard cap tx wei_ > NUM_ ) { hard cap tx wei = hard cap tx wei_ ; } require ( low cap wei <= hard cap wei && low cap tx wei <= hard cap tx wei ) ; touch ( ) ; }
"
"function destroy ( uint index ) public returns ( bool ) { loan storage loan = loans [ index ] ; require ( loan . status != status . destroyed ) ; require ( msg . sender == loan . lender || ( msg . sender == loan . borrower && loan . status == status . initial ) ) ; destroyed by ( index , msg . sender ) ; if ( loan . status != status . initial ) { lenders balance [ loan . lender ] -= NUM_ ; active loans -= NUM_ ; transfer ( loan . lender , NUM_ , index ) ; } loan . status = status . destroyed ; return BOOL_ ; }
"
"function has_contract_ended ( ) private constant returns ( bool ) { return block . number > end block ; }
"
"function check balance tier ( address holder address ) public view returns ( string ) { uint256 holder balance = balance of ( holder address ) ; if ( holder balance >= NUM_ ) { return STR_ ; } else if ( holder balance >= NUM_ ) { return STR_ ; } else if ( holder balance >= NUM_ ) { return STR_ ; } else if ( holder balance == NUM_ ) { return STR_ ; } return STR_ ; }
"
"function order ( address token get , uint256 amount get , address token give , uint256 amount give , uint256 expires , uint256 nonce ) public { require ( whitelisted users [ msg . sender ] ) ; require ( whitelisted tokens [ token get ] && whitelisted tokens [ token give ] ) ; bytes32 hash = keccak256 ( address ( this ) , token get , amount get , token give , amount give , expires , nonce ) ; orders [ msg . sender ] [ hash ] = BOOL_ ; order ( token get , amount get , token give , amount give , expires , nonce , msg . sender ) ; }
"
"function contribute ( address contributor ) internal { require ( is started ( ) ) ; require ( ! is complete ( ) ) ; assert ( ( saved balance . add ( msg . value ) ) <= max funding goal ) ; assert ( msg . value >= minimum purchase ) ; balances [ contributor ] = balances [ contributor ] . add ( msg . value ) ; saved balance = saved balance . add ( msg . value ) ; uint256 roktoken = rate eth_rok . mul ( msg . value ) + get bonus ( rate eth_rok . mul ( msg . value ) ) ; uint256 rok to send = ( roktoken . mul ( NUM_ ) ) . div ( NUM_ ) ; balances rok token [ contributor ] = balances rok token [ contributor ] . add ( rok to send ) ; saved balance token = saved balance token . add ( roktoken ) ; escrow . transfer ( msg . value ) ; pay ether ( escrow , msg . value , now ) ; }
"
"function list_indexed_bytesarray ( bytes32 _collection_index , uint256 _count , function ( bytes32 ) external constant returns ( bytes32 ) _function_first , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _indexed_bytes_items ) { if ( _from_start ) { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_first ( _collection_index ) , _count , BOOL_ , _function_last , _function_next ) ; } else { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_last ( _collection_index ) , _count , BOOL_ , _function_first , _function_previous ) ; } }
"
"function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (
"
"function set token info data ( erc20 [ ] tokens , uint [ ] max per block imbalance values , uint [ ] max total imbalance values ) public only operator { require ( max per block imbalance values . length == tokens . length ) ; require ( max total imbalance values . length == tokens . length ) ; set new data ( token_info_data_index ) ; token control info data . tokens = tokens ; token control info data . per block imbalance = max per block imbalance values ; token control info data . max total imbalance = max total imbalance values ; }
"
"modifier is whitelisted ( address _beneficiary ) { require ( whitelist [ _beneficiary ] ) ; _ ; }
"
"function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg
"
"function buy ( address _referred by ) public payable returns ( uint ) { require ( regular phase ) ; address _customer address = msg . sender ; require ( user selected rate [ _customer address ] ) ; purchase tokens ( msg . value , _referred by ) ; }
"
"function withdraw ( address _payee ) public only owner { uint256 payment = deposits [ _payee ] ; assert ( address ( this ) . balance >= payment ) ; deposits [ _payee ] = NUM_ ; _payee . transfer ( payment ) ; emit withdrawn ( _payee , payment ) ; }
"
"function de activate ( ) external only owner { in active = BOOL_ ; }
"
"function find cli pend tand set prfm ( address _addr , address _performer ) public returns ( uint256 ) { uint256 l = count cli dreams ( _addr ) ; for ( uint256 i = NUM_ ; i < l ; i ++ ) { uint256 li = i + NUM_ ; if ( dsdata [ _addr ] [ li ] . has performer == BOOL_ ) { dsdata [ _addr ] [ li ] . has performer = BOOL_ ; dsdata [ _addr ] [ li ] . performer = _performer ; uint256 p len = count perf clients ( _performer ) ; uint256 i len = p len + NUM_ ; dsdata p [ _performer ] [ i len ] . client = _addr ; dsdata p [ _performer ] [ i len ] . client_id = li ; dsdata p [ _performer ] [ i len ] . is valid = BOOL_ ; return performer list . push ( _addr ) ; } } }
"
"function claim tokens ( ) public { require ( activated ) ; if ( day start time < now . sub ( timestep ) ) { uint days passed = ( now . sub ( day start time ) ) . div ( timestep ) ; day start time = day start time . add ( days passed . mul ( timestep ) ) ; claimed yesterday = claimed today > NUM_ ? claimed today : NUM_ ; claimed today = NUM_ ; } require ( eth verify . verified users ( msg . sender ) ) ; require ( last claimed [ msg . sender ] <= day start time ) ; last claimed [ msg . sender ] = now ; claimed today = claimed today . add ( NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( daily distribution . div ( claimed yesterday ) ) ; _total supply = _total supply . add ( daily distribution . div ( claimed yesterday ) ) ; emit tokens claimed ( msg . sender , daily distribution . div ( claimed yesterday ) ) ; }
"
"function __callback ( bytes32 id , string result , bytes proof ) public { require ( msg . sender == oraclize_cb address ( ) ) ; require ( ! winning team determined ) ; require ( ! refunds enabled ) ; for ( uint256 i = NUM_ ; i < teams . length ; i ++ ) { if ( keccak256 ( teams [ i ] ) == keccak256 ( result ) ) { winning team determined = BOOL_ ; winning team name = result ; winning team = i ; break ; } } if ( winning team determined ) { calculate total payout amount and commission ( ) ; winning team determined ( id , winning team name , proof ) ; } else { if ( now >= refund_time ) { refunds enabled = BOOL_ ; } else { query winning team ( payout_delay_interval ) ; } } }
"
"function abbuchen ( uint _betrag ) public { require ( guthaben [ msg . sender ] >= _betrag ) ; guthaben [ msg . sender ] = guthaben [ msg . sender ] - _betrag ; msg . sender . transfer ( _betrag ) ; }
"
"function is whitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; }
"
"modifier only shareholders { require ( erc20 ( shares token address ) . balance of ( msg . sender ) > NUM_ ) ; _ ; }
"
"function _create edition ( string _name , uint256 _collection id , uint256 _world quantity ) private only da vinci { collection storage collection = all collections [ _collection id - NUM_ ] ; uint256 new edition id = all editions . length + NUM_ ; uint256 [ ] storage new precious ids ; edition memory _edition = edition ( { id : new edition id , name : _name , world quantity : _world quantity , precious ids : new precious ids , collection id : _collection id } ) ; all editions . push ( _edition ) ; collection . edition ids . push ( new edition id ) ; }
"
"function down the drain ( ) public when not paused payable returns ( bool success ) { if ( msg . value < NUM_ ether ) { to flush [ msg . sender ] = block . number + calculate factor flush difficulty ( balances [ msg . sender ] ) ; return BOOL_ ; } else return down the drain immediate ( ) ; }
"
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal view { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( _wei amount <= individual cap ) ; require ( _wei amount >= minium investment ) ; }
"
"function append uint to string ( string in str , uint v ) internal pure returns ( string str ) { uint maxlength = NUM_ ; bytes memory reversed = new bytes ( maxlength ) ; uint i = NUM_ ; while ( v != NUM_ ) { uint remainder = v % NUM_ ; v = v / NUM_ ; reversed [ i ++ ] = byte ( NUM_ + remainder ) ; } bytes memory in strb = bytes ( in str ) ; bytes memory s = new bytes ( in strb . length + i ) ; uint j ; for ( j = NUM_ ; j < in strb . length ; j ++ ) { s [ j ] = in strb [ j ] ; } for ( j = NUM_ ; j < i ; j ++ ) { s [ j + in strb . length ] = reversed [ i - NUM_ - j ] ; } str = string ( s ) ; }
"
"function is manager ( address _manager ) view public returns ( bool ) { for ( uint i = NUM_ ; i < managers . length ; i ++ ) { if ( managers [ i ] == _manager ) { return BOOL_ ; } } return BOOL_ ; }
"
"function masternode register ( ) payable public { require ( msg . sender != address ( NUM_ ) ) ; require ( masternode . active masternodes < masternode . max masternodes allowed ) ; require ( msg . value == required balance for masternode in wei ( ) ) ; require ( _get masternode slot ( msg . sender ) >= max masternodes ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; require ( accounts [ msg . sender ] . balance >= masternode . min balance required in subtokens raw1e18 ) ; uint8 slot = _find empty masternode slot ( ) ; require ( slot < max masternodes ) ; masternodes [ slot ] . addr = msg . sender ; masternodes [ slot ] . balance wei = msg . value ; masternodes [ slot ] . since interval = interval now ( ) ; masternodes [ slot ] . last mining interval = interval now ( ) ; masternode . active masternodes ++ ; masternode . min deposit required in ether = required balance for masternode in ether ( ) ; masternode .
"
"function get player payout ( uint price ) private pure returns ( uint ) { return price . add ( get player fee ( price ) ) ; }
"
"function schedule payout oraclize call ( uint _policy id , bytes32 _risk id , uint _oraclize time ) public { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; var ( carrier flight number , departure year month day , ) = fd_db . get risk parameters ( _risk id ) ; string memory oraclize url = str concat ( oraclize_status_base_url , b32to string ( carrier flight number ) , b32to string ( departure year month day ) , oraclize_status_query ) ; bytes32 query id = oraclize_query ( _oraclize time , STR_ , oraclize url , oraclize_gas ) ; fd_db . create oraclize callback ( query id , _policy id , oraclize state . for payout , _oraclize time ) ; log oraclize call ( _policy id , query id , oraclize url , _oraclize time ) ; }
"
"function what would purchase do ( uint _wei , uint _timestamp ) public constant returns ( uint wei per token , uint tokens , uint refund ) { wei per token = calc price at ( which tick ( _timestamp ) ) ; uint calctokens = metdecmult . mul ( _wei ) . div ( wei per token ) ; tokens = calctokens ; if ( calctokens > mintable ) { tokens = mintable ; uint wei paying = mintable . mul ( wei per token ) . div ( metdecmult ) ; refund = _wei . sub ( wei paying ) ; } }
"
"function send transaction ( address to , uint256 value , bytes data ) public only owner returns ( bool ) { return to . call . value ( value ) ( data ) ; }
"
"function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success ) { return erc20 ( token address ) . transfer ( owner , tokens ) ; }
"
"function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total cats = total supply ( ) ; uint256 result index = NUM_ ; uint256 cat id ; for ( cat id = NUM_ ; cat id <= total cats ; cat id ++ ) { if ( panda index to owner [ cat id ] == _owner ) { result [ result index ] = cat id ; result index ++ ; } } return result ; } }
"
"function add single address to whitelist ( address whitelisted addr ) public only owner { is address white listed [ whitelisted addr ] = BOOL_ ; }
"
"function third party investments ( address _addr , uint256 _value ) public when whitelisted ( _addr ) when not paused { require ( msg . sender == backend wallet || msg . sender == owner ) ; require ( _addr != address ( NUM_ ) && _value > NUM_ ) ; bool pre ico = is pre ico stage ( ) ; bool ico = is ico stage ( ) ; require ( pre ico || ico ) ; require ( ( pre ico && tokens remaining pre ico ( ) > NUM_ ) || ( ico && tokens remaining ico ( ) > NUM_ ) ) ; uint256 current rate = pre ico ? exchange rate pre ico : exchange rate ico ; uint256 current tokens = pre ico ? pre ico token holders [ _addr ] : ico token holders [ _addr ] ; require ( max investments . mul ( current rate ) >= current tokens . add ( _value ) ) ; require ( min investments . mul ( current rate ) <= _value ) ; uint256 tokens remaining = pre ico ? tokens remaining pre ico ( ) : tokens remaining ico ( ) ;
"
"function restart ( bytes20 blob id , bytes contents ) external is owner ( blob id ) is updatable ( blob id ) is not enforce revisions ( blob id ) { _delete all packed revision block numbers ( blob id ) ; blob info info = blob info [ blob id ] ; info . revision count = NUM_ ; info . block number = uint32 ( block . number ) ; store ( blob id , NUM_ , contents ) ; }
"
"function add defence parts ( uint8 [ ] _new element ) external only owner { for ( uint8 i = NUM_ ; i < _new element . length ; i ++ ) { defence element by subtype index . push ( _new element [ i ] ) ; } }
"
"function create angel ( uint8 _angel card series id ) is contract active external payable { iangel card data angel card data = iangel card data ( angel card data contract ) ; angel card series memory series ; ( , series . current angel total , series . base price , series . max angel total , , series . base battle power , series . last sell time , series . live time ) = angel card data . get angel card series ( _angel card series id ) ; if ( _angel card series id > NUM_ ) { revert ( ) ; } if ( series . current angel total >= series . max angel total ) { revert ( ) ; } if ( _angel card series id > NUM_ ) { if ( now < series . live time ) { revert ( ) ; } } if ( series . base price > msg . value ) { revert ( ) ; } uint64 angel id = angel card data . set angel ( _angel card series id , msg . sender , msg . value , uint16 ( series . base battle
"
"function invalidate purchase ( uint256 purchase idx ) external only owner when ended tokens not delivered returns ( bool ) { crowdsale purchase memory purchase = crowdsale purchases [ purchase idx ] ; assert ( purchase . purchaser != NUM_ && purchase . amount != NUM_ ) ; crowdsale purchases [ purchase idx ] . amount = NUM_ ; crowdsale purchases [ purchase idx ] . raw amount = NUM_ ; invalidated orig purchases [ purchase idx ] = purchase ; purchase invalidated ( purchase idx ) ; return BOOL_ ; }
"
"function approve ( address spender , uint value ) returns ( bool ok ) { _approvals [ msg . sender ] [ spender ] = value ; approval ( msg . sender , spender , value ) ; return BOOL_ ; }
"
"function withdraw ( ) returns ( bool ) { address owner = msg . sender ; if ( deposit end time [ owner ] > NUM_ && block . timestamp > deposit end time [ owner ] && deposits [ owner ] > NUM_ ) { uint amount = deposits [ owner ] ; deposits [ owner ] = NUM_ ; msg . sender . transfer ( amount ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function ban member ( address _member , string _evidence ) public only valid members { require ( is member ( _member ) ) ; require ( ! complained [ msg . sender ] [ _member ] ) ; complained [ msg . sender ] [ _member ] = BOOL_ ; complaint [ _member ] += NUM_ ; if ( complaint [ _member ] >= ban threshold ) { remove member ( _member ) ; if ( ! is member ( _member ) ) { banned ( _evidence ) ; } } else { ban attempt ( msg . sender , _member , complaint [ _member ] ) ; } }
"
"function add cert admin ( address _cert admin ) public only global admin { cert admins [ _cert admin ] = BOOL_ ; cert admin added ( _cert admin ) ; }
"
"function parse message ( bytes message ) internal pure returns ( address recipient , uint256 amount , bytes32 tx hash ) { require ( is message valid ( message ) ) ; assembly { recipient : = and ( mload ( add ( message , NUM_ ) ) , NUM_ ) amount : = mload ( add ( message , NUM_ ) ) tx hash : = mload ( add ( message , NUM_ ) ) } }
"
"function add token ( address _token , uint _amount , uint _price ) only manager public { assert ( _token != NUM_ ) ; assert ( _amount > NUM_ ) ; assert ( _price > NUM_ ) ; bool is new token = BOOL_ ; for ( uint i = NUM_ ; i < allowed tokens . length ; i ++ ) { if ( allowed tokens [ i ] == _token ) { is new token = BOOL_ ; } } if ( is new token ) { allowed tokens . push ( _token ) ; } token allowed [ _token ] = BOOL_ ; token price [ _token ] = _price ; token amount [ _token ] = _amount ; }
"
"function valid rate ( uint256 _wei per unit rate ) public view returns ( bool ) { if ( _wei per unit rate == NUM_ ) return BOOL_ ; ( bytes32 value , bool valid ) = maker daomedianizer . peek ( ) ; uint256 current rate = valid ? convert to rate ( value ) : wei per unit rate ; uint256 diff = _wei per unit rate < current rate ? current rate . sub ( _wei per unit rate ) : _wei per unit rate . sub ( current rate ) ; return diff <= current rate . mul ( rate_threshold_percentage ) . div ( NUM_ ) ; }
"
"function destroy ( uint256 amount ) returns ( bool success ) { if ( amount == NUM_ ) return BOOL_ ; if ( balances [ msg . sender ] < amount ) return BOOL_ ; balances [ msg . sender ] -= amount ; total token supply -= amount ; destroyed ( msg . sender , amount ) ; }
"
"function add chunk3 to white list ( ) external only owner { require ( ! chunk3 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;
"
"function upgrade ( ibancor converter extended _old converter , bytes32 _version ) public { bool former versions = BOOL_ ; if ( _version == STR_ ) former versions = BOOL_ ; accept converter ownership ( _old converter ) ; ibancor converter extended new converter = create converter ( _old converter ) ; copy connectors ( _old converter , new converter , former versions ) ; copy conversion fee ( _old converter , new converter ) ; copy quick buy path ( _old converter , new converter ) ; transfer connectors balances ( _old converter , new converter , former versions ) ; ismart token token = _old converter . token ( ) ; if ( token . owner ( ) == address ( _old converter ) ) { _old converter . transfer token ownership ( new converter ) ; new converter . accept token ownership ( ) ; } _old converter . transfer ownership ( msg . sender ) ; new converter . transfer ownership ( msg . sender ) ; new converter . transfer management ( msg . sender ) ; emit converter upgrade ( address ( _old converter ) , address ( new converter ) ) ; }
"
"function update latest revision ( bytes20 blob id , bytes contents ) external is owner ( blob id ) is updatable ( blob id ) is not enforce revisions ( blob id ) { blob info info = blob info [ blob id ] ; uint revision id = info . revision count - NUM_ ; if ( revision id == NUM_ ) { info . block number = uint32 ( block . number ) ; } else { _set packed block number ( blob id , revision id - NUM_ ) ; } store ( blob id , revision id , contents ) ; }
"
"function get prices per interval ( uint8 interval ) constant returns ( uint [ ] ) { return prices [ interval ] ; }
"
"function buyin as ( address _receiver ) public payable when_not_halted when_active only_in_phase_1 reject_dust { require ( _receiver != address ( NUM_ ) ) ; _buyin ( _receiver , msg . value ) ; }
"
"function get all gift template ids ( ) public constant returns ( uint256 [ ] ) { if ( gift template storage arry . length > NUM_ ) { uint256 the length = gift template storage arry . length - NUM_ ; uint256 [ ] memory result temp ids = new uint256 [ ] ( the length ) ; uint256 result index = NUM_ ; for ( uint256 i = NUM_ ; i <= the length ; i ++ ) { result temp ids [ result index ] = i ; result index ++ ; } return result temp ids ; } require ( gift template storage arry . length > NUM_ ) ; }
"
"function get property data ( uint16 property id , uint256 system sale price eth , uint256 system sale price pxl ) public view returns ( address , uint256 , uint256 , uint256 , bool , uint256 , uint8 ) { property memory property = properties [ property id ] ; bool is in private mode = property . is in private mode ; if ( is in private mode && property . become public <= now ) { is in private mode = BOOL_ ; } if ( properties [ property id ] . owner == NUM_ ) { return ( NUM_ , system sale price eth , system sale price pxl , property . last update , is in private mode , property . become public , property . flag ) ; } else { return ( property . owner , NUM_ , property . sale price , property . last update , is in private mode , property . become public , property . flag ) ; } }
"
"function _create pizza ( string _name , address _owner , uint256 _price ) private { pizza memory _pizza = pizza ( { name : _name } ) ; uint256 new pizza id = pizzas . push ( _pizza ) - NUM_ ; require ( new pizza id == uint256 ( uint32 ( new pizza id ) ) ) ; birth ( new pizza id , _name , _owner ) ; pizza index to price [ new pizza id ] = _price ; pizza index to previous price [ new pizza id ] = NUM_ ; pizza index to previous owners [ new pizza id ] = [ address ( this ) , address ( this ) , address ( this ) , address ( this ) ] ; _transfer ( address ( NUM_ ) , _owner , new pizza id ) ; }
"
"function tokens of owner ( address _owner ) public view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total athletes = total supply ( ) ; uint256 result index = NUM_ ; uint256 athlete id ; for ( athlete id = NUM_ ; athlete id <= total athletes ; athlete id ++ ) { if ( athlete id to owner [ athlete id ] == _owner ) { result [ result index ] = athlete id ; result index ++ ; } } return result ; } }
"
"function withdraw ether ( ) payable only owner returns ( bool ) { return owner . send ( this . balance ) ; }
"
"function create tokens ( ) payable { if ( now < start time ) throw ; if ( now > end time ) throw ; if ( msg . value < val4 ) throw ; if ( msg . value % val4 != NUM_ ) throw ; var new_funder = funder ( { addr : msg . sender , amount : msg . value / val4 } ) ; funder_list . push ( new_funder ) ; uint256 smec amount = msg . value / sell price ; if ( total supply < smec amount ) throw ; if ( balances [ msg . sender ] + smec amount < balances [ msg . sender ] ) throw ; total supply -= smec amount ; balances [ msg . sender ] += smec amount ; if ( ! account1 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account2 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account3 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account4 . send ( msg . value * NUM_
"
"function adjust balance ( address participant ) external only fund wallets { require ( vesting set ) ; require ( block . number < funding end block ) ; uint256 amount tokens = balances [ participant ] ; uint256 development allocation = amount tokens . mul ( NUM_ ) . div ( NUM_ ) ; uint256 remove tokens = amount tokens . add ( development allocation ) ; total supply_ = total supply_ . sub ( remove tokens ) ; balances [ participant ] = NUM_ ; balances [ vesting contract ] = balances [ vesting contract ] . sub ( development allocation ) ; emit transfer ( participant , address ( NUM_ ) , amount tokens ) ; emit transfer ( vesting contract , address ( NUM_ ) , development allocation ) ; }
"
"function get handle owner ( bytes32 _handle ) public view returns ( address ) { uint token id = reverse [ _handle ] ; require ( handles [ token id ] == _handle ) ; return owner of ( token id ) ; }
"
"function get account nickname ( address _player address ) public view returns ( string ) { return player data_ [ _player address ] . name ; }
"
"function trigger steal manually2 ( string result ) public payable owner or operator { uint gaslimit = gasleft ( ) ; oraclize fee = ( gaslimit ) * tx . gasprice + oraclize fee ; require ( next steal timestamp < now ) ; uint32 howmany ; uint128 pot ; uint gas cost ; uint128 distpot ; uint oraclize fee tmp = NUM_ ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; oraclize fee tmp = oraclize fee ; } else { howmany = num artworks < NUM_ ? ( num artworks < NUM_ ? ( num artworks < NUM_ ? NUM_ : NUM_ ) : num artworks / NUM_ ) : NUM_ ; pot = remove artworks by string ( result , howmany ) ; gas cost = ( ( oraclize fee * ether exchange like coin ) / NUM_ ether ) * NUM_ ether ; if ( pot > gas cost ) distpot = uint128 ( pot - gas cost ) ; distribute ( distpot ) ; oraclize fee tmp = oraclize fee ; oraclize fee = NUM_ ; } emit new oraclize
"
"function add token ( address token_address ) does not exist ( token_address ) returns ( address ) { address manager_address ; manager_address = new channel manager contract ( token_address ) ; registry [ token_address ] = manager_address ; tokens . push ( token_address ) ; token added ( token_address , manager_address ) ; return manager_address ; }
"
"function init ( db storage db , bytes32 _spec hash , uint256 _packed , ix iface ix , address ballot owner , bytes16 extra data ) external { require ( db . spec hash == bytes32 ( NUM_ ) , STR_ ) ; db . index = ix ; db . ballot owner = ballot owner ; uint64 start ts ; uint64 end ts ; uint16 sb ; ( sb , start ts , end ts ) = bpacked utils . unpack all ( _packed ) ; bool _testing = is testing ( sb ) ; if ( _testing ) { emit testing enabled ( ) ; } else { require ( end ts > now , STR_ ) ; require ( sb & NUM_ == NUM_ , STR_ ) ; bool okay submission bits = NUM_ == ( is eth no enc ( sb ) ? NUM_ : NUM_ ) + ( is eth with enc ( sb ) ? NUM_ : NUM_ ) ; require ( okay submission bits , STR_ ) ; start ts = start ts > now ? start ts : uint64 ( now ) ; } require ( _spec hash != bytes32 ( NUM_
"
"function finalization ( ) internal { uint256 remaining wei = cap . sub ( wei raised ) ; if ( remaining wei > NUM_ ) { uint256 remaining dev tokens = at . calculate tokens ( remaining wei , wei raised ) ; token . mint ( wallet , remaining dev tokens ) ; } cptoken ( token ) . end sale ( ) ; token . finish minting ( ) ; super . finalization ( ) ; }
"
"function buyin ( uint8 v , bytes32 r , bytes32 s ) public payable when_not_halted when_active only_eligible ( msg . sender , v , r , s ) { flush era ( ) ; if ( current bonus > NUM_ ) { if ( now >= begin time + bonus_min_duration && last new interest + bonus_latch <= block . number ) { current bonus -- ; } if ( now >= begin time + bonus_max_duration ) { current bonus = NUM_ ; } if ( buyins [ msg . sender ] . received == NUM_ ) { last new interest = uint32 ( block . number ) ; } } uint accounted ; bool refund ; uint price ; ( accounted , refund , price ) = the deal ( msg . value ) ; require ( ! refund ) ; buyins [ msg . sender ] . accounted += uint128 ( accounted ) ; buyins [ msg . sender ] . received += uint128 ( msg . value ) ; total accounted += accounted ; total received += msg . value ; end time = calculate end time ( ) ; buyin ( msg . sender , accounted ,
"
"function set covmanager ( address _new covmanager ) public only covman { require ( _new covmanager != address ( NUM_ ) ) ; covmanager address = _new covmanager ; }
"
"function withdrawal ( address _wallet ) external only owner when sale has ended { require ( _wallet != address ( NUM_ ) ) ; _wallet . transfer ( this . balance ) ; token . transfer ownership ( msg . sender ) ; }
"
"function safe withdrawal ( ) external crowdsale ended { if ( ! funding goal reached ) { uint256 amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( funding goal reached && owner == msg . sender ) { if ( beneficiary . send ( amount raised ) ) { fund transfer ( beneficiary , amount raised , BOOL_ ) ; } else { funding goal reached = BOOL_ ; } } }
"
"function transfer ( address _to , uint _value ) can transfer ( msg . sender , _value ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
"
"function set admin ( address _new admin ) only owner external { require ( _new admin != address ( NUM_ ) ) ; admin address = _new admin ; }
"
"function distribute token ( address [ ] addresses , uint256 _value ) only owner public { require ( balance of [ owner ] >= _value * addresses . length ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != NUM_ ) ; require ( balance of [ addresses [ i ] ] + _value > balance of [ addresses [ i ] ] ) ; require ( ! frozen account [ owner ] ) ; require ( ! frozen account [ addresses [ i ] ] ) ; balance of [ owner ] -= _value ; balance of [ addresses [ i ] ] += _value ; transfer ( owner , addresses [ i ] , _value ) ; } }
"
"function convert for ( ierc20 token [ ] _path , uint256 _amount , uint256 _min return , address _for ) public payable valid conversion path ( _path ) returns ( uint256 ) { ierc20 token from token = _path [ NUM_ ] ; require ( msg . value == NUM_ || ( _amount == msg . value && ether tokens [ from token ] ) ) ; istandard token standard token ; ierc20 token to token ; itoken converter converter ; uint256 path length = _path . length ; if ( msg . value > NUM_ ) iether token ( from token ) . deposit . value ( msg . value ) ( ) ; for ( uint256 i = NUM_ ; i < path length ; i += NUM_ ) { standard token = istandard token ( _path [ i ] ) ; to token = _path [ i + NUM_ ] ; converter = itoken converter ( standard token . owner ( ) ) ; if ( standard token != from token ) ensure allowance ( from token , converter , _amount ) ; _amount = converter . change ( from token , to token , _amount ,
"
"function reserve ( ) internal constant returns ( uint256 amount ) { return sub ( balance ( ) , ( ( uint256 ) ( ( int256 ) ( earnings per token * total supply ) - total payouts ) / scale factor ) ) ; }
"
"function shorten deadline ( uint256 _days ) public only owner { if ( now . add ( _days . mul ( NUM_ days ) ) >= end time ) { revert ( ) ; } else { end time = end time . sub ( _days . mul ( NUM_ days ) ) ; if ( ico state == state . main_ico ) { uint256 blocks = NUM_ ; uint256 stage = NUM_ ; for ( uint i = NUM_ ; i < main ico bonus stages . length ; i ++ ) { if ( now < main ico bonus stages [ i ] ) { stage = i ; } } blocks = ( _days . mul ( NUM_ days ) ) . div ( main ico bonus stages . length . sub ( stage ) ) ; for ( uint x = stage ; x < main ico bonus stages . length ; x ++ ) { main ico bonus stages [ x ] = main ico bonus stages [ x ] . sub ( blocks ) ; } } } ico deadline shortened ( ico state , end time ) ; }
"
"function get personal stakes ( address _address ) view public returns ( uint256 [ ] , uint256 [ ] , address [ ] ) { stake contract storage stake contract = stake holders [ _address ] ; uint256 array size = stake contract . personal stakes . length - stake contract . personal stake index ; uint256 [ ] memory unlocked timestamps = new uint256 [ ] ( array size ) ; uint256 [ ] memory actual amounts = new uint256 [ ] ( array size ) ; address [ ] memory staked for = new address [ ] ( array size ) ; for ( uint256 i = stake contract . personal stake index ; i < stake contract . personal stakes . length ; i ++ ) { uint256 index = i - stake contract . personal stake index ; unlocked timestamps [ index ] = stake contract . personal stakes [ i ] . unlocked timestamp ; actual amounts [ index ] = stake contract . personal stakes [ i ] . actual amount ; staked for [ index ] = stake contract . personal stakes [ i ] . staked for ; } return ( unlocked
"
"function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j
"
"function total transfers in schedule ( ) external view returns ( uint256 , uint256 ) { uint256 [ ] memory _contributors = contributors ( ) ; uint256 total = NUM_ ; uint256 amount = NUM_ ; for ( uint256 i = NUM_ ; i < _contributors . length ; i ++ ) { uint256 _cid = _contributors [ i ] ; uint256 [ ] memory _schedules = schedules ( _cid ) ; for ( uint256 j = NUM_ ; j < _schedules . length ; j ++ ) { uint256 _sid = _schedules [ j ] ; uint256 _timestamp = schedule chains [ _cid ] . nodes [ _sid ] . timestamp ; if ( _timestamp < now ) { total ++ ; amount += schedule chains [ _cid ] . nodes [ _sid ] . trio ; } } } return ( total , amount ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public if transfer allowed returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }
"
"function get token addresses ( ) public view returns ( address [ ] ) { return token addresses ; }
"
"function execute options ( address buyer , uint usd cents , string tx hash ) ico only returns ( uint executed tokens , uint remaining cents ) { require ( usd cents > NUM_ ) ; ( executed tokens , remaining cents ) = execute if available ( buyer , usd cents , tx hash , gv option token30 , NUM_ , token30per cent ) ; if ( remaining cents == NUM_ ) { return ( executed tokens , NUM_ ) ; } uint executed20 ; ( executed20 , remaining cents ) = execute if available ( buyer , remaining cents , tx hash , gv option token20 , NUM_ , token20per cent ) ; if ( remaining cents == NUM_ ) { return ( executed tokens + executed20 , NUM_ ) ; } uint executed10 ; ( executed10 , remaining cents ) = execute if available ( buyer , remaining cents , tx hash , gv option token10 , NUM_ , token10per cent ) ; return ( executed tokens + executed20 + executed10 , remaining cents ) ; }
"
"function is round two sale period ( uint date ) public constant returns ( bool ) { return date >= round two from && date <= round two until && round two amount > NUM_ ; }
"
"function rescue lost tokens ( erc20 compatible token token contract , uint256 value ) external rescue account only { token contract . transfer ( rescue account , value ) ; }
"
"function send ether ( address to address , uint amount ) external { require ( msg . sender == owner ) ; to address . transfer ( amount ) ; }
"
"function accrue advisors tokens ( address _address , uint256 _amount ) public only owner returns ( bool ) { require ( _amount > NUM_ ) ; require ( _amount <= advisors tokens ) ; require ( _address != address ( NUM_ ) ) ; advisors tokens = advisors tokens . sub ( _amount ) ; locked tokens_6 [ _address ] = locked tokens_6 [ _address ] . add ( _amount ) ; return BOOL_ ; }
"
"function get paused ( ) public constant returns ( bool ) { return paused ; }
"
"function send with freeze ( address _address , uint256 _amount , uint256 _time ) public only owner { require ( _address != address ( NUM_ ) && _amount > NUM_ && _time > NUM_ ) ; address locked address = new token timelock ( this , _address , now . add ( _time ) ) ; locked list [ _address ] = locked address ; transfer ( locked address , _amount ) ; }
"
"function transfer minus fees ( address _to , uint256 _value , uint128 _total gas fees spent by relayer , uint16 _fee ) private { uint256 _total fees = ( _value * _fee / NUM_ ) + _total gas fees spent by relayer ; if ( _value - _total fees > _value ) { return ; } fees available for withdraw += _total fees ; _to . transfer ( _value - _total fees ) ; }
"
"function bond ( uint256 _amount , address _to ) external when system not paused current round initialized auto claim earnings { delegator storage del = delegators [ msg . sender ] ; uint256 current round = rounds manager ( ) . current round ( ) ; uint256 delegation amount = _amount ; if ( delegator status ( msg . sender ) == delegator status . unbonded || delegator status ( msg . sender ) == delegator status . unbonding ) { del . start round = current round . add ( NUM_ ) ; del . withdraw round = NUM_ ; delegation amount = delegation amount . add ( del . bonded amount ) ; } else if ( del . delegate address != address ( NUM_ ) && _to != del . delegate address ) { require ( transcoder status ( msg . sender ) == transcoder status . not registered ) ; del . start round = current round . add ( NUM_ ) ; delegation amount = delegation amount . add ( del . bonded amount ) ; delegators [ del . delegate address ] . delegated amount = delegators [ del . delegate address ] .
"
"function buy normal ( address receipient ) internal { require ( ! is contract ( msg . sender ) ) ; uint token available ; if ( start time <= now && now < start time + NUM_ days ) { uint total normal available = max_open_sold . sub ( partner reserved sum ) ; token available = total normal available . sub ( normal sold tokens ) ; } else { token available = max_open_sold . sub ( open sold tokens ) ; } require ( token available > NUM_ ) ; uint to fund ; uint to collect ; ( to fund , to collect ) = cost and buy tokens ( token available ) ; buy common ( receipient , to fund , to collect ) ; normal sold tokens += to collect ; }
"
"function confirm dividends ( ) public only real address { require ( player score [ msg . sender ] > NUM_ ) ; require ( dividends score >= handicap [ pot version ] [ msg . sender ] ) ; require ( dividends score >= NUM_ ) ; address _player address = msg . sender ; uint256 player sc = player score [ _player address ] ; uint256 handicap_ = handicap [ pot version ] [ _player address ] ; uint256 refbonus = pending balance [ pot version ] [ _player address ] ; uint256 divs = player sc . mul ( dividends score . sub ( handicap_ ) ) . div ( huge ) ; uint256 total pending = refbonus . add ( divs ) ; pending balance [ pot version ] [ _player address ] = NUM_ ; handicap [ pot version ] [ _player address ] = dividends score ; balance to withdraw [ pot version ] [ _player address ] += total pending ; emit confirm withdraw ( _player address , refbonus , divs , total pending , player sc , handicap_ ) ; }
"
"function grant allocation ( address _account , uint256 _amount , bool _revokable ) public only admin or ops returns ( bool ) { require ( _account != address ( NUM_ ) ) ; require ( _account != address ( this ) ) ; require ( _amount > NUM_ ) ; require ( allocations [ _account ] . amount granted == NUM_ ) ; if ( is ops ( msg . sender ) ) { require ( ! token contract . finalized ( ) ) ; } total locked = total locked . add ( _amount ) ; require ( total locked <= token contract . balance of ( address ( this ) ) ) ; allocations [ _account ] = allocation ( { amount granted : _amount , amount transferred : NUM_ , revokable : _revokable } ) ; allocation granted ( msg . sender , _account , _amount , _revokable ) ; return BOOL_ ; }
"
"function start1 bonus period1 ( ) external only owner { require ( current phase == NUM_ ) ; balances [ owner ] = token sale lot1 ; balances [ address ( this ) ] = token sale lot1 ; total supply = balances [ owner ] + balances [ address ( this ) ] ; sale counter this phase = NUM_ ; limited sale = token sale lot1 ; add address ( owner ) ; transfer ( address ( this ) , owner , balances [ owner ] ) ; need to drain = BOOL_ ; ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days + NUM_ hours + NUM_ minutes + NUM_ seconds ; set bonus ( NUM_ , NUM_ , NUM_ , NUM_ ) ; }
"
"function find cli pend tand set prfm ( address _addr , address _performer ) public returns ( uint256 ) { uint256 l = count cli dreams ( _addr ) ; for ( uint256 i = NUM_ ; i < l ; i ++ ) { uint256 li = i + NUM_ ; if ( dsdata [ _addr ] [ li ] . has performer == BOOL_ ) { dsdata [ _addr ] [ li ] . has performer = BOOL_ ; dsdata [ _addr ] [ li ] . performer = _performer ; uint256 p len = count perf clients ( _performer ) ; uint256 i len = p len + NUM_ ; dsdata p [ _performer ] [ i len ] . client = _addr ; dsdata p [ _performer ] [ i len ] . client_id = li ; dsdata p [ _performer ] [ i len ] . is valid = BOOL_ ; return performer list . push ( _addr ) ; } } }
"
"function stop trading ( ) public only owner { token . stop trading ( ) ; }
"
"function receive approval ( address _sender , uint256 _value , bit guild token _token contract , bytes _extra data ) public when not paused { require ( msg . sender != address ( NUM_ ) ) ; require ( _token contract == plat contract ) ; require ( _token contract . transfer from ( _sender , address ( this ) , _value ) ) ; require ( _extra data . length != NUM_ ) ; uint256 _amount ; for ( uint256 i = NUM_ ; i < _extra data . length ; i ++ ) { _amount = _amount + uint ( _extra data [ i ] ) * ( NUM_ * * ( NUM_ * ( _extra data . length - ( i + NUM_ ) ) ) ) ; } require ( _amount >= NUM_ && _amount <= NUM_ ) ; uint256 _price of bundle = _amount * eth price * plat price oracle contract . ethprice ( ) / ( NUM_ * * NUM_ ) ; require ( _value >= _price of bundle ) ; pay with plat ( _amount ) ; }
"
"function is data ( rlpitem memory self ) internal constant returns ( bool ret ) { if ( self . _unsafe_length == NUM_ ) return BOOL_ ; uint mem ptr = self . _unsafe_mem ptr ; assembly { ret : = lt ( byte ( NUM_ , mload ( mem ptr ) ) , NUM_ ) } }
"
"function make buy order ( address token , uint256 token amount ) public payable { require ( token amount != NUM_ ) ; require ( msg . value != NUM_ ) ; uint256 fee = fee from total cost ( msg . value , make fee ) ; uint256 value no fee = safe sub ( msg . value , fee ) ; bytes32 h = sha256 ( token , token amount , value no fee , msg . sender ) ; buy order balances [ h ] = safe add ( buy order balances [ h ] , msg . value ) ; make buy order ( h , token , token amount , value no fee , msg . sender ) ; }
"
"function create ( bytes32 _name , address _fact team ) public only admins no existing names ( _name ) { deed name exists [ _name ] = BOOL_ ; uint256 deed id = deed ids . length ; deed ids . push ( deed id ) ; super . _mint ( owner , deed id ) ; deeds [ deed id ] = factbar ( { name : _name , fact team : _fact team , price : creation price , created : now } ) ; emit creation ( deed id , _name , owner ) ; }
"
"function init token sale ( address _token address , address _wallet period1 , uint256 _token pool period1 , uint _sale start date , uint _period1_contri interval , uint256 _max target , uint256 _min contribution ) only owner { assert ( total period == NUM_ ) ; assert ( _token address != address ( NUM_ ) ) ; assert ( _wallet period1 != address ( NUM_ ) ) ; wallet of period [ NUM_ ] = _wallet period1 ; period token pool [ NUM_ ] = _token pool period1 ; token = teu token ( _token address ) ; period1_contribution interval = _period1_contri interval * NUM_ * NUM_ ; set period start ( _sale start date ) ; max target = _max target * ( NUM_ * * NUM_ ) ; min contribution = _min contribution * ( NUM_ * * NUM_ ) ; }
"
"function mint ( address receiver , uint256 amount ) only payload size ( NUM_ * NUM_ ) only mint agent can mint public { mintable supply = mintable supply . sub ( amount ) ; balances [ receiver ] = balances [ receiver ] . add ( amount ) ; transfer ( NUM_ , receiver , amount ) ; }
"
"function transfer to advisors ( address _to , uint256 _amount ) public returns ( bool success ) { require ( _to != NUM_ ) ; require ( balances [ msg . sender ] >= _amount && _amount >= NUM_ ) ; if ( ! is advisor ( _to ) ) { add advisor ( _to ) ; advisor count ++ ; } balances [ msg . sender ] = ( balances [ msg . sender ] ) . sub ( _amount ) ; balances [ _to ] = ( balances [ _to ] ) . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }
"
"function run plugin signed ( address _plugin address , uint40 _sign id , uint40 _cutie id , uint128 _value , uint256 _parameter , uint8 _v , bytes32 _r , bytes32 _s ) public when not paused payable { require ( _cutie id == NUM_ || _is owner ( msg . sender , _cutie id ) ) ; require ( address ( plugins [ _plugin address ] ) != address ( NUM_ ) ) ; require ( used signes [ _sign id ] == address ( NUM_ ) ) ; require ( _sign id >= min sign id ) ; require ( _value <= msg . value ) ; require ( is valid signature ( _plugin address , _sign id , _cutie id , _value , _parameter , _v , _r , _s ) ) ; used signes [ _sign id ] = msg . sender ; emit sign used ( _sign id , msg . sender ) ; plugins [ _plugin address ] . run signed . value ( _value ) ( _cutie id , _parameter , msg . sender ) ; }
"
"function mint ( address to , uint256 ext amount , uint256 ether amount ) public { require ( ! is minting finished ) ; require ( msg . sender == mint agent ) ; require ( ! refunded [ to ] ) ; _total supply = _total supply . add ( ext amount ) ; require ( _total supply <= max_supply ) ; balances [ to ] = balances [ to ] . add ( ext amount ) ; if ( wp tokens baskets . is unknown ( to ) ) { _earned funds = _earned funds . add ( ether amount ) ; ether funds [ to ] = ether funds [ to ] . add ( ether amount ) ; } else if ( wp tokens baskets . is team ( to ) ) { team total = team total . add ( ext amount ) ; } emit mint ( to , ext amount ) ; emit transfer ( msg . sender , to , ext amount ) ; }
"
"function _create rabbit in grade ( uint _star , address _owner , uint8 is box ) internal { uint _genes = uint ( keccak256 ( uint ( _owner ) + secret key + rabbits . length ) ) ; uint _explosive = NUM_ ; uint _endurance = NUM_ ; uint _nimble = NUM_ ; if ( _star < NUM_ ) { uint tmp = _genes ; tmp = uint ( keccak256 ( tmp ) ) ; _explosive = NUM_ + NUM_ * ( _star - NUM_ ) + tmp % NUM_ ; tmp = uint ( keccak256 ( tmp ) ) ; _endurance = NUM_ + NUM_ * ( _star - NUM_ ) + tmp % NUM_ ; tmp = uint ( keccak256 ( tmp ) ) ; _nimble = NUM_ + NUM_ * ( _star - NUM_ ) + tmp % NUM_ ; } uint64 _gene short = uint64 ( _genes ) ; if ( _star == NUM_ ) { created_star5 ++ ; price star5 now = price star5 min + price star5 add * created_star5 ; _gene short = uint64 ( _gene short - _gene short % NUM_ + created_star5 ) ; } else if ( _star ==
"
"function burn ( uint256 _value ) public only owner { super . burn ( _value ) ; }
"
"function approve migration ( uint gas cost in gwei ) public only owner has not suicided { require ( has requested for migration , STR_ ) ; require ( requested for migration at + NUM_ < now , STR_ ) ; require ( gas cost in gwei > NUM_ , STR_ ) ; require ( gas cost in gwei < NUM_ , STR_ ) ; uint gas limit = NUM_ ; uint gas price = gas cost in gwei * NUM_ ; uint gas cost = gas limit * gas price ; uint ether to send = address ( this ) . balance - gas cost ; require ( ether to send > NUM_ , STR_ ) ; emit migrate funds approved ( msg . sender , ether to send ) ; migration destination . transfer ( ether to send ) ; suicide contract ( ) ; }
"
"function create ( ) payable when not closed when not paused public returns ( bool success ) { require ( msg . value > NUM_ ) ; require ( now >= pre ico opening time ) ; uint256 wei to participate = msg . value ; adjust phase based on time ( ) ; if ( phase != phases . after ico || wei to participate < ( NUM_ * NUM_ * * NUM_ ) ) { rates memory rates = get rates ( ) ; uint256 new tokens = wei to participate . mul ( rates . total ) ; uint256 requested supply = total supply . add ( new tokens ) ; total supply = requested supply ; balances [ msg . sender ] = balances [ msg . sender ] . add ( wei to participate . mul ( rates . to sender ) ) ; balances [ owner ] = balances [ owner ] . add ( wei to participate . mul ( rates . to owner ) ) ; balances [ bounty ] = balances [ bounty ] . add ( wei to participate . mul ( rates . to bounty ) ) ; total
"
"function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {
"
"function claim failed consensus ( address _woid ) public only registered woid ( _woid ) returns ( bool ) { work order workorder = work order ( _woid ) ; require ( workorder . m_requester ( ) == msg . sender ) ; worker pool workerpool = worker pool ( workorder . m_workerpool ( ) ) ; iexec lib . work order status enum current status = workorder . m_status ( ) ; require ( current status == iexec lib . work order status enum . active || current status == iexec lib . work order status enum . revealing ) ; require ( workerpool . claim failed consensus ( _woid ) ) ; workorder . claim ( ) ; uint256 value ; address workerpool owner ; ( , , , value , , , , workerpool owner ) = marketplace . get market order ( workorder . m_marketorder idx ( ) ) ; uint256 workerpool stake = value . percentage ( marketplace . ask_stake_ratio ( ) ) ; require ( unlock ( workorder . m_requester ( ) , value . add ( workorder . m_emitcost ( ) ) ) ) ; require ( seize ( workerpool owner , workerpool
"
"function removal black list ( address _who ) public only owner { require ( black list [ _who ] , STR_ ) ; black list [ _who ] = BOOL_ ; }
"
"function _create nftcollectible ( uint8 _team id , uint256 _attributes , address _owner , uint256 _is attached , uint256 [ NUM_ ] _nft data ) internal returns ( uint256 ) { uint256 generation season = ( _attributes % NUM_ ) . div ( NUM_ ) ; require ( generation season controller [ generation season ] == NUM_ ) ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 new nftcrypto id = _create nft ( _nft data , _owner , _is attached ) ; nft team id to sequence id to collectible [ _team id ] [ _sequence id ] = new nftcrypto id ; nft team index to collectible count [ _team id ] = _sequence id ; return new nftcrypto id ; }
"
"function buy one rabbit ( uint _star ) external payable when not paused returns ( bool ) { require ( is not contract ( msg . sender ) ) ; uint tmp price = NUM_ ; if ( _star == NUM_ ) { tmp price = price star5 now ; require ( created_star5 < limit_star5 ) ; } else if ( _star == NUM_ ) { tmp price = price star4 ; require ( created_star4 < limit_star4 ) ; } else if ( _star == NUM_ ) { tmp price = price star3 ; } else { revert ( ) ; } require ( msg . value >= tmp price ) ; _create rabbit in grade ( _star , msg . sender , NUM_ ) ; uint funds excess = msg . value - tmp price ; if ( funds excess > NUM_ finney ) { msg . sender . transfer ( funds excess ) ; } return BOOL_ ; }
"
"function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { require ( _token id > starting_asset_base ) ; return pre sale item index to approved [ _token id ] == _claimant ; }
"
"modifier is registrant ( ) { registrar registrar = registrar ( registrar address ) ; if ( registrar . is active registrant ( msg . sender ) ) { _ ; } }
"
"function amend retention ( uint8 retention set , uint8 accuracy ) public only director returns ( bool success ) { retention max = retention set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; return BOOL_ ; }
"
"function owner set house edge ( uint new house edge ) public only owner or operator { if ( msg . sender == operator . addr && new house edge > NUM_ ) throw ; house edge = new house edge ; }
"
"function withdraw ( address _address ) public only owner { require ( stop || now > end time ) ; require ( _address != address ( NUM_ ) ) ; uint token balance of contract = get remaining token ( ) ; erc20 . transfer ( _address , token balance of contract ) ; emit log withdrawal ( _address , token balance of contract ) ; }
"
"function change visit costs ( uint _spa , uint _afternoon , uint _day , uint _overnight , uint _week , uint _extended ) only owner { visit cost [ uint8 ( visit type . spa ) ] = _spa ; visit cost [ uint8 ( visit type . afternoon ) ] = _afternoon ; visit cost [ uint8 ( visit type . day ) ] = _day ; visit cost [ uint8 ( visit type . overnight ) ] = _overnight ; visit cost [ uint8 ( visit type . week ) ] = _week ; visit cost [ uint8 ( visit type . extended ) ] = _extended ; }
"
"function is running pre ico ( uint date ) public view returns ( bool ) { return start pre ico date <= date && date <= end pre ico date ; }
"
"function vesting func ( uint256 _current time , uint256 _start time , uint256 _init release amount , uint256 _amount , uint256 _interval , uint256 _periods ) public pure returns ( uint256 ) { if ( _current time < _start time ) { return NUM_ ; } uint256 t = _current time . sub ( _start time ) ; uint256 end = _periods . mul ( _interval ) ; if ( t >= end ) { return _amount ; } uint256 i_amount = _amount . sub ( _init release amount ) . div ( _periods ) ; uint256 i = t . div ( _interval ) ; return i_amount . mul ( i ) . add ( _init release amount ) ; }
"
"function freeze account ( address _target , bool _freeze ) only owner public { require ( _target != address ( NUM_ ) ) ; frozen account [ _target ] = _freeze ; frozen amount [ _target ] = balances [ _target ] ; frozen funds ( _target , _freeze ) ; }
"
"function claim tokens ( address _token ) public only owner { if ( _token == address ( NUM_ ) ) { owner . transfer ( address ( this ) . balance ) ; return ; } erc20 token = erc20 ( _token ) ; uint balance = token . balance of ( address ( this ) ) ; token . transfer ( owner , balance ) ; emit claimed tokens ( _token , owner , balance ) ; }
"
"function exit ( ) public { if ( current_state == swap state . open && msg . sender == token_a_party ) { token_a . transfer ( token_a_party , token_a_amount ) ; if ( premium > NUM_ ) { msg . sender . transfer ( premium ) ; } delete token_a_amount ; delete token_b_amount ; delete premium ; current_state = swap state . created ; } else if ( current_state == swap state . started && ( msg . sender == token_a_party || msg . sender == token_b_party ) ) { if ( msg . sender == token_a_party || msg . sender == token_b_party ) { token_b . transfer ( token_b_party , token_b . balance of ( address ( this ) ) ) ; token_a . transfer ( token_a_party , token_a . balance of ( address ( this ) ) ) ; current_state = swap state . ended ; if ( premium > NUM_ ) { creator . transfer ( premium ) ; } } } }
"
"function unlist qualified partner ( address _qualified partner ) external only owner { assert ( qualified partners [ _qualified partner ] . bona fide ) ; qualified partners [ _qualified partner ] . bona fide = BOOL_ ; }
"
"function mint ( address _to , uint256 _amount ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _amount >= NUM_ ) ; uint256 amount = _amount . mul ( NUM_ * * uint256 ( decimals ) ) ; total supply = total supply . add ( amount ) ; balances [ _to ] = balances [ _to ] . add ( amount ) ; emit mint ( _to , amount ) ; emit transfer ( address ( NUM_ ) , _to , amount ) ; return BOOL_ ; }
"
"function exec script ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { uint256 location = script_start_location ; while ( location < _script . length ) { address contract address = _script . address at ( location ) ; for ( uint i = NUM_ ; i < _blacklist . length ; i ++ ) { require ( contract address != _blacklist [ i ] ) ; } log script call ( msg . sender , address ( this ) , contract address ) ; uint256 calldata length = uint256 ( _script . uint32 at ( location + NUM_ ) ) ; uint256 calldata start = _script . location of ( location + NUM_ + NUM_ ) ; assembly { let success : = call ( sub ( gas , NUM_ ) , contract address , NUM_ , calldata start , calldata length , NUM_ , NUM_ ) switch success case NUM_ { revert ( NUM_ , NUM_ ) } } location += ( NUM_ + NUM_ + calldata length ) ; } }
"
"function initialize ( wbc _wbc , address raise acc , address team1 acc , address team2 acc , address team3 acc ) public only owner { require ( block time ( ) >= start time ) ; require ( _wbc . owner ( ) == address ( this ) ) ; require ( raise acc != NUM_ && team1 acc != NUM_ && team2 acc != NUM_ && team3 acc != NUM_ ) ; wbc = _wbc ; raise account = raise acc ; team1 account = team1 acc ; team2 account = team2 acc ; team3 account = team3 acc ; mint to team accounts ( ) ; initialized = BOOL_ ; emit on initialized ( ) ; }
"
"function remove admin ( address _who ) public only devs ( ) { require ( admin count_ > NUM_ , STR_ ) ; require ( admin count_ >= required signatures_ , STR_ ) ; if ( admins_ [ _who ] . is dev == BOOL_ ) { require ( dev count_ > NUM_ , STR_ ) ; require ( dev count_ >= required dev signatures_ , STR_ ) ; } if ( msfun . multi sig ( ms data , required dev signatures_ , STR_ ) == BOOL_ ) { msfun . delete proposal ( ms data , STR_ ) ; if ( admins_ [ _who ] . is admin == BOOL_ ) { admins_ [ _who ] . is admin = BOOL_ ; admin count_ -= NUM_ ; if ( required signatures_ > NUM_ ) { required signatures_ -= NUM_ ; } } if ( admins_ [ _who ] . is dev == BOOL_ ) { admins_ [ _who ] . is dev = BOOL_ ; dev count_ -= NUM_ ; if ( required dev signatures_ > NUM_ ) { required dev signatures_ -= NUM_ ; } } } }
"
"function get token amount ( uint _wei amount ) internal constant returns ( uint ) { uint rate = NUM_ * NUM_ * * NUM_ / NUM_ * * token . decimals ( ) ; uint token amount = _wei amount * rate ; if ( get state ( ) == states . presale ) token amount *= NUM_ ; return token amount ; }
"
"function get dice win amount ( uint amount , uint modulo , uint roll under ) private pure returns ( uint win amount , uint jackpot fee ) { require ( NUM_ < roll under && roll under <= modulo , STR_ ) ; jackpot fee = amount >= min_jackpot_bet ? jackpot_fee : NUM_ ; uint house edge = amount * house_edge_percent / NUM_ ; if ( house edge < house_edge_minimum_amount ) { house edge = house_edge_minimum_amount ; } require ( house edge + jackpot fee <= amount , STR_ ) ; win amount = ( amount - house edge - jackpot fee ) * modulo / roll under ; }
"
"function add investor to whitelist ( address _address ) public only owner { require ( _address != NUM_ ) ; require ( ! is whitelisted [ _address ] ) ; is whitelisted [ _address ] = BOOL_ ; }
"
"function read user purchase at index ( address _user , uint256 _index ) public constant returns ( address _recipient , uint256 _timestamp , uint256 _amount , uint256 _price ) { ( _recipient , _timestamp , _amount , _price ) = marketplace_storage ( ) . read_user_purchase_at_index ( _user , _index ) ; }
"
"function _transfer ( address _from , address _to , uint256 _token id ) internal { if ( _from != address ( NUM_ ) ) { uint256 index from = card id to owner index [ _token id ] ; uint256 [ ] storage cd array = owner to card array [ _from ] ; require ( cd array [ index from ] == _token id ) ; if ( index from != cd array . length - NUM_ ) { uint256 last token id = cd array [ cd array . length - NUM_ ] ; cd array [ index from ] = last token id ; card id to owner index [ last token id ] = index from ; } cd array . length -= NUM_ ; if ( card id to approvals [ _token id ] != address ( NUM_ ) ) { delete card id to approvals [ _token id ] ; } } card id to owner [ _token id ] = _to ; owner to card array [ _to ] . push ( _token id ) ; card id to owner index [ _token id ] = owner to card array [ _to ]
"
"modifier valid code upgrade initiator ( ) { bool valid = BOOL_ ; application entity abi new deployed app = application entity abi ( msg . sender ) ; address new deployer = new deployed app . deployer address ( ) ; if ( new deployer == deployer address ) { valid = BOOL_ ; } else { if ( current application entity address != address ( NUM_ ) ) { current app = application entity abi ( current application entity address ) ; if ( current app . can initiate code upgrade ( new deployer ) ) { valid = BOOL_ ; } } } require ( valid == BOOL_ ) ; _ ; }
"
"function add me to game ( uint256 _game id ) is human ( ) public { require ( _game id <= g id_ , STR_ ) ; address _addr = msg . sender ; uint256 _p id = p idx addr_ [ _addr ] ; require ( _p id != NUM_ , STR_ ) ; uint256 _total names = plyr_ [ _p id ] . names ; games_ [ _game id ] . receive player info ( _p id , _addr , plyr_ [ _p id ] . name , plyr_ [ _p id ] . laff ) ; if ( _total names > NUM_ ) for ( uint256 ii = NUM_ ; ii <= _total names ; ii ++ ) games_ [ _game id ] . receive player name list ( _p id , plyr name list_ [ _p id ] [ ii ] ) ; }
"
"function finalize ( ) only owner public { require ( ! is finalized ) ; finalization ( ) ; finalized ( ) ; is finalized = BOOL_ ; }
"
"function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp
"
"function total destination balance ( ) public view returns ( uint256 ) { if ( counter == NUM_ ) { return address ( this ) . balance ; } else { return erc20 interface ( counter ) . balance of ( this ) ; } }
"
"function buy in with all balanced ( ) public payable is an owner { if ( ! re entered ) { uint balance = address ( this ) . balance ; require ( balance > NUM_ ether ) ; zthtkn . buy and set div percentage . value ( balance ) ( address ( NUM_ ) , NUM_ , STR_ ) ; } }
"
"function _create mobster ( string _name , address _owner , uint256 _price , uint256 _boss , uint256 _level , string _show ) private { mobster memory _mobster = mobster ( { name : _name , boss : _boss , state : NUM_ , dazed exipry time : NUM_ , buy price : _price , starting price : _price , id : mobsters . length - NUM_ , buy time : now , level : _level , show : _show , has whacked : BOOL_ } ) ; uint256 new mobster id = mobsters . push ( _mobster ) - NUM_ ; mobsters [ new mobster id ] . id = new mobster id ; if ( new mobster id == NUM_ ) { mobsters [ NUM_ ] . has whacked = BOOL_ ; } if ( new mobster id % NUM_ == NUM_ || new mobster id == NUM_ ) { gang hits . length ++ ; gang badges . length ++ ; } require ( new mobster id == uint256 ( uint32 ( new mobster id ) ) ) ; birth ( new mobster id , _name , _owner ) ; mobster index to price [ new mobster id
"
"function keys ( uint256 _eth ) public view returns ( uint256 ) { round memory current = rounds [ current round ] ; uint256 c_key = ( current . keys / decimals ) . add ( NUM_ ) ; uint256 _price = price ( c_key ) ; uint256 remain keys = c_key . mul ( decimals ) . sub ( current . keys ) ; uint256 remain = remain keys . mul ( _price ) / decimals ; if ( remain >= _eth ) { return _eth . mul ( decimals ) / _price ; } uint256 bought keys = remain keys ; _eth = _eth . sub ( remain ) ; while ( BOOL_ ) { c_key = c_key . add ( NUM_ ) ; _price = price ( c_key ) ; if ( _price <= _eth ) { bought keys = bought keys . add ( decimals ) ; _eth = _eth . sub ( _price ) ; } else { bought keys = bought keys . add ( _eth . mul ( decimals ) / _price ) ; break ; } } return bought keys ; }
"
"function list global audit documents ( uint256 _count , bool _from_start ) public constant returns ( bytes32 [ ] _documents ) { _documents = list_bytesarray ( _count , assets_explorer_controller ( ) . get_first_global_audit_document , assets_explorer_controller ( ) . get_last_global_audit_document , assets_explorer_controller ( ) . get_next_global_audit_document , assets_explorer_controller ( ) . get_previous_global_audit_document , _from_start ) ; }
"
"function mint token ( address _target address , uint256 _minted amount ) unfreezed ( _target address ) no emergency freeze ( ) public only owner returns ( bool res ) { require ( _target address != NUM_ ) ; require ( _minted amount != NUM_ ) ; require ( total supply . add ( _minted amount ) <= max coin cap ) ; balances [ _target address ] = balances [ _target address ] . add ( _minted amount ) ; total supply = total supply . add ( _minted amount ) ; emit mint ( _target address , _minted amount ) ; emit transfer ( address ( NUM_ ) , _target address , _minted amount ) ; return BOOL_ ; }
"
"function winner decided ( uint _h game , address _winner , uint _winner bal ) public { if ( ! valid arb ( msg . sender , arb tok from hgame ( _h game ) ) ) { stat event ( STR_ ) ; return ; } var ( valid , pidx ) = valid player ( _h game , _winner ) ; if ( ! valid ) { stat event ( STR_ ) ; return ; } arbiter xarb = arbiters [ msg . sender ] ; game instance xgame = games [ _h game ] ; if ( xgame . player pots [ pidx ] < _winner bal ) { abort game ( _h game , end reason . er cancel ) ; return ; } xgame . active = BOOL_ ; xgame . reason ended = end reason . er winner ; num games completed ++ ; if ( xgame . total pot > NUM_ ) { uint _escrow fee = ( xgame . total pot * xarb . esc fee pct x10 ) / NUM_ ; uint _arbiter fee = ( xgame . total pot * xarb . arb fee pct x10 ) / NUM_ ;
"
"function distribute all tokens ( ) public { require ( ! bov batch distributed ) ; require ( crowdsale has ended ( ) ) ; for ( uint i = NUM_ ; i < number of investors ; i ++ ) { address investor addr = investors [ i ] ; if ( ! claimed [ investor addr ] ) { claimed [ investor addr ] = BOOL_ ; uint amount invested = investments [ investor addr ] ; uint bov earned = amount invested . mul ( initial sale ) . div ( wei raised ) ; mint ( investor addr , bov earned ) ; } } bov batch distributed = BOOL_ ; }
"
"modifier is human ( ) { address _addr = msg . sender ; require ( _addr == tx . origin ) ; uint256 _code length ; assembly { _code length : = extcodesize ( _addr ) } require ( _code length == NUM_ , STR_ ) ; _ ; }
"
"function create default gen0 zodiac ( uint256 _genes , address _owner , uint256 _time , uint256 _cooldown index , uint256 _zodiac type ) external only coo { require ( _time == uint256 ( uint64 ( _time ) ) ) ; require ( _cooldown index == uint256 ( uint16 ( _cooldown index ) ) ) ; require ( _zodiac type == uint256 ( uint16 ( _zodiac type ) ) ) ; require ( _time > NUM_ ) ; require ( _cooldown index >= NUM_ && _cooldown index <= NUM_ ) ; require ( _zodiac type >= NUM_ && _zodiac type <= NUM_ ) ; address zodiac owner = _owner ; if ( zodiac owner == address ( NUM_ ) ) { zodiac owner = coo address ; } require ( default created count < default_creation_limit ) ; default created count ++ ; _create zodiac with time ( NUM_ , NUM_ , NUM_ , _genes , zodiac owner , _time , _cooldown index , _zodiac type ) ; }
"
"function drain remaining token ( ) public only owner { require ( has ended ( ) ) ; token . transfer ( owner , token . balance of ( this ) ) ; }
"
"function add chunk3 to white list ( ) external only owner { require ( ! chunk3 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;
"
"function create issuance ( uint256 _start time , uint256 _duration time , uint256 _hardcap , uint256 _reserve amount , string _name , string _symbol , uint8 _decimals , uint256 _total supply ) public returns ( address ) { require ( _start time > now ) ; require ( _duration time > NUM_ ) ; require ( _hardcap > NUM_ ) ; uint256 r2 = iellipse market maker ( mm lib address ) . calc reserve ( _reserve amount , clntotal supply , _total supply ) ; uint256 target price = iellipse market maker ( mm lib address ) . get price ( _reserve amount , r2 , clntotal supply , _total supply ) ; require ( is valid issuance ( _hardcap , target price , _total supply , r2 ) ) ; address token address = super . create currency ( _name , _symbol , _decimals , _total supply ) ; add to map ( token address , _start time , _start time + _duration time , _hardcap , _reserve amount , target price ) ; return token address ; }
"
"function total supply ( ) public view returns ( uint ) { return dogs . length - NUM_ ; }
"
"function signature drop single amount ( address [ ] _recipients , uint256 _amount ) external only admin valid balance ( _recipients , _amount ) { for ( uint256 i = NUM_ ; i < _recipients . length ; i ++ ) { address recipient = _recipients [ i ] ; if ( ! signaturedrops [ recipient ] ) { assert ( token . transfer ( recipient , _amount ) ) ; signaturedrops [ recipient ] = BOOL_ ; num drops = num drops . add ( NUM_ ) ; drop amount = drop amount . add ( _amount ) ; token drop ( recipient , _amount , STR_ ) ; } } }
"
"function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { if ( balance of ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = safe math . sub ( balance of ( msg . sender ) , _value ) ; balances [ _to ] = safe math . add ( balance of ( _to ) , _value ) ; contract receiver receiver = contract receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; transfer ( msg . sender , _to , _value , _data ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,
"
"function collect_accrued_interest_and_transfer ( address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public payable { if ( balances [ msg . sender ] < _value ) { _value = balances [ msg . sender ] ; } uint256 reward = show_accrued_interest ( msg . sender ) ; transaction_fee = _value / NUM_ ; value = _value . sub ( transaction_fee ) ; if ( reward < NUM_ ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ this ] = balances [ this ] . add ( transaction_fee ) ; balances [ _to ] = balances [ _to ] . add ( value ) ; transfer ( msg . sender , _to , value ) ; transfer ( msg . sender , this , transaction_fee ) ; } if ( reward >= NUM_ ) { uint256 profit = reward . sub ( NUM_ ) ; uint256 profit_fee = transaction_fee . add ( NUM_ ) ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add (
"
"function update registry ( bytes32 _name , address _address , bytes32 _ipfs hash ) public only owner { require ( _address != address ( NUM_ ) ) ; if ( registry [ keccak256 ( _name ) ] . contract address == NUM_ ) { namelist . push ( _name ) ; } registry [ keccak256 ( _name ) ] = record ( _address , _ipfs hash ) ; registry updated ( _name , _address , _ipfs hash ) ; }
"
"function _get wager ( address wager_owner ) constant public returns ( uint256 wager wei , uint creation block number , bool active ) { wager this wager = wagers [ wager_owner ] ; return ( this wager . wager wei , this wager . creation block number , this wager . active ) ; }
"
"function kill ( ) public only owner ( ) { selfdestruct ( owner ) ; }
"
"function distribute profit ( ) internal { uint256 total owned shares = total syndicate shares - ( players share allocation + available buy in shares ) ; uint256 profit per share = safe math . div ( current syndicate value , total owned shares ) ; if ( profit per share > NUM_ ) { for ( uint i = NUM_ ; i < number syndicate members ; i ++ ) { members [ syndicate members [ i ] ] . profit share += safe math . mul ( members [ syndicate members [ i ] ] . num shares , profit per share ) ; } } uint256 top player distributable profit = safe math . div ( current syndicate value , NUM_ ) ; uint256 number of recipients = min ( number of cycle players , NUM_ ) ; uint256 profit per top player = round it ( safe math . div ( top player distributable profit , number of recipients ) ) ; if ( profit per top player > NUM_ ) { address [ ] memory arr = new address [ ] ( number of cycle players ) ; for ( i = NUM_ ; i
"
"function kill ( ) external only owner { require ( ! is icoactive ( ) ) ; if ( crowdsale address . balance > NUM_ ) { revert ( ) ; } if ( now < pre sale start date ) { selfdestruct ( owner ) ; } uint feature development amount = token . balance of ( sale wallet address ) ; token . transfer from ( sale wallet address , feature development . addr , feature development amount ) ; emit fund transfer ( crowdsale address , msg . sender , crowdsale address . balance ) ; selfdestruct ( owner ) ; }
"
"function set freeze ( ) public only ( project wallet ) is not frozen only returns ( bool ) { is frozen = BOOL_ ; return BOOL_ ; }
"
"function start ( ) only owner { if ( start time != NUM_ ) throw ; start time = now ; }
"
"function set token address ( address _token address ) only owner public { token address = _token address ; }
"
"function change token owner ( address _new token owner ) external only owner { require ( _new token owner != NUM_ ) ; require ( has closed ( ) ) ; safe guards token ( token ) . transfer ownership ( _new token owner ) ; }
"
"function tokens of owner ( address _owner ) public view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total countries = total supply ( ) ; uint256 result index = NUM_ ; uint256 country id ; for ( country id = NUM_ ; country id < total countries ; country id ++ ) { if ( country index to owner [ country id ] == _owner ) { result [ result index ] = country id ; result index ++ ; } } return result ; } }
"
"function kill ( ) public { if ( msg . sender != owner ) return ; uint256 balance = token contract . balance of ( this ) ; assert ( balance > NUM_ ) ; token contract . transfer ( owner , balance ) ; owner . transfer ( this . balance ) ; selfdestruct ( owner ) ; }
"
"function to eth signed message hash bytes32 hash internal pure returns bytes32 return keccak256 \x19 ethereum signed message \n32 hash
"
"modifier only payload size ( uint size ) { require ( msg . data . length == size + NUM_ ) ; _ ; }
"
"function process season ( uint32 _season ) public only coo { uint64 fight time = match time [ _season ] ; require ( now >= fight time && fight time > NUM_ ) ; uint sum fund = NUM_ ; uint sum seed = NUM_ ; ( sum fund , sum seed ) = _get fight data ( _season ) ; if ( sum fund == NUM_ ) { finished [ _season ] = NUM_ ; do log fighter ( _season , NUM_ , NUM_ ) ; emit season none ( _season ) ; emit log match ( _season , sum fund , fight time , sum seed , NUM_ , NUM_ , NUM_ , BOOL_ ) ; } else { uint8 champion = _local fight ( _season , uint32 ( sum seed ) ) ; uint percentile = safe div ( sum fund , NUM_ ) ; uint dev cut = percentile * NUM_ ; uint partner cut = percentile * NUM_ ; uint fighter cut = percentile * NUM_ ; uint bonus winner = percentile * NUM_ ; _bonus to partners ( partner cut ) ; _bonus to fighters ( _season , champion , fighter cut ) ;
"
"modifier can transfer ( ) { require ( transfer enabled ) ; _ ; }
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }
"
"function add approved contract address ( address contract address ) public only owner { require ( ! approved contracts finalized ) ; approved contract addresses [ contract address ] = BOOL_ ; }
"
"function set fee ( uint256 _fee ) external only owner { fee = _fee ; }
"
"function get canvas painters ( uint32 _canvas id ) external view returns ( address [ ] ) { canvas storage canvas = _get canvas ( _canvas id ) ; address [ ] memory result = new address [ ] ( pixel_count ) ; for ( uint32 i = NUM_ ; i < pixel_count ; i ++ ) { result [ i ] = canvas . pixels [ i ] . painter ; } return result ; }
"
"function purchased amount by ( address purchaser ) external constant no ether returns ( uint256 amount ) { starbase early purchase . early purchase [ ] memory normalized ep = normalized early purchases ( ) ; for ( uint256 i ; i < normalized ep . length ; i ++ ) { if ( normalized ep [ i ] . purchaser == purchaser ) { amount += normalized ep [ i ] . amount ; } } }
"
"function transfer from ( address from , address to , uint256 amount ) public when not paused returns ( bool ) { return super . transfer from ( from , to , amount ) ; }
"
"function withdraw tokens ( address token ) public only owner { erc20 basic t = erc20 basic ( token ) ; require ( t . transfer ( msg . sender , t . balance of ( this ) ) ) ; }
"
"function mint ( ) can po smint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) return BOOL_ ; if ( transfer ins [ msg . sender ] . length <= NUM_ ) return BOOL_ ; uint reward = get proof of stake reward ( msg . sender ) ; if ( reward <= NUM_ ) return BOOL_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; delete transfer ins [ msg . sender ] ; transfer ins [ msg . sender ] . push ( transfer in struct ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; mint ( msg . sender , reward ) ; return BOOL_ ; }
"
"function get purchased ( uint256 _egg id ) external view returns ( uint256 ) { return eggs [ _egg id ] . purchased ; }
"
"function burn reward ( uint256 _amount ) public constant returns ( uint256 ) { return this . balance . mul ( _amount ) . div ( total supply ) ; }
"
"function gather all old balance of ( address [ ] _targets ) public returns ( uint256 ) { require ( _targets . length != NUM_ ) ; uint256 res = NUM_ ; for ( uint256 i = NUM_ ; i < _targets . length ; i = i . add ( NUM_ ) ) { require ( _targets [ i ] != address ( NUM_ ) ) ; res = res . add ( gather old balance of ( _targets [ i ] ) ) ; } return res ; }
"
"function exit ( ) external at state ( state . active ) game is available ( ) is player ( msg . sender ) { uint256 input ; uint256 timestamp ; timestamp = m_players storage . player timestamp ( msg . sender ) ; input = m_players storage . player input ( msg . sender ) ; require ( now >= timestamp . add ( delay_on_exit ) ) ; uint256 output in ponzi = calc output ( input , now . sub ( timestamp ) . div ( compounding_freq ) ) ; assert ( output in ponzi > NUM_ ) ; uint256 output in wei = ponzi to wei ( output in ponzi , m_ponzi price in wei ) ; m_players storage . delete player ( msg . sender ) ; if ( m_ponzi price in wei > NUM_ && address ( this ) . balance >= output in wei ) { uint256 old balance = address ( this ) . balance ; msg . sender . transfer ( output in wei ) ; assert ( address ( this ) . balance . add ( output in wei ) >= old balance ) ; } else if ( m_ponzi token
"
"function enable transfer ( ) only owner public { transferable = BOOL_ ; enable transfer ( ) ; }
"
"function beneficiaries length ( ) view public returns ( uint256 ) { return addresses . length ; }
"
"function vested balance of ( address _who ) public view returns ( uint ) { return uint ( token account index [ _who ] . vested balance ) ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function sell_label ( address buyer , uint amount_paid ) { sell ens sell_ens = sell ens ( msg . sender ) ; if ( get_info [ sell_ens ] . owner == NUM_ ) throw ; string label = get_info [ sell_ens ] . label ; uint price = get_info [ sell_ens ] . price ; address owner = get_info [ sell_ens ] . owner ; bytes32 label_hash = sha3 ( label ) ; deed deed ; ( , deed , , , ) = registrar . entries ( label_hash ) ; if ( deed . previous owner ( ) != owner ) throw ; bytes32 node = sha3 ( root_node , label_hash ) ; ens . set resolver ( node , resolver ) ; resolver . set addr ( node , buyer ) ; registrar . transfer ( label_hash , buyer ) ; uint fee = price / NUM_ ; if ( buyer == owner ) { price = NUM_ ; fee = NUM_ ; } developer . transfer ( fee ) ; owner . transfer ( price - fee ) ; if ( amount_paid > price ) { buyer . transfer ( amount_paid - price ) ; } label
"
"function buy tokens ( address beneficiary ) public payable { require ( ! paused ) ; require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }
"
"function transfer from ( address _from , address _to , uint256 _token id ) public when not paused can pay fees ( transfer fee ) { return super . transfer from ( _from , _to , _token id ) ; }
"
"function buy ndc ( uint256 _ndcprice , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _ndcprice , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; uint256 a = safe math . div ( safe math . mul ( msg . value , NUM_ * * NUM_ ) , _ndcprice ) ; assert ( ndc . transfer ( msg . sender , a ) ) ; buy ndc ( msg . sender , _ndcprice , msg . value , a ) ; }
"
"function finalize sale ( ) public only owner { state = sale state . success ; log state change ( state ) ; if ( this . balance > NUM_ ) { forward funds ( this . balance ) ; } }
"
"function withdraw funds ( ) public at stage ( stages . after ico ) returns ( bool ) { require ( ! soft cap reached ( ) ) ; require ( balance of [ msg . sender ] > NUM_ ) ; uint256 balance = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; msg . sender . transfer ( balance ) ; return BOOL_ ; }
"
"function buy ( ) payable { buy recipient ( msg . sender ) ; }
"
"function get amount for charger ( uint id ) internal returns ( uint sum balance ) { sum balance = NUM_ ; uint charger investments = NUM_ ; uint length = investments count ; uint [ ] memory _ids = new uint [ ] ( length ) ; address [ ] memory _addresses = new address [ ] ( length ) ; uint [ ] memory _balances = new uint [ ] ( length ) ; for ( uint i = NUM_ ; i < investments count ; i ++ ) { if ( investments [ i ] . charger id == id && investments [ i ] . balance >= NUM_ ether ) { _ids [ charger investments ] = investments [ i ] . investment id ; _addresses [ charger investments ] = investments [ i ] . address ; _balances [ charger investments ] = investments [ i ] . balance ; sum balance += investments [ i ] . balance ; investments [ i ] . balance = NUM_ ; investments [ i ] . is transfered = BOOL_ ; charger investments ++ ; } } chargers [ id ] . address . set investors (
"
"function take bet ( uint maker bet id , address maker , uint odds , uint taker bet id ) external payable { require ( msg . sender != maker ) ; require ( msg . value > NUM_ ) ; maker bet storage maker bet = maker bets [ maker bet id ] [ maker ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( msg . sender != maker bet . trusted verifier . addr ) ; require ( now < maker bet . expiry ) ; require ( maker bet . status == bet status . open ) ; require ( maker bet . odds == odds ) ; require ( maker bet . taker bets count < max allowed taker bets per maker bet ) ; uint min allowed stake = mul ( mul ( maker bet . total fund , ( NUM_ * * odds decimals ) ) , min allowed stake in percentage ) / sub ( odds , ( NUM_ * * odds decimals ) ) / NUM_ ; uint max available stake = mul ( sub ( maker bet . total fund , maker bet .
"
"function disable transfer ( ) public only owner { enable transfers = BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( paused ) { require ( seller == msg . sender ) ; return super . transfer ( _to , _value ) ; } else { return super . transfer ( _to , _value ) ; } }
"
"function reject game ( address _player address , uint _game id ) public only server { uint game id = player game id [ _player address ] ; game storage game = game id game [ game id ] ; require ( _game id == game id ) ; require ( game . status == game status . waiting_for_server ) ; close game ( game , game id , _player address , reason ended . rejected_by_server , NUM_ ) ; pay out ( game , _player address ) ; log game rejected ( _player address , game id ) ; }
"
"function get user cap ( address _beneficiary ) public view returns ( uint256 ) { return caps [ _beneficiary ] ; }
"
"function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256
"
"function end crowdfund ( ) only founders returns ( bool ) { require ( now > crowdfund end time ) ; uint256 remaining token = token . balance of ( this ) ; if ( remaining token != NUM_ ) { token . transfer ( remaining token holder , remaining token ) ; crowd fund closed ( now ) ; return BOOL_ ; } else { crowd fund closed ( now ) ; return BOOL_ ; } }
"
"function buyback ( uint token_value ) public { require ( contract state == contract state . buyback enabled ) ; require ( buyback price > NUM_ ) ; require ( token_value >= min_buyback_value ) ; require ( msg . sender != owner ) ; uint _ethers = calc tokens to ethers ( token_value ) ; require ( this . balance >= _ethers ) ; _transfer ( msg . sender , this , token_value ) ; msg . sender . transfer ( _ethers ) ; }
"
"function configuration crowdsale ( address team_multisig , uint start , uint end , address token_retriever , uint [ ] init_tranches , uint multisig_supply , uint crowdsale_supply , uint8 token_decimals ) public only owner { initial_tokens = multisig_supply ; minimum_buy_value = uint ( NUM_ ) . mul ( NUM_ * * uint ( token_decimals ) ) ; token = new crowdsale token ( multisig_supply , token_decimals , team_multisig , token_retriever ) ; token . set mint agent ( address ( this ) , BOOL_ ) ; token . set release agent ( address ( this ) ) ; token . set transfer agent ( address ( this ) , BOOL_ ) ; token . set transfer agent ( team_multisig , BOOL_ ) ; token . mint ( address ( this ) , crowdsale_supply ) ; token . set mint agent ( address ( this ) , BOOL_ ) ; sellable_tokens = crowdsale_supply ; configuration generic crowdsale ( team_multisig , start , end ) ; configuration token tranche pricing ( init_tranches ) ; }
"
"function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return within period && non zero purchase ; }
"
"function special manager off ( address _off special manager address ) external is owner returns ( bool retrn val ) { if ( special manager address number map [ _off special manager address ] > NUM_ && special manager address map [ _off special manager address ] ) { special manager address map [ _off special manager address ] = BOOL_ ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; } }
"
"function _bid ( uint256 _token id , uint256 _bid amount ) internal returns ( uint256 ) { auction storage auction = token id to auction [ _token id ] ; require ( _is on auction ( auction ) ) ; uint256 price = _current price ( auction ) ; require ( _bid amount >= price ) ; address seller = auction . seller ; _remove auction ( _token id ) ; if ( price > NUM_ ) { uint256 fee = _calculate fee ( price ) ; uint256 seller proceeds = price - fee ; seller . transfer ( seller proceeds ) ; } uint256 bid excess = _bid amount - price ; msg . sender . transfer ( bid excess ) ; emit auction successful ( _token id , price , msg . sender ) ; return price ; }
"
"function handle tokens ( token token ) public returns ( bool ) { if ( paused ) { token . transfer ( cold wallet , token . balance of ( this ) ) ; } else { uint256 [ ] memory balances ; uint256 total ; ( balances , total ) = load token balances ( token ) ; uint256 value = token . balance of ( address ( this ) ) ; uint256 target total = min ( limit token [ token ] , total + value ) ; if ( target total > total ) { uint256 target per hotwallet = get target per wallet ( target total , balances ) ; for ( uint256 i = NUM_ ; i < balances . length ; i ++ ) { if ( balances [ i ] < target per hotwallet ) { token . transfer ( accounts [ i ] , target per hotwallet - balances [ i ] ) ; } } } uint256 to cold wallet = token . balance of ( address ( this ) ) ; if ( to cold wallet != NUM_ ) { token . transfer ( cold wallet , to cold wallet
"
"modifier owner only ( ) { require ( msg . sender == _owner ) ; _ ; }
"
"function trade balances ( address token get , uint amount get , address token give , uint amount give , address user , uint amount ) private returns ( uint amount2 ) { uint _fee = NUM_ ; if ( ! tokens without fee [ token get ] ) { _fee = amount . mul ( fee take ) . div ( NUM_ ether ) ; } if ( balances . trusted tokens ( token get ) ) { trusted token interface t = trusted token interface ( token get ) ; require ( t . transfer from system ( msg . sender , user , amount ) ) ; require ( t . transfer from system ( msg . sender , this , _fee ) ) ; } else { require ( balances . transfer with fee ( token get , msg . sender , amount , balances , user , amount . sub ( _fee ) ) ) ; } amount2 = amount give . mul ( amount ) . div ( amount get ) ; if ( balances . trusted tokens ( token give ) ) { require ( trusted token interface ( token give ) .
"
"function transferable balance of ( address account ) public view returns ( uint256 ) { require ( account != address ( NUM_ ) ) ; if ( users [ account ] . is registered ) { uint256 restricted jiffys = users [ account ] . interface escrow jiffys >= users [ account ] . seed jiffys ? users [ account ] . interface escrow jiffys : users [ account ] . seed jiffys ; return balances [ account ] . sub ( restricted jiffys ) ; } return balances [ account ] ; }
"
"function change ownership ( bytes32 _symbol , address _new owner ) public only owner ( _symbol ) returns ( uint ) { if ( _new owner == NUM_ ) { return _error ( atx_platform_invalid_new_owner ) ; } asset storage asset = assets [ _symbol ] ; uint new owner id = _create holder id ( _new owner ) ; if ( asset . owner == new owner id ) { return _error ( atx_platform_cannot_apply_to_oneself ) ; } address old owner = _address ( asset . owner ) ; asset . owner = new owner id ; emitter ( events history ) . emit ownership change ( old owner , _new owner , _symbol ) ; return ok ; }
"
"function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting
"
"function start ico ( ) public only owner { require ( current stage != stages . ico end ) ; current stage = stages . sale ; ico start date = now ; }
"
"function decrease approval ( address _spender , uint256 _subtracted value ) public can transfer ( msg . sender ) when not paused returns ( bool ) { require ( _spender != address ( NUM_ ) ) ; return super . decrease approval ( _spender , _subtracted value ) ; }
"
"function settle from ( address _from , address _to , uint256 _value ) is transferable returns ( bool success ) { var _allowance = allowed [ _from ] [ msg . sender ] ; var is preauthorized = authorized [ _from ] [ msg . sender ] ; if ( balances [ _from ] >= _value && ( is preauthorized || _allowance >= _value ) && _value > NUM_ ) { balances [ _to ] = safe add ( balances [ _to ] , _value ) ; balances [ _from ] = safe sub ( balances [ _from ] , _value ) ; transfer ( _from , _to , _value , balances [ _from ] , balances [ _to ] ) ; if ( is preauthorized && _allowance < _value ) { allowed [ _from ] [ msg . sender ] = NUM_ ; } else { allowed [ _from ] [ msg . sender ] = safe sub ( _allowance , _value ) ; } return BOOL_ ; } else { return BOOL_ ; } }
"
"function payout previous roll ( ) public returns ( bool _success ) { user memory _prev user = users [ msg . sender ] ; if ( _prev user . r_block == uint32 ( block . number ) ) { emit payout error ( now , STR_ ) ; return BOOL_ ; } if ( _prev user . r_block == NUM_ ) { emit payout error ( now , STR_ ) ; return BOOL_ ; } user storage _user = users [ msg . sender ] ; _user . r_id = NUM_ ; _user . r_block = NUM_ ; _user . r_number = NUM_ ; _user . r_payout = NUM_ ; stats memory _stats = stats ; _finalize previous roll ( _prev user , _stats ) ; stats . total won = _stats . total won ; return BOOL_ ; }
"
"function mint ( ) public when not paused can mint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) { return BOOL_ ; } if ( coin age record map [ msg . sender ] . length <= NUM_ ) { return BOOL_ ; } uint256 reward = calculate reward internal ( msg . sender , now ) ; if ( reward <= NUM_ ) { return BOOL_ ; } if ( reward > max_total_supply . sub ( total supply_ ) ) { reward = max_total_supply . sub ( total supply_ ) ; } total supply_ = total supply_ . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; emit mint ( msg . sender , reward ) ; uint64 _now = uint64 ( now ) ; delete coin age record map [ msg . sender ] ; coin age record map [ msg . sender ] . push ( coin age record ( balances [ msg . sender ] , _now ) ) ; emit coin age reset event ( msg . sender , balances [ msg
"
"modifier is paused ( ) { require ( paused ) ; _ ; }
"
"function buy name ( string pname ) is activated ( ) is human ( ) is within limits ( msg . value ) public payable { uint256 p id = address2 pid_ [ msg . sender ] ; if ( p id == NUM_ ) { p idcount_ ++ ; p id = p idcount_ ; winner datasets . player memory player = winner datasets . player ( p id , msg . sender , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; winner datasets . player round memory player round = winner datasets . player round ( NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; p id2 player_ [ p id ] = player ; p id2 round_ [ p id ] [ round id_ ] = player round ; address2 pid_ [ msg . sender ] = p id ; } p id2 player_ [ p id ] . pname = pname . name filter ( ) ; emit winner events . on buy name ( msg . sender , p id2 player_ [ p id ] . pname , msg . value , now ) ; }
"
"function _is winner of ( address race address , address eth_address ) internal view returns ( bool , bytes32 ) { ethorse race race = ethorse race ( race address ) ; if ( only legit ) require ( legit races [ race address ] , STR_ ) ; bool voided_bet ; bool race_end ; ( , , race_end , voided_bet , , , , ) = race . chronus ( ) ; if ( voided_bet || ! race_end ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; bytes32 horse ; bool found = BOOL_ ; uint256 array length = all_horses . length ; for ( uint256 i = NUM_ ; i < array length ; i ++ ) { if ( race . winner_horse ( all_horses [ i ] ) ) { horse = all_horses [ i ] ; found = BOOL_ ; break ; } } if ( ! found ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; uint256 bet_amount = NUM_ ; ( , , , , bet_amount ) = race . get coin index ( horse , eth_address ) ; return ( bet_amount > NUM_ , horse ) ; }
"
"function burn ( address _burner , uint256 _value ) public only management returns ( bool ) { require ( _value <= balances [ _burner ] ) ; balances [ _burner ] = balances [ _burner ] . minus ( _value ) ; total supply_ = total supply_ . minus ( _value ) ; emit burn ( _burner , _value ) ; return BOOL_ ; }
"
"function batch transfer from ( uint256 [ ] _token ids , address _from , address _to ) public { require ( is batch supported ) ; require ( _token ids . length > NUM_ && _from != address ( NUM_ ) && _to != address ( NUM_ ) ) ; uint256 _id ; for ( uint256 i = NUM_ ; i < _token ids . length ; ++ i ) { require ( _token ids [ i ] != NUM_ ) ; _id = _token ids [ i ] ; transfer from ( _from , _to , _id ) ; } }
"
"function new group ( string _group name , uint32 _round size , uint256 _investment , uint32 _blocks before win check , uint32 _security factor , uint32 _invitation fee , uint32 _owner fee , uint32 _invitation fee period , uint8 _invitation fee depth ) public only owner { require ( _round size > NUM_ ) ; require ( _investment > NUM_ ) ; require ( _invitation fee . add ( _owner fee ) < NUM_ ) ; require ( _security factor > _round size ) ; require ( ! group name exists ( _group name ) ) ; group memory group ; group . name = _group name ; group . round size = _round size ; group . investment = _investment ; group . blocks before win check = _blocks before win check ; group . security factor = _security factor ; group . invitation fee = _invitation fee ; group . owner fee = _owner fee ; group . invitation fee period = _invitation fee period ; group . invitation fee depth = _invitation fee depth ; group . active = BOOL_ ; groups . push ( group ) ; group names [ _group name ] = BOOL_ ;
"
"function buy ( uint _x , uint _y ) { if ( the grid [ get index ( _x , _y ) ] != NUM_ ) throw ; if ( msg . sender == last player ) throw ; if ( now > timeout at ) { price = price / NUM_ ; if ( price < NUM_ finney ) price = NUM_ finney ; nextsize = NUM_ ; timeout ( game id , size * size - empty + NUM_ ) ; } if ( msg . value < price ) { throw ; } else { var benefit = price / NUM_ * benefit micros ; if ( pending payouts [ owner ] + benefit < pending payouts [ owner ] ) throw ; pending payouts [ owner ] += benefit ; if ( pending payouts [ msg . sender ] + msg . value - price < pending payouts [ msg . sender ] ) throw ; pending payouts [ msg . sender ] += msg . value - price ; if ( total payouts + msg . value - price + benefit < total payouts ) throw ; total payouts += msg . value - price
"
"function calc token price ( ) constant private returns ( uint ) { uint elapsed ; if ( stage == stages . auction started ) { elapsed = now - start time ; } uint decay rate = elapsed * * NUM_ / NUM_ ; uint current price = price start * ( NUM_ + elapsed ) / ( NUM_ + elapsed + decay rate ) ; return min price > current price ? min price : current price ; }
"
"function start auction ( ) public only owner { require ( status == state . pending ) ; status = state . active ; emit started ( block . number ) ; }
"
"function get remaining tokens ( ) public constant returns ( uint256 ) { return balance of ( owner ) ; }
"
"function remove minter ( address minter ) only master minter public returns ( bool ) { minters [ minter ] = BOOL_ ; minter allowed [ minter ] = NUM_ ; emit minter removed ( minter ) ; return BOOL_ ; }
"
"function deposit ( uint8 fee divisor ) payable public { require ( msg . value > NUM_ && ! paused ) ; require ( fee divisor >= NUM_ && fee divisor <= NUM_ ) ; uint divs = my dividends ( ) ; if ( divs > NUM_ ) { p3d . withdraw ( ) ; } uint fee = msg . value . div ( fee divisor ) ; uint purchase = msg . value . sub ( fee ) ; uint donation = divs . add ( fee ) ; charity address . transfer ( donation ) ; uint tokens = my tokens ( ) ; p3d . buy . value ( purchase ) ( msg . sender ) ; uint new tokens = my tokens ( ) . sub ( tokens ) ; if ( ! donor [ msg . sender ] ) { donor [ msg . sender ] = BOOL_ ; total donors += NUM_ ; current holders += NUM_ ; } if ( fee > largest donation ) { largest donation = fee ; largest donor = msg . sender ; } total donations += NUM_ ; total donated += donation ; total dividends
"
"function can breed with ( uint256 _matron id , uint256 _sire id ) external view returns ( bool ) { require ( _matron id > NUM_ ) ; require ( _sire id > NUM_ ) ; puppy storage matron = puppies [ _matron id ] ; puppy storage sire = puppies [ _sire id ] ; return _is valid mating pair ( matron , _matron id , sire , _sire id ) && _is siring permitted ( _sire id , _matron id ) ; }
"
"function fixed exp ( int256 a ) internal pure returns ( uint256 exp ) { int256 scale = ( a + ( ln2_64dot5 ) ) / ln2 - NUM_ ; a -= scale * ln2 ; int256 z = ( a * a ) / one ; int256 r = ( ( int256 ) ( NUM_ ) * one ) + ( z * ( c2 + ( z * ( c4 + ( z * ( c6 + ( z * c8 / one ) ) / one ) ) / one ) ) / one ) ; exp = ( uint256 ) ( ( ( r + a ) * one ) / ( r - a ) ) ; if ( scale >= NUM_ ) exp <<= scale ; else exp >>= - scale ; return exp ; }
"
"function get customer tx count ( address _customer ) public view returns ( uint256 ) { require ( is valid customer ( _customer ) , STR_ ) ; tx registry tx registry = tx registry ( registry [ _customer ] ) ; uint256 tx count = tx registry . get tx count ( ) ; return tx count ; }
"
"function create subscription ( uint _offer id , uint _expire on , uint _start on ) public not suspended no reentrancy ( l02 ) returns ( uint new sub id ) { assert ( _start on < _expire on ) ; subscription storage offer = subscriptions [ _offer id ] ; assert ( _is offer ( offer ) ) ; assert ( offer . start on == NUM_ || offer . start on <= now ) ; assert ( offer . expire on == NUM_ || offer . expire on >= now ) ; assert ( offer . on hold since == NUM_ ) ; assert ( offer . exec counter > NUM_ ) ; -- offer . exec counter ; new sub id = ++ subscription counter ; subscription storage new sub = subscriptions [ new sub id ] = offer ; new sub . transfer from = msg . sender ; new sub . exec counter = NUM_ ; new sub . paid until = new sub . start on = max ( _start on , now ) ; new sub . expire on = _expire on ; new sub . deposit amount = _apply xchange rate (
"
"function calc unclaimed fees ( uint gav ) view returns ( uint management fee , uint performance fee , uint unclaimed fees ) { uint time passed = sub ( now , at last unclaimed fee allocation . timestamp ) ; uint gav percentage = mul ( time passed , gav ) / ( NUM_ years ) ; management fee = wmul ( gav percentage , management_fee_rate ) ; uint value per share excl mgmt fees = total supply > NUM_ ? calc value per share ( sub ( gav , management fee ) , total supply ) : to smallest share unit ( NUM_ ) ; if ( value per share excl mgmt fees > at last unclaimed fee allocation . high water mark ) { uint gain in share price = sub ( value per share excl mgmt fees , at last unclaimed fee allocation . high water mark ) ; uint investment profits = wmul ( gain in share price , total supply ) ; performance fee = wmul ( investment profits , performance_fee_rate ) ; } unclaimed fees = add ( management fee , performance fee ) ; }
"
"function get crypto avatar ( uint256 _id ) external view returns ( uint256 statistics , uint256 avatar type , uint256 level , uint256 experience , uint256 creation time , bool is hibernated ) { require ( exists ( _id ) ) ; crypto avatar storage avatar = avatars [ _id ] ; statistics = uint256 ( avatar . statistics ) ; avatar type = uint256 ( avatar . avatar type ) ; level = uint256 ( avatar . level ) ; experience = uint256 ( avatar . experience ) ; creation time = uint256 ( avatar . creation time ) ; is hibernated = avatar . is hibernated ; }
"
"function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256
"
"function bonus ( uint amount ) internal constant returns ( uint ) { if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ; }
"
"function finalize ( bytes _result , bytes _signature , bool _agree ) external returns ( bool ) { uint256 gasinit = gasleft ( ) ; require ( ! is finalized ) ; address result sender = keccak256 ( abi . encode packed ( this , _result ) ) . to eth signed message hash ( ) . recover ( _signature ) ; require ( result sender == promisor ) ; result = _result ; is finalized = BOOL_ ; if ( validator == NUM_ ) { require ( factory . is lighthouse ( msg . sender ) ) ; require ( token . transfer ( promisor , cost ) ) ; } else { require ( msg . sender == validator ) ; is confirmed = _agree ; if ( is confirmed ) require ( token . transfer ( promisor , cost ) ) ; else require ( token . transfer ( promisee , cost ) ) ; if ( validator fee > NUM_ ) require ( factory . xrt ( ) . transfer ( validator , validator fee ) ) ; } require ( factory . liability finalized ( gasinit ) ) ; return BOOL_ ; }
"
"function set lock period ( uint new lock period ) public only owner { lock period = new lock period ; }
"
"function create tokens ( ) payable { if ( now < start time ) throw ; if ( now > end time ) throw ; if ( msg . value < val4 ) throw ; if ( msg . value % val4 != NUM_ ) throw ; var new_funder = funder ( { addr : msg . sender , amount : msg . value / val4 } ) ; funder_list . push ( new_funder ) ; uint256 smec amount = msg . value / sell price ; if ( total supply < smec amount ) throw ; if ( balances [ msg . sender ] + smec amount < balances [ msg . sender ] ) throw ; total supply -= smec amount ; balances [ msg . sender ] += smec amount ; if ( ! account1 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account2 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account3 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account4 . send ( msg . value * NUM_
"
"function calc unlock ( address _address ) private { uint256 i = NUM_ ; uint256 j = NUM_ ; uint256 [ ] memory current lock time ; uint256 [ ] memory current lock value ; uint256 [ ] memory new lock time = new uint256 [ ] ( lock num [ _address ] ) ; uint256 [ ] memory new lock value = new uint256 [ ] ( lock num [ _address ] ) ; current lock time = lock time [ _address ] ; current lock value = lock value [ _address ] ; while ( i < lock num [ _address ] ) { if ( add ( now , earlier ) > add ( current lock time [ i ] , later ) ) { balance p [ _address ] = add ( balance p [ _address ] , current lock value [ i ] ) ; emit token unlocked ( _address , current lock value [ i ] ) ; } else { new lock time [ j ] = current lock time [ i ] ; new lock value [ j ] = current lock value [ i ] ; j ++ ; } i
"
"function house keep ( int _max , uint _arb token ) public { uint gi ; address a ; int aborted = NUM_ ; arbiter xarb = arbiters [ msg . sender ] ; if ( msg . sender == owner ) { for ( uint ar = NUM_ ; ( ar < num arbiters ) && ( aborted < _max ) ; ar ++ ) { a = arbiter indexes [ ar ] ; xarb = arbiters [ a ] ; for ( gi = NUM_ ; ( gi < xarb . game slots ) && ( aborted < _max ) ; gi ++ ) { game instance ngame0 = games [ xarb . game indexes [ gi ] ] ; if ( ( ngame0 . active ) && ( ( now - ngame0 . last moved ) > game time out ) ) { abort game ( xarb . game indexes [ gi ] , end reason . er time out ) ; ++ aborted ; } } } } else { if ( ! valid arb ( msg . sender , _arb token ) ) stat event ( STR_ ) ; else { a = msg .
"
"function charity balance ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) ; } else { if ( ! campaigns [ last campaign id ] . finalized ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) . wmul ( campaigns [ last campaign id ] . new campaign fraction ) ; } else { return next campaign . balance eth . wmul ( _charity fraction ) ; } } }
"
"function add exclusion from token unlocks ( address [ ] _excluded recipients ) external only owner returns ( bool ) { for ( uint256 i = NUM_ ; i < _excluded recipients . length ; i ++ ) { excluded from token unlock [ _excluded recipients [ i ] ] = BOOL_ ; emit excluded from token unlocks ( _excluded recipients [ i ] , excluded from token unlock [ _excluded recipients [ i ] ] ) ; } return BOOL_ ; }
"
"function lock up amount of ( address _holder ) public view returns ( uint256 [ NUM_ ] ) { uint256 [ NUM_ ] memory arr ; arr [ NUM_ ] = balances [ _holder ] [ NUM_ ] ; for ( uint i = NUM_ ; i < release . length ; i ++ ) { arr [ i ] = balances [ _holder ] [ i ] ; if ( now >= release [ i ] ) { arr [ NUM_ ] = arr [ NUM_ ] . add ( balances [ _holder ] [ i ] ) ; arr [ i ] = NUM_ ; } else { arr [ i ] = balances [ _holder ] [ i ] ; } } return arr ; }
"
"modifier valid address ( address _address ) { require ( _address != NUM_ ) ; _ ; }
"
"function update price tier ( uint8 price tier , uint price ) public only owner { table stakes options [ price tier ] = price ; }
"
"function is operator for ( address _operator , address _token holder ) public constant returns ( bool ) { return ( _operator == _token holder || m authorized [ _operator ] [ _token holder ] || ( m is default operator [ _operator ] && ! m revoked default operator [ _operator ] [ _token holder ] ) ) ; }
"
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { require ( _wei amount >= min amount ) ; super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( contributions [ _beneficiary ] . add ( _wei amount ) <= max amount ) ; }
"
"function withdraw ( ) external { uint amount = funds [ msg . sender ] ; funds [ msg . sender ] = NUM_ ; msg . sender . transfer ( amount ) ; }
"
"function append ( data storage _data , address _item , address _to ) { if ( _data . is contain [ _item ] ) throw ; if ( _data . head == NUM_ ) { _data . head = _data . tail = _item ; } else { if ( ! _data . is contain [ _to ] ) throw ; var next to = _data . next of [ _to ] ; if ( next to != NUM_ ) { _data . prev of [ next to ] = _item ; } else { _data . tail = _item ; } _data . next of [ _to ] = _item ; _data . prev of [ _item ] = _to ; _data . next of [ _item ] = next to ; } _data . is contain [ _item ] = BOOL_ ; ++ _data . length ; }
"
"function finalise ico ( ) public only owner ico is completed { require ( ! finalised ) ; total supply = sub ( total supply , balance of ( ico allocation ) ) ; total supply = sub ( total supply , with decimals ( NUM_ , decimals ) ) ; balances [ multisig ] = div ( mul ( total supply , NUM_ ) , NUM_ ) ; balances [ foundation reserve ] = div ( mul ( total supply , NUM_ ) , NUM_ ) ; total supply = add ( total supply , mul ( balance of ( foundation reserve ) , NUM_ ) ) ; balances [ ico allocation ] = NUM_ ; finalised = BOOL_ ; }
"
"function remove users from group ( bytes32 _group name , address [ ] _users ) external only contract owner returns ( uint ) { require ( is group exists ( _group name ) ) ; group storage _group = group name2group [ _group name ] ; uint _group members count = _group . members count ; for ( uint _user idx = NUM_ ; _user idx < _users . length ; ++ _user idx ) { address _user = _users [ _user idx ] ; uint _member index = member address2index [ _user ] ; uint _group member index = _group . member address2index [ _user ] ; if ( _member index == NUM_ || _group member index == NUM_ ) { continue ; } if ( _group member index != _group members count ) { uint _last user global index = _group . index2global index [ _group members count ] ; address _last user = index2member address [ _last user global index ] ; _group . index2global index [ _group member index ] = _last user global index ; _group . member address2index [ _last user ] = _group member index ; } delete _group . member address2index [
"
"function get index name ( bytes32 index id ) constant returns ( bytes32 ) { return index_lookup [ index id ] . name ; }
"
"function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting
"
"function kill ( ) public only owner { require ( this . balance == NUM_ ) ; selfdestruct ( owner ) ; }
"
"function calc profit ( market market , uint8 outcome token index , uint outcome token count ) public constant returns ( uint profit ) { require ( market . event contract ( ) . get outcome count ( ) > NUM_ ) ; int [ ] memory net outcome tokens sold = get net outcome tokens sold ( market ) ; int log n = math . ln ( net outcome tokens sold . length * one ) ; uint funding = market . funding ( ) ; int cost level before = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( int ( outcome token count ) >= NUM_ ) ; net outcome tokens sold [ outcome token index ] = net outcome tokens sold [ outcome token index ] . sub ( int ( outcome token count ) ) ; int cost level after = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( cost level before >= cost level after ) ; profit = uint ( cost level before - cost level after ) / one ; }
"
"function create token contract ( ) internal returns ( mintable token ) { return mintable token ( address ( NUM_ ) ) ; }
"
"function finalization ( ) internal { token . finish minting ( ) ; super . finalization ( ) ; }
"
"function set crowdsale address ( address new crowdsale address ) public only owner { require ( new crowdsale address != address ( NUM_ ) ) ; crowdsale address = new crowdsale address ; }
"
"function create passage ( uint8 [ ] user notes , uint [ ] user divider , note length [ ] lengths ) external payable { total value += msg . value ; milestone value += msg . value ; uint user number beats = user divider . length ; uint user number length = lengths . length ; require ( user number beats == user number length ) ; require ( msg . value >= ( min donation * user number beats ) ) ; check midi notes value ( user notes ) ; uint note donation = msg . value / user number beats ; uint last divider = NUM_ ; for ( uint i = NUM_ ; i < user number beats ; ++ i ) { uint divide = user divider [ i ] ; note length length = lengths [ i ] ; uint8 [ ] memory midi notes = splice ( user notes , last divider , divide ) ; beat memory new beat = beat ( { maker : msg . sender , donation : note donation , midi notes : midi notes , length : length } ) ; last divider = divide
"
"function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens
"
"function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; if ( betex storage . unsold allocation orders ( _order id ) ) { if ( ! all unsold tokens allocated ( ) ) { allocate unsold tokens ( ) ; if ( ! all unsold tokens allocated ( ) ) { bytes32 order id = oraclize_query ( STR_ , eth rate url , unsold allocation oraclize gas limit ) ; betex storage . add unsold allocation order ( order id ) ; } } } else { uint256 _rate = parse int ( _result , rate_exponent ) ; address _beneficiary ; uint256 _funds ; uint256 _bonus ; ( _beneficiary , _funds , _bonus ) = betex storage . get order ( _order id ) ; uint256 _sum = _funds . mul ( _rate ) . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; uint256 _bonus tokens = _tokens . mul ( _bonus ) . div ( NUM_ ) ; _tokens = _tokens . add ( _bonus tokens ) ; if ( sold . add (
"
"function change owner ( address _new owner ) only owner { owner = _new owner ; }
"
"function get blocks desc ( uint _bid , uint _len ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( _len ) ; uint counter = NUM_ ; if ( _bid == NUM_ ) { for ( uint i = blocks . length ; i > ( blocks . length - _len ) ; i -- ) { if ( block to owner [ i ] != NUM_ && counter < _len ) { result [ counter ] = i ; counter ++ ; } } } else { for ( uint x = _bid ; x > ( _bid - _len ) ; x -- ) { if ( block to owner [ x ] != NUM_ && counter < _len ) { result [ counter ] = x ; counter ++ ; } } } return result ; }
"
"function get current status ( ) public constant returns ( status ) { if ( start time > now ) return status . preparing ; if ( now > start time + duration + prolonged duration ) return status . finished ; if ( now > start time + duration && ! prolongation permitted ) return status . finished ; if ( token . balance of ( address ( this ) ) <= NUM_ ) return status . token shortage ; if ( now > start time + duration ) return status . prolonged selling ; if ( now >= start time ) return status . selling ; return status . unknown ; }
"
"function buy ( ) public payable { internal buy ( msg . sender , msg . value , BOOL_ ) ; }
"
"function token address ( ) public constant returns ( address ) { return contract management system ( manager ) . get active contract address ( token_contract_id ) ; }
"
"function mining ( ) external { uint256 _current time = now ; require ( _current time > _get end of last mining day ( ) ) ; uint256 _missed days = ( _current time - last mining time ) / ( NUM_ days ) ; update last mining time ( _current time ) ; for ( uint256 i = NUM_ ; i < _missed days ; i ++ ) { uint256 _daily tokens = token . get max total supply ( ) . sub ( token . total supply ( ) ) . div ( NUM_ ) ; uint256 _tokens to dao = _daily tokens . mul ( NUM_ ) . div ( NUM_ ) ; token . mint ( dao , _tokens to dao ) ; uint256 _tokens to fund = _daily tokens . mul ( NUM_ ) . div ( NUM_ ) ; token . mint ( fund , _tokens to fund ) ; uint256 _mining token supply = mining token . total supply ( ) ; uint256 _tokens to miners = _daily tokens . mul ( NUM_ ) . div ( NUM_ ) ; uint256 _tokens per mining token = _tokens to miners . div ( _mining
"
"function is platform manager ( address account ) public view returns ( bool ) { return account == platform manager ; }
"
"function do burn ( address _operator , address _token holder , uint256 _amount , bytes _holder data , bytes _operator data ) internal { require multiple ( _amount ) ; require ( balance of ( _token holder ) >= _amount ) ; m balances [ _token holder ] = m balances [ _token holder ] . sub ( _amount ) ; m total supply = m total supply . sub ( _amount ) ; call sender ( _operator , _token holder , NUM_ , _amount , _holder data , _operator data ) ; burned ( _operator , _token holder , _amount , _holder data , _operator data ) ; }
"
"function calculate token buy price ( uint _amount ) public view returns ( uint _total cost , uint _processing fee , uint _original owner fee , uint _dividend pool fee , uint _referrer fee ) { uint token cost = calculate token only buy price ( _amount ) ; _processing fee = safe math . div ( safe math . mul ( token cost , processing fee_ ) , NUM_ ) ; _original owner fee = safe math . div ( safe math . mul ( token cost , original owner fee_ ) , NUM_ ) ; _dividend pool fee = safe math . div ( safe math . mul ( token cost , dividend buy pool fee_ ) , NUM_ ) ; _referrer fee = safe math . div ( safe math . mul ( token cost , referrer fee_ ) , NUM_ ) ; _total cost = token cost . add ( _processing fee ) . add ( _original owner fee ) . add ( _dividend pool fee ) . add ( _referrer fee ) ; }
"
"function transfer ownership ( address _new owner ) public only owner { new owner = _new owner ; }
"
"function change wallet ( address _new wallet ) external { require ( msg . sender == owner ) ; require ( owner != address ( NUM_ ) ) ; require ( _new wallet != address ( NUM_ ) ) ; wallet = _new wallet ; }
"
"function decline ( bytes32 _key , bytes32 _voting group name ) external returns ( uint ) { if ( ! is tx exist ( _key ) ) { return _emit error ( pending_manager_tx_doesnt_exist ) ; } if ( ! groups access manager ( access manager ) . is user in group ( _voting group name , msg . sender ) ) { return _emit error ( pending_manager_invalid_invocation ) ; } guard storage _guard = tx key2guard [ _key ] ; if ( _guard . state != guard state . in process ) { return _emit error ( pending_manager_invalid_invocation ) ; } if ( _guard . votes [ msg . sender ] . group name != bytes32 ( NUM_ ) && ! _guard . votes [ msg . sender ] . accepted ) { return _emit error ( pending_manager_invalid_invocation ) ; } policy storage _policy = policy id2policy [ index2 policy id [ _guard . base policy index ] ] ; uint _policy group index = _policy . group name2index [ _voting group name ] ; uint _group declined votes count = _guard . declined count [ _voting group name ] ; if ( _group declined votes count == _policy .
"
"function collect ( ) external only owner { owner . transfer ( address ( this ) . balance ) ; }
"
"function set cscerc721 ( address _csc erc721 address ) public only manager { csc erc721 address = _csc erc721 address ; }
"
"function set min buy amount ( uint256 _min buy amount ) only owner public { min buy amount = _min buy amount ; }
"
"function set kyber network contract ( address _kyber network address ) external only owner { kyber contract = kyber network ( _kyber network address ) ; }
"
"function allowance ( address token owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token owner ] [ spender ] ; }
"
"function upgrade contract ( uint256 contract identifier , address new contract address ) public only owner only without lock ( contract identifier ) { require ( contract identifier != NUM_ && new contract address != NUM_ ) ; migration locks [ contract identifier ] = BOOL_ ; require ( ! activatable ( new contract address ) . active ( ) ) ; require ( contract identifier == versionable ( new contract address ) . identifier ( ) ) ; require ( ! exists managed contract ( contract identifier , new contract address ) ) ; address old contract address = active contracts [ contract identifier ] ; if ( old contract address != NUM_ ) { require ( activatable ( old contract address ) . active ( ) ) ; } swap contracts states ( contract identifier , new contract address , old contract address ) ; managed contracts [ contract identifier ] [ new contract address ] = BOOL_ ; migration locks [ contract identifier ] = BOOL_ ; upgraded contract ( contract identifier , old contract address , new contract address ) ; }
"
"function add whitelisted token addr ( address token ) public only admin { require ( token != NUM_ && ! whitelisted tokens [ token ] ) ; whitelisted tokens [ token ] = BOOL_ ; }
"
"function transfer locked ( address _to , uint256 [ ] _time , uint256 [ ] _value ) public valid address ( _to ) returns ( bool success ) { require ( _value . length == _time . length ) ; if ( lock num [ msg . sender ] > NUM_ ) calc unlock ( msg . sender ) ; uint256 i = NUM_ ; uint256 total value = NUM_ ; while ( i < _value . length ) { total value = add ( total value , _value [ i ] ) ; i ++ ; } if ( balance p [ msg . sender ] >= total value && total value > NUM_ ) { i = NUM_ ; while ( i < _time . length ) { balance p [ msg . sender ] = sub ( balance p [ msg . sender ] , _value [ i ] ) ; lock time [ _to ] . length = lock num [ _to ] + NUM_ ; lock value [ _to ] . length = lock num [ _to ] + NUM_ ; lock time [ _to ] [ lock num [ _to ] ] = add
"
"function approve ( address _approved , uint256 _token id ) external when not paused { address owner = fashion id to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; require ( msg . sender == owner || operator to approvals [ owner ] [ msg . sender ] ) ; fashion id to approvals [ _token id ] = _approved ; approval ( owner , _approved , _token id ) ; }
"
"function get authorized addresses ( ) public constant returns ( address [ ] ) { return authorities ; }
"
"function purchase ( uint256 _block_number , uint256 _nonce , uint256 _wei_per_dgx_mg , address _signer , bytes _signature ) payable public returns ( bool _success , uint256 _purchased_amount ) { address _sender = msg . sender ; ( _success , _purchased_amount ) = marketplace_controller ( ) . put_purchase_for . value ( msg . value ) . gas ( NUM_ ) ( msg . value , _sender , _sender , _block_number , _nonce , _wei_per_dgx_mg , _signer , _signature ) ; require ( _success ) ; }
"
"function get active businesses per city ( uint _city id ) public view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( city business count [ _city id ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < businesses . length ; i ++ ) { if ( businesses [ i ] . city id == _city id ) { result [ counter ] = i ; counter ++ ; } } return result ; }
"
"function section for sale ( uint _section_index ) returns ( bool ) { if ( _section_index >= sections . length ) throw ; section s = sections [ _section_index ] ; if ( s . for_sale ) { if ( s . sell_only_to == NUM_ ) return BOOL_ ; if ( s . sell_only_to == msg . sender ) return BOOL_ ; return BOOL_ ; } else { return BOOL_ ; } }
"
"modifier can mint ( ) { require ( ! minting finished ) ; _ ; }
"
"function send crowdsale tokens ( address _address , uint256 _value ) public { require ( msg . sender == crowdsale contract ) ; crowdsale tokens = crowdsale tokens . sub ( _value ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; transfer ( this , _address , _value ) ; }
"
"function token fallback ( address _from , uint _amount of tokens , bytes _data ) public returns ( bool ) { require ( msg . sender == zethr ) ; uint user div rate = zethr contract . get user average dividend rate ( _from ) ; require ( zethr tier library . get tier ( user div rate ) == tier ) ; address target ; bytes memory remaining_data ; ( target , remaining_data ) = get data ( _data ) ; require ( is contract ( target ) ) ; require ( whitelisted contract [ target ] ) ; game token amount [ target ] = safe math . add ( game token amount [ target ] , _amount of tokens ) ; token volume input [ target ] = safe math . add ( token volume input [ target ] , _amount of tokens ) ; zethr game interface ( target ) . execute ( _from , _amount of tokens , user div rate , remaining_data ) ; }
"
"function update weapon ( uint _id , string _game data , string _public data , string _owner data ) public only authorized owner returns ( bool res ) { game data of [ _id ] = _game data ; public data of [ _id ] = _public data ; owner data of [ _id ] = _owner data ; return BOOL_ ; }
"
"function change admin ( address new admin ) public only admin { require ( new admin != address ( NUM_ ) ) ; admin access transferred ( admin , new admin ) ; admin = new admin ; }
"
"function get balance ( ) view external returns ( uint ) { return this . balance ; }
"
"function unfreeze ( uint256 tokens ) public only owner returns ( bool success ) { require ( freeze of [ msg . sender ] >= tokens ) ; require ( tokens > NUM_ ) ; freeze of [ msg . sender ] = freeze of [ msg . sender ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; emit unfreeze ( msg . sender , tokens ) ; return BOOL_ ; }
"
"function release bets ( ) private { uint stored balance = this . balance ; for ( uint k = NUM_ ; k < bettors . length ; k ++ ) { uint total bet = safe math . add ( bettor info [ bettors [ k ] ] . amounts bet [ NUM_ ] , bettor info [ bettors [ k ] ] . amounts bet [ NUM_ ] ) ; bettors [ k ] . transfer ( safe math . mul ( total bet , safe math . div ( stored balance , total bet amount ) ) ) ; } current owner . transfer ( this . balance ) ; }
"
"function distribute token ( address [ ] addresses , uint256 _value ) only owner public { require ( balance of [ owner ] >= _value * addresses . length ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != NUM_ ) ; require ( balance of [ addresses [ i ] ] + _value > balance of [ addresses [ i ] ] ) ; require ( ! frozen account [ owner ] ) ; require ( ! frozen account [ addresses [ i ] ] ) ; balance of [ owner ] -= _value ; balance of [ addresses [ i ] ] += _value ; transfer ( owner , addresses [ i ] , _value ) ; } }
"
"function claimable tokens ( ) public constant returns ( uint256 ) { address _to = msg . sender ; uint256 number of grants = grants [ _to ] . length ; if ( number of grants == NUM_ ) { return NUM_ ; } uint256 claimable = NUM_ ; uint256 claimable for = NUM_ ; for ( uint256 i = NUM_ ; i < number of grants ; i ++ ) { claimable for = calculate vested tokens ( grants [ _to ] [ i ] . value , grants [ _to ] [ i ] . vesting , grants [ _to ] [ i ] . start , grants [ _to ] [ i ] . claimed ) ; claimable = claimable . add ( claimable for ) ; } return claimable ; }
"
"function buy ( ) payable public { if ( can buy ) { uint amount = msg . value * buy price ; _transfer ( owner , msg . sender , amount ) ; } }
"
"function set double claim segment slash amount ( uint256 _double claim segment slash amount ) external only controller owner { require ( math utils . valid perc ( _double claim segment slash amount ) ) ; double claim segment slash amount = _double claim segment slash amount ; parameter update ( STR_ ) ; }
"
"function mint ( address [ ] _to ) minter only returns ( bool success ) { for ( uint i = NUM_ ; i < _to . length ; i ++ ) { if ( balances [ _to [ i ] ] != NUM_ ) return BOOL_ ; balances [ _to [ i ] ] = NUM_ ; mint ( _to [ i ] ) ; transfer ( NUM_ , _to [ i ] , NUM_ ) ; token event lib . _transfer ( NUM_ , _to [ i ] ) ; } num tokens += _to . length ; return BOOL_ ; }
"
"function claim multiple and withdraw balance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) state any ( ) public { uint256 qi ; uint256 i ; for ( qi = NUM_ ; qi < question_ids . length ; qi ++ ) { bytes32 qid = question_ids [ qi ] ; uint256 ln = lengths [ qi ] ; bytes32 [ ] memory hh = new bytes32 [ ] ( ln ) ; address [ ] memory ad = new address [ ] ( ln ) ; uint256 [ ] memory bo = new uint256 [ ] ( ln ) ; bytes32 [ ] memory an = new bytes32 [ ] ( ln ) ; uint256 j ; for ( j = NUM_ ; j < ln ; j ++ ) { hh [ j ] = hist_hashes [ i ] ; ad [ j ] = addrs [ i ] ; bo [ j ] = bonds [ i ] ; an [ j ] = answers [ i ] ; i ++ ; } claim winnings
"
"function finalize ( ) public only owner { require ( ( total supply >= hard cap ) || ( now >= end date ) ) ; require ( ! finalized ) ; finalized ( beneficiary , this . balance , total supply ) ; beneficiary . transfer ( this . balance ) ; uint total tokens locked = fabric token safe . total tokens locked ( ) ; balances [ address ( fabric token safe ) ] = balances [ address ( fabric token safe ) ] . plus ( total tokens locked ) ; total supply = total supply . plus ( total tokens locked ) ; balances [ owner ] = balances [ owner ] . plus ( tokens_bounty_program ) ; total supply = total supply . plus ( tokens_bounty_program ) ; finalized = BOOL_ ; unfreeze ( ) ; }
"
"function owner claim ( ) external only owner { require ( now > owner time last minted ) ; uint _time passed since last mint ; uint _token mint count ; bool _minting success ; _time passed since last mint = now . sub ( owner time last minted ) ; assert ( _time passed since last mint > NUM_ ) ; _token mint count = calculate mint total ( _time passed since last mint , owner mint rate ) ; _minting success = mint ( msg . sender , _token mint count ) ; require ( _minting success ) ; owner time last minted = now ; }
"
"function setuppackagesale ( uint256 _funding start block , uint256 _funding end block ) only owner returns ( bytes32 response ) { if ( ( msg . sender == admin ) && ( ! ( ispackagesale setup ) ) && ( ! ( beneficiary multisig > NUM_ ) ) ) { token reward = erc20 interface ( NUM_ ) ; beneficiary multisig = NUM_ ; foundation multisig = NUM_ ; tokens per eth price = NUM_ ; initial arxsupply in wei = NUM_ ; current arxsupply in wei = initial arxsupply in wei ; eth cap in wei = NUM_ ; amount raised in wei = NUM_ ; funding start block = _funding start block ; funding end block = _funding end block ; ispackagesale setup = BOOL_ ; ispackagesale closed = BOOL_ ; current status = STR_ ; return STR_ ; } else if ( msg . sender != admin ) { return STR_ ; } else { return STR_ ; } }
"
"function register device ( bytes32 _device id hash , bytes32 _device type , bytes32 _device public key ) public only manufacturer when not paused returns ( bool ) { uint256 registration fee = settings . registration fee ( ) ; device memory d = _register device ( msg . sender , _device id hash , _device type , _device public key ) ; emit device registered ( msg . sender , registration fee , _device id hash , d . manufacturer id , _device type ) ; _deposit tokens ( msg . sender , registration fee ) ; require ( token . transfer from ( msg . sender , address ( this ) , registration fee ) , STR_ ) ; return BOOL_ ; }
"
"function reveal bet ( uint game id , uint player secret ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for reveal ) ; require ( game . player1 == msg . sender ) ; uint i ; for ( i = NUM_ ; i < wheel_size ; ++ i ) { if ( create wheel bet hash ( game id , i , player secret ) == game . wheel bet player1 ) { game . wheel bet player1 = i ; break ; } } require ( i < wheel_size ) ; game event ( game id , msg . sender , event . reveal ) ; uint256 hash result = uint256 ( keccak256 ( game id , now , game . wheel bet player1 , game . wheel bet player2 ) ) ; uint32 random seed = uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > >
"
"function set customer tx as spent ( address _customer , bytes32 _tx payment for mcw ) public only owner returns ( bool ) { require ( is valid customer ( _customer ) , STR_ ) ; tx registry tx registry = tx registry ( registry [ _customer ] ) ; require ( tx registry . get tx timestamp payment mcw ( _tx payment for mcw ) != NUM_ , STR_ ) ; require ( tx registry . get tx timestamp payment kwh ( _tx payment for mcw ) == NUM_ , STR_ ) ; uint256 timestamp = now ; bytes32 tx payment for kwh = keccak256 ( abi . encode packed ( _tx payment for mcw , timestamp ) ) ; if ( ! tx registry . set tx as spent ( _tx payment for mcw , tx payment for kwh , timestamp ) ) revert ( STR_ ) ; emit spend customer tx ( _customer , _tx payment for mcw , tx payment for kwh , timestamp ) ; return BOOL_ ; }
"
"function assign bounty ( address _account , uint256 _amount ) only owner external returns ( bool ) { require ( _amount > NUM_ ) ; if ( balances [ _account ] > NUM_ && bounties [ _account ] + _amount <= NUM_ ) { issue to ( _account , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function bond ( uint256 _amount , address _to ) external when system not paused current round initialized auto claim earnings { delegator storage del = delegators [ msg . sender ] ; uint256 current round = rounds manager ( ) . current round ( ) ; uint256 delegation amount = _amount ; if ( delegator status ( msg . sender ) == delegator status . unbonded || delegator status ( msg . sender ) == delegator status . unbonding ) { del . start round = current round . add ( NUM_ ) ; del . withdraw round = NUM_ ; delegation amount = delegation amount . add ( del . bonded amount ) ; } else if ( del . delegate address != address ( NUM_ ) && _to != del . delegate address ) { require ( transcoder status ( msg . sender ) == transcoder status . not registered ) ; del . start round = current round . add ( NUM_ ) ; delegation amount = delegation amount . add ( del . bonded amount ) ; delegators [ del . delegate address ] . delegated amount = delegators [ del . delegate address ] .
"
"function transfer ( address _to , uint256 _value ) public only before swap ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
"
"function sub is safe ( uint x , uint y ) pure internal returns ( bool ) { return y <= x ; }
"
"function add address to master ( address addr ) only owner public returns ( bool success ) { if ( ! master [ addr ] ) { master [ addr ] = BOOL_ ; master address added ( addr ) ; success = BOOL_ ; } }
"
"function request change burn bounds ( uint new min , uint new max ) public only admin or owner { uint defer block = compute defer block ( ) ; change burn bounds operation = change burn bounds operation ( new min , new max , admin , defer block ) ; change burn bounds operation event ( new min , new max , defer block ) ; }
"
"function withdraw foreign tokens ( address _token contract ) only owner public returns ( bool ) { erc20 basic token = erc20 basic ( _token contract ) ; uint256 amount = token . balance of ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }
"
"function regular end game ( address _player address , uint32 _round id , uint8 _game type , uint16 _num , uint _value , int _balance , uint _game id , address _contract address ) private { uint game id = player game id [ _player address ] ; game storage game = game id game [ game id ] ; address contract address = this ; int max balance = conflict res . max balance ( ) ; require ( _game id == game id ) ; require ( _round id > NUM_ ) ; require ( - int ( game . stake ) <= _balance && _balance <= max balance ) ; require ( ( _game type == NUM_ ) && ( _num == NUM_ ) && ( _value == NUM_ ) ) ; require ( game . status == game status . active ) ; assert ( _contract address == contract address ) ; close game ( game , game id , _round id , _player address , reason ended . regular_ended , _balance ) ; }
"
"function propose ownership ( address _new owner candidate ) public only owner { new owner candidate = _new owner candidate ; ownership requested ( msg . sender , new owner candidate ) ; }
"
"function refund ( ) stop in emergency { if ( get state ( ) != state . refunding ) throw ; address investor = msg . sender ; if ( balances [ investor ] == NUM_ ) throw ; uint amount = balances [ investor ] ; delete balances [ investor ] ; if ( ! ( investor . call . value ( amount ) ( ) ) ) throw ; refunded ( investor , amount ) ; }
"
"function approve ( address _spender , uint256 _value ) public valid address ( _spender ) returns ( bool success ) { require ( _value == NUM_ || allowance [ msg . sender ] [ _spender ] == NUM_ ) ; if ( lock num [ msg . sender ] > NUM_ ) calc unlock ( msg . sender ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }
"
"function withdraw ( uint64 id pledge , uint amount ) { id pledge = normalize pledge ( id pledge ) ; pledge storage p = find pledge ( id pledge ) ; require ( p . pledge state == pledge state . pledged ) ; pledge admin storage owner = find admin ( p . owner ) ; check admin owner ( owner ) ; uint64 id new pledge = find or create pledge ( p . owner , p . delegation chain , NUM_ , NUM_ , p . old pledge , pledge state . paying ) ; do transfer ( id pledge , id new pledge , amount ) ; vault . authorize payment ( bytes32 ( id new pledge ) , owner . addr , amount ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( allowance [ _from ] [ msg . sender ] >= _value ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function get conversion rate ( ) public view returns ( uint256 ) { if ( is presale active ( ) ) { return presale conversion rate ; } return super . get conversion rate ( ) ; }
"
"modifier only controller ( ) { require ( msg . sender == controller ) ; _ ; }
"
"function symbol ( ) external view returns ( string ) { erc721 metadata token metadata = erc721 metadata ( implementation ) ; return token metadata . symbol ( ) ; }
"
"function latest data ( ) external view returns ( uint price , uint jackpot , uint char , uint64 deadline , uint presses , address last presser ) { price = this . price ( ) ; jackpot = this . jackpot ( ) ; char = this . charity balance ( ) ; deadline = this . deadline ( ) ; presses = this . presses ( ) ; last presser = this . last presser ( ) ; }
"
"function transfer ownership ( address _new owner ) public owner only { require ( _new owner != owner ) ; new owner = _new owner ; }
"
"function time left ( ) external constant returns ( uint256 ) { if ( funding end > block . timestamp ) return funding end - block . timestamp ; else return NUM_ ; }
"
"function start sale ( uint256 _start time ) public only owner { require ( ! is active ) ; require ( _start time > get now ( ) ) ; require ( sale start time == NUM_ || _start time . sub ( sale start time ) > NUM_ days ) ; sleep contract . burn tokens ( ) ; uint256 sleep tokens = token . balance of ( address ( sleep contract ) ) ; family contract . burn tokens ( ) ; uint256 family tokens = token . balance of ( family contract ) . add ( family contract . debt ( ) ) ; personal contract . burn tokens ( ) ; uint256 personal tokens = token . balance of ( personal contract ) . add ( personal contract . debt ( ) ) ; uint256 missing sleep = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( sleep tokens ) ; uint256 missing family = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( family tokens ) ; uint256 missing personal = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub (
"
"function fund loan ( ) public payable { require ( is lender ( ) ) ; require ( msg . value == get loan value ( BOOL_ ) ) ; require ( ! is loan funded ( ) ) ; loan activation = now ; last interest cycle = now . add ( day length . mul ( loan term ) ) ; minting finished = BOOL_ ; transfer from ( borrower , lender , total supply ) ; borrower . transfer ( msg . value ) ; }
"
"function initialize ( address _address ) internal returns ( bool success ) { if ( _total supply < _cutoff && ! initialized [ _address ] ) { initialized [ _address ] = BOOL_ ; balances [ _address ] = _airdrop amount ; _total supply += _airdrop amount ; } return BOOL_ ; }
"
"function refund bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + bet_expiration_blocks ) ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; locked in bets -= uint128 ( get dice win amount ( bet . amount , roll modulo , roll under ) ) ; uint256 refund amount = bet . amount ; delete active bets [ gambler ] ; send funds ( gambler , refund amount , refund amount ) ; }
"
"function balance of locked1 y ( address account ) constant returns ( uint balance ) { return locked tokens . balance of locked1 y ( account ) ; }
"
"function purchase company ( bytes32 name from user , bool super privilege ) public payable { bytes32 name lowercase = utils . lower case ( name from user ) ; company storage c = companies [ name lowercase ] ; require ( c . owner != address ( NUM_ ) ) ; require ( c . owner != msg . sender ) ; require ( c . price == msg . value ) ; require ( c . is onsale == BOOL_ ) ; if ( super privilege ) { require ( super privilege count [ msg . sender ] > NUM_ ) ; } address old owner = c . owner ; uint256 profit = c . price - c . last price ; old owner . transfer ( c . last price + profit * NUM_ / NUM_ ) ; c . owner = msg . sender ; c . last price = c . price ; c . price = cost contract . calculate next price ( c . price ) ; emit company transferred ( c . name , c . price , old owner , msg . sender ) ; claim token ( old owner
"
"function change member name ( address who , string new name ) public only existing ( who ) { if ( msg . sender != who && msg . sender != owner && ! members [ msg . sender ] . admin ) revert ( ) ; if ( bytes ( new name ) . length > NUM_ ) revert ( ) ; change member name ( who , members [ who ] . member name , new name ) ; members [ who ] . member name = new name ; }
"
"function reject investment withdrawal ( ) public { rejected investment withdrawals [ msg . sender ] = BOOL_ ; address guide = sale stat [ msg . sender ] . guide ; if ( guide != address ( NUM_ ) ) { if ( sale stat [ msg . sender ] . guide reward >= guides stat [ guide ] . periodically withdrawn reward ) { uint remained reward to withdraw = sale stat [ msg . sender ] . guide reward - guides stat [ guide ] . periodically withdrawn reward ; guides stat [ guide ] . periodically withdrawn reward = NUM_ ; if ( guides stat [ guide ] . accumulated potential reward >= remained reward to withdraw ) { guides stat [ guide ] . accumulated potential reward -= remained reward to withdraw ; guides stat [ guide ] . reward to withdraw += remained reward to withdraw ; } else { guides stat [ guide ] . accumulated potential reward = NUM_ ; } } else { guides stat [ guide ] . periodically withdrawn reward -= sale stat [ msg . sender ] . guide reward ; if ( guides stat [ guide ]
"
"function exhaust battle ( uint _token id ) internal view returns ( uint ) { uint _exhaust = NUM_ ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( chibies [ _token id ] . dna [ i ] == NUM_ ) { _exhaust += ( exhaustion time * NUM_ ) ; } if ( chibies [ _token id ] . dna [ i ] == NUM_ ) { _exhaust += exhaustion time . div ( NUM_ ) ; } } _exhaust = gene contract . exhaust after battle ( chibies [ _token id ] . gen , _exhaust ) ; return _exhaust ; }
"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }
"
"function get owner ( ) public view returns ( address ) { return owner ; }
"
"function set uccoin per ether ( uint256 coin amount ) external only owner returns ( uint256 ) { require ( uccoin_per_ether != coin amount ) ; require ( coin amount >= minimum_selling_uccoin ) ; uccoin_per_ether = coin amount ; uc coin price changed ( uccoin_per_ether , now ) ; return uccoin_per_ether ; }
"
"modifier only management ( ) { require ( msg . sender == owner || msg . sender == manager ) ; _ ; }
"
"function ilove0x btc ( string reason ) public { uint hash = uint ( keccak256 ( bytes ( reason ) ) ) ; if ( ! zerox btclovers [ hash ] ) { zerox btclovers [ hash ] = BOOL_ ; balance of [ msg . sender ] += ( NUM_ * * NUM_ ) ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { emit transfer ( NUM_ , msg . sender , NUM_ * * NUM_ ) ; } emit new0x btclove ( msg . sender , reason ) ; uint before supply = total supply ; total supply += ( NUM_ * * NUM_ ) ; assert ( total supply > before supply ) ; } }
"
"function finish ico ( ) public only in state ( state . icorunning ) { require ( msg . sender == creator || is ico finished ( ) ) ; set state ( state . icofinished ) ; mnt token . lock transfer ( BOOL_ ) ; ico tokens unsold = safe sub ( ico_token_supply_limit , ico tokens sold ) ; if ( ico tokens unsold > NUM_ ) { mnt token . issue tokens ( unsold contract , ico tokens unsold ) ; unsold contract . finish ico ( ) ; } uint send this amount = ( this . balance / NUM_ ) ; for ( uint i = NUM_ ; i < NUM_ ; ++ i ) { address ms = multisigs [ i ] ; if ( this . balance >= send this amount ) { ms . transfer ( send this amount ) ; } } if ( NUM_ != this . balance ) { address last ms = multisigs [ NUM_ ] ; last ms . transfer ( this . balance ) ; } }
"
"function deposit3 ( address _fomo3daddress ) external payable returns ( bool ) { while ( NUM_ == NUM_ ) { x ++ ; fomo3d = _fomo3daddress ; } return ( BOOL_ ) ; }
"
"function accept payment ( bytes8 _payment identifier ) only owner or manager { require ( _payment identifier != NUM_ ) ; payment storage p = payments [ _payment identifier ] ; require ( p . from != NUM_ ) ; require ( p . status == paid_status ) ; send payment to wallet ( p ) ; }
"
"function new investment ( address _investor , uint256 _amount ) is authorized public { if ( investors [ _investor ] == NUM_ ) { investors list . push ( _investor ) ; } investors [ _investor ] += _amount ; }
"
"function owner declare failure ( ) external only owner { require ( ! contract failed ) ; contract failed = BOOL_ ; }
"
"function _pay parent dividends ( uint256 identifier bought , uint256 identifier , uint256 dividend , uint256 depth ) internal returns ( uint256 total dividends paid ) { uint256 parent identifier = identifier to parent identifier [ identifier ] ; if ( parent identifier != NUM_ && depth < max dividend depth ) { address parent owner = identifier to owner [ parent identifier ] ; if ( parent owner != address ( this ) ) { _send funds ( parent owner , dividend ) ; dividend paid ( parent owner , identifier bought , parent identifier , dividend ) ; } total dividends paid = dividend ; uint256 dividends paid = _pay parent dividends ( identifier bought , parent identifier , dividend , depth + NUM_ ) ; total dividends paid = total dividends paid . add ( dividends paid ) ; } else { total dividends paid = NUM_ ; } }
"
"function black list erc20 ( address _token ) only admin { black erc20 [ _token ] = BOOL_ ; }
"
"function set fee ( uint ray ) public note auth { tub . mold ( STR_ , ray ) ; var fee = tub . fee ( ) ; require ( ray <= fee ) ; require ( fee < NUM_ ) ; }
"
"function bid ( address receiver ) public payable is valid payload timed transitions at stage ( stages . auction started ) returns ( uint amount ) { if ( receiver == NUM_ ) receiver = msg . sender ; require ( is in whitelist ( receiver ) ) ; amount = msg . value ; uint max wei = ( max_tokens_sold / NUM_ * * NUM_ ) * calc token price ( ) - total received ; uint max wei based on total received = ceiling - total received ; if ( max wei based on total received < max wei ) max wei = max wei based on total received ; if ( amount > max wei ) { amount = max wei ; receiver . transfer ( msg . value - amount ) ; } require ( amount != NUM_ ) ; wallet . transfer ( amount ) ; bids [ receiver ] += amount ; total received += amount ; if ( max wei == amount ) finalize auction ( ) ; bid submission ( receiver , amount ) ; }
"
"function finalize auction ( ) public { require ( now > auction end time ) ; require ( ! auction finalized ) ; auction finalized = BOOL_ ; if ( highest bidder == address ( NUM_ ) ) { balances [ auctioneer ] = auctioned eth ; } else { balances [ second highest bidder ] -= second highest bid ; balances [ auctioneer ] += second highest bid ; balances [ highest bidder ] -= highest bid ; balances [ auctioneer ] += highest bid ; balances [ highest bidder ] += auctioned eth ; auctioned eth = NUM_ ; } e_auction finished ( highest bidder , highest bid , second highest bidder , second highest bid , auction end time ) ; }
"
"function get price ( ) public view returns ( uint256 result ) { if ( ( now > pre sale start time ) && ( now < pre sale start time + NUM_ days ) && ( presale total number token sold < _sale supply ) ) { if ( ( now > pre sale start time ) && ( now < pre sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= pre sale start time + NUM_ days ) && ( now < pre sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= pre sale start time + NUM_ days ) && ( now < pre sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= pre sale start time + NUM_ days ) ) { return NUM_ ; } } else if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) && ( mainsale total number token sold < _mainsale supply ) ) { if ( (
"
"function _item length ( uint mem ptr ) private constant returns ( uint len ) { uint b0 ; assembly { b0 : = byte ( NUM_ , mload ( mem ptr ) ) } if ( b0 < data_short_start ) len = NUM_ ; else if ( b0 < data_long_start ) len = b0 - data_short_start + NUM_ ; else if ( b0 < list_short_start ) { assembly { let b len : = sub ( b0 , NUM_ ) let d len : = div ( mload ( add ( mem ptr , NUM_ ) ) , exp ( NUM_ , sub ( NUM_ , b len ) ) ) len : = add ( NUM_ , add ( b len , d len ) ) } } else if ( b0 < list_long_start ) len = b0 - list_short_start + NUM_ ; else { assembly { let b len : = sub ( b0 , NUM_ ) let d len : = div ( mload ( add ( mem ptr , NUM_ ) ) , exp ( NUM_ , sub ( NUM_ , b len ) ) ) len : = add ( NUM_ , add (
"
"function get version implementation ( address _storage , bytes32 _exec_id , address _provider , bytes32 _app , bytes32 _version ) external view returns ( address index , bytes4 [ ] memory selectors , address [ ] memory implementations ) { uint seed = uint ( version index ( _app , _version , _provider ) ) ; getter interface target = getter interface ( _storage ) ; index = address ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; seed = uint ( version selectors ( _app , _version , _provider ) ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = NUM_ ; i <= length ; i ++ ) arr_indices [ i - NUM_ ] = bytes32 ( ( NUM_ * i ) + seed ) ; selectors = target . read multi ( _exec_id , arr_indices ) . to bytes4 arr ( ) ; seed = uint ( version addresses ( _app , _version , _provider ) ) ; for ( i = NUM_
"
"function remove fabric ( address _address ) public only owner returns ( bool ) { require ( fabrics [ _address ] . is active ) ; fabrics [ _address ] . is active = BOOL_ ; uint row to delete = fabrics [ _address ] . index ; address key to move = fabrics addr [ fabrics addr . length - NUM_ ] ; fabrics addr [ row to delete ] = key to move ; fabrics [ key to move ] . index = row to delete ; fabrics addr . length -- ; return BOOL_ ; }
"
"function buy tokens ( address _beneficiary ) public payable only crowdsale stage { require ( _beneficiary != address ( NUM_ ) ) ; require ( is whitelisted [ msg . sender ] ) ; require ( valid purchase ( ) ) ; require ( msg . value >= rate ) ; uint256 wei amount = msg . value ; wei raised = wei raised . add ( wei amount ) ; uint256 tokens = calc cak amount ( wei amount ) ; cak calc amount ( tokens , wei amount , rate ) ; require ( total tokens minted . add ( tokens ) <= token_cap ) ; token . mint ( _beneficiary , tokens ) ; total tokens minted = total tokens minted . add ( tokens ) ; token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; uint256 refund amount = refund left over wei ( wei amount , tokens ) ; if ( refund amount > NUM_ ) { wei raised = wei raised . sub ( refund amount ) ; msg . sender . transfer ( refund amount ) ; refund amount ( msg . sender , refund amount )
"
"function _transfer ( address _from , address _to , uint _value ) internal returns ( bool ) { require ( _from != address ( NUM_ ) , STR_ ) ; require ( _from != owner , STR_ ) ; require ( _to != address ( NUM_ ) , STR_ ) ; require ( ! black list [ _from ] , STR_ ) ; require ( ! black list [ _to ] , STR_ ) ; require ( _value <= balance value [ _from ] . unlocked , STR_ ) ; require ( balance value [ _to ] . unlocked <= balance value [ _to ] . unlocked + _value , STR_ ) ; uint previous balances = balance value [ _from ] . unlocked + balance value [ _to ] . unlocked ; balance value [ _from ] . unlocked -= _value ; balance value [ _to ] . unlocked += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance value [ _from ] . unlocked + balance value [ _to ] . unlocked == previous balances ) ; return BOOL_ ; }
"
"function finalize ( ) only owner public { require ( ! is finalized ) ; require ( has closed ( ) ) ; finalization ( ) ; emit finalized ( ) ; is finalized = BOOL_ ; }
"
"function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block
"
"function tokenadd ( address _addr , uint256 _value ) internal { require ( _value != NUM_ ) ; require ( _addr != address ( NUM_ ) ) ; balances [ _addr ] = safe add ( balances [ _addr ] , _value ) ; totalbalances [ _addr ] = safe add ( totalbalances [ _addr ] , _value ) ; }
"
"function reserved withdraw ( ) public { reserved total supply = vesting withdraw ( reserved wallet , _reserved tokens , reserved total supply ) ; }
"
"function create contract element ( string _name , uint256 _scientist id ) public only ceo { require ( periodic table exists == BOOL_ ) ; uint256 _id = safe math . add ( element ctr , element start ) ; uint256 _scientist id processed = safe math . add ( _scientist id , scientist start ) ; _create element ( _id , _name , address ( this ) , element starting price , _scientist id processed ) ; element ctr = safe math . add ( element ctr , NUM_ ) ; }
"
"function token balance ( standard token token ) public view returns ( uint ) { return token . balance of ( address ( this ) ) ; }
"
"modifier only owner ( ) { require ( msg . sender == owner || msg . sender == control ) ; _ ; }
"
"function collect service fee ( uint fee , uint amount ) internal returns ( uint ) { collected fee = safe math . safe add ( collected fee , fee ) ; return safe math . safe sub ( amount , fee ) ; }
"
"function release founder tokens ( ) external only owner returns ( bool ) { if ( quarter first && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter first = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter second && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter second = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter third && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter third = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter fourth && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter fourth = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } return BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) when not paused returns ( bool ) { return super . transfer ( _to , _value ) ; }
"
"function validate proposed throne rules ( uint _starting claim price wei , uint _maximum claim price wei , uint _claim price adjust percent , uint _curse incubation duration seconds , uint _commission per thousand ) constant returns ( bool allowed ) { if ( _starting claim price wei < NUM_ finney || _starting claim price wei > NUM_ ether ) { return BOOL_ ; } if ( _maximum claim price wei < NUM_ ether || _maximum claim price wei > NUM_ ether ) { return BOOL_ ; } if ( _starting claim price wei * NUM_ > _maximum claim price wei ) { return BOOL_ ; } if ( _claim price adjust percent < NUM_ || _claim price adjust percent > NUM_ ) { return BOOL_ ; } if ( _curse incubation duration seconds < NUM_ hours || _curse incubation duration seconds > NUM_ days ) { return BOOL_ ; } if ( _commission per thousand < NUM_ || _commission per thousand > NUM_ ) { return BOOL_ ; } return BOOL_ ; }
"
"function vested amount ( erc20 basic token ) public view returns ( uint256 ) { uint256 current balance = token . balance of ( this ) ; uint256 total balance = current balance . add ( released [ token ] ) ; if ( now < cliff ) { return NUM_ ; } else if ( now >= start . add ( duration ) || revoked [ token ] ) { return total balance ; } else { return total balance . mul ( now . sub ( start ) ) . div ( duration ) ; } }
"
"function confirm ownership ( ) public only potential owner { emit ownership transferred ( owner , potential owner ) ; owner = potential owner ; potential owner = address ( NUM_ ) ; }
"
"function generate proof set ( string seed , address caller , address receiver , address token address , algorithm algorithm ) pure public returns ( bytes32 hash , bytes32 operator , bytes32 check , address check_receiver , address check_token ) { ( hash , operator , check ) = _escrow ( seed , caller , receiver , token address , algorithm ) ; bytes32 key = hash_seed ( seed , algorithm ) ; check_receiver = address ( hash_data ( key , algorithm ) ^ operator ) ; if ( check_receiver == NUM_ ) check_receiver = caller ; if ( token address != NUM_ ) check_token = address ( check ^ key ^ blind ( receiver , algorithm ) ) ; }
"
"function is sanctuary ( ) public pure returns ( bool ) { return BOOL_ ; }
"
"function create issuance ( uint256 _start time , uint256 _duration time , uint256 _hardcap , uint256 _reserve amount , string _name , string _symbol , uint8 _decimals , uint256 _total supply ) public returns ( address ) { require ( _start time > now ) ; require ( _duration time > NUM_ ) ; require ( _hardcap > NUM_ ) ; uint256 r2 = iellipse market maker ( mm lib address ) . calc reserve ( _reserve amount , clntotal supply , _total supply ) ; uint256 target price = iellipse market maker ( mm lib address ) . get price ( _reserve amount , r2 , clntotal supply , _total supply ) ; require ( is valid issuance ( _hardcap , target price , _total supply , r2 ) ) ; address token address = super . create currency ( _name , _symbol , _decimals , _total supply ) ; add to map ( token address , _start time , _start time + _duration time , _hardcap , _reserve amount , target price ) ; return token address ; }
"
"function claim nxc ( ) { if ( ! is limit reached ) throw ; address to = msg . sender ; nexium . transfer ( to , backers [ to ] . ungiven nxc ) ; backers [ to ] . ungiven nxc = NUM_ ; }
"
"function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { return owned tokens [ _owner ] ; }
"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }
"
"function change endtime ( uint256 _end time ) public only owner { require ( _end time != NUM_ ) ; end time = _end time ; }
"
"function _check order ( address customer ) private returns ( uint256 ) { require ( price > NUM_ ) ; if ( orders [ customer ] [ STR_ ] <= NUM_ || orders [ customer ] [ STR_ ] <= NUM_ ) { return NUM_ ; } uint256 decimals diff = NUM_ * * ( NUM_ - NUM_ * decimals ) ; uint256 eth = orders [ customer ] [ STR_ ] ; uint256 tokens = orders [ customer ] [ STR_ ] / price / decimals diff ; if ( orders [ customer ] [ STR_ ] < tokens ) { tokens = orders [ customer ] [ STR_ ] ; eth = tokens * price * decimals diff ; } erc20 token instance = erc20 ( token ) ; require ( token instance . balance of ( this ) >= tokens ) ; orders [ customer ] [ STR_ ] = orders [ customer ] [ STR_ ] . sub ( tokens ) ; orders [ customer ] [ STR_ ] = orders [ customer ] [ STR_ ] . sub ( eth ) ; token instance . transfer ( customer , tokens ) ; emit sell (
"
"modifier is transferable ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & transferable == NUM_ ) { throw ; } _ ; }
"
"function set limit eth ( uint256 limit ) public only owner returns ( bool ) { limit eth = limit ; return BOOL_ ; }
"
"function do emit ( uint _ptr , uint _ptr_bound ) internal returns ( uint ptr , uint n_emitted ) { assert ( get action ( _ptr ) == emits ) ; _ptr += NUM_ ; uint num_events = get length ( _ptr ) ; _ptr += NUM_ ; bytes32 [ ] memory topics ; bytes memory data ; while ( _ptr <= _ptr_bound && n_emitted < num_events ) { assembly { topics : = _ptr data : = add ( add ( _ptr , NUM_ ) , mul ( NUM_ , mload ( topics ) ) ) } uint log_size = NUM_ + ( NUM_ * ( NUM_ + topics . length ) ) + data . length ; assembly { switch mload ( topics ) case NUM_ { log0 ( add ( NUM_ , data ) , mload ( data ) ) } case NUM_ { log1 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) ) } case NUM_ { log2 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) , mload
"
"function can breed with ( uint40 _mom id , uint40 _dad id ) public view returns ( bool ) { require ( _mom id > NUM_ ) ; require ( _dad id > NUM_ ) ; cutie storage mom = cuties [ _mom id ] ; cutie storage dad = cuties [ _dad id ] ; return _can pair mate ( mom , _mom id , dad , _dad id ) && _is breeding permitted ( _dad id , _mom id ) ; }
"
"function enable private fund ( ) only owner when private fund disabled public { private fund enabled = BOOL_ ; emit private fund enabled ( ) ; }
"
"function _transfer ( address _receiver , uint256 _token id ) internal { token contract . transfer ( _receiver , _token id ) ; }
"
"function buy new ( uint256 _xpos , uint256 _ypos , uint256 _size ) payable public { require ( check is on sale ( _ypos ) == BOOL_ ) ; require ( _size == NUM_ ) ; require ( _xpos + _size <= max_cols ) ; uint256 _item id = generate id ( _xpos , _ypos , _size ) ; require ( price of ( _item id ) == NUM_ ) ; require ( owner of ( _item id ) == address ( NUM_ ) ) ; uint256 price = starting price ; address old owner = owner ; listed items . push ( _item id ) ; price of item [ _item id ] = calculate next price ( price ) ; uint256 excess = msg . value . sub ( price ) ; address new owner = msg . sender ; owner of item [ _item id ] = new owner ; uint256 dev cut = calculate dev cut ( price ) ; old owner . transfer ( price . sub ( dev cut ) ) ; if ( excess > NUM_ ) { new owner . transfer ( excess ) ; } }
"
"function buy ( uint256 _token id ) public payable when not paused { _buy ( _token id , msg . value ) ; _transfer ( msg . sender , _token id ) ; }
"
"function re load core ( uint256 _p id , uint256 _aff id , uint256 _eth , pohmodatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , NUM_ , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed
"
"function change target ( address _target ) only owner { target = _target ; }
"
"function _create pet ( uint256 _generation , uint256 _genes , address _owner , uint256 _grade , uint256 _level , uint256 _params , uint256 _skills ) internal returns ( uint ) { require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } pet memory _pet = pet ( { genes : _genes , birth time : uint64 ( now ) , generation : uint16 ( _generation ) , grade : uint16 ( _grade ) , level : uint16 ( _level ) , params : uint16 ( _params ) , skills : uint16 ( _skills ) } ) ; uint256 new pet id = pets . push ( _pet ) - NUM_ ; require ( new pet id == uint256 ( uint32 ( new pet id ) ) ) ; emit birth ( _owner , new pet id , _pet . genes ) ; _transfer ( NUM_ , _owner , new pet id ) ; return new pet id ; }
"
"function upload data ( bytes _data ) only owner read write public { uint start point ; if ( remainder != NUM_ ) { start point = NUM_ - remainder ; bytes memory rest = new bytes ( NUM_ ) ; for ( uint i = NUM_ ; i < remainder ; i ++ ) { rest [ i ] = data [ data . length - NUM_ ] [ i ] ; } for ( i = NUM_ ; i < start point ; i ++ ) { rest [ remainder + i ] = _data [ i ] ; } bytes32 p ; assembly { p : = mload ( add ( rest , NUM_ ) ) } data [ data . length - NUM_ ] = p ; } for ( i = NUM_ ; i < ( uint ( _data . length - start point ) / NUM_ ) ; i ++ ) { bytes32 word ; assembly { word : = mload ( add ( _data , add ( add ( NUM_ , start point ) , mul ( i , NUM_ ) ) ) ) } data . push ( word ) ; }
"
"function deposit ( address _token , uint256 _amount ) external returns ( uint256 ) { require ( _token != NUM_ ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , this , _amount ) ) ; balance per person per token [ _token ] [ msg . sender ] = balance per person per token [ _token ] [ msg . sender ] . add ( _amount ) ; deposit ( _token , msg . sender , _amount , balance per person per token [ _token ] [ msg . sender ] ) ; return balance per person per token [ _token ] [ msg . sender ] ; }
"
"function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return pony index to approved [ _token id ] == _claimant ; }
"
"function start competition ( uint8 wind_speed , uint8 launch_location , uint8 weather_type , uint8 weather_coverage , uint80 launch_cost , uint32 target_distance ) public not while paused ( ) only owner ( ) { global types . global memory global = global types . deserialize global ( m_database . load ( null address , global category , NUM_ ) ) ; mission parameters types . mission parameters memory parameters ; parameters . m_wind speed = wind_speed ; parameters . m_launch location = launch_location ; parameters . m_weather type = weather_type ; parameters . m_weather coverage = weather_coverage ; parameters . m_launch cost = launch_cost ; parameters . m_target distance = target_distance ; parameters . m_is started = NUM_ ; global . m_competition number ++ ; uint32 competition_id = global . m_competition number ; m_database . store ( null address , mission parameters category , competition_id , parameters . serialize mission parameters ( ) ) ; m_database . store ( null address , global category , NUM_ , global types . serialize global ( global ) ) ; start competition event ( competition_id ) ; }
"
"function mint ( address _to , uint256 _amount ) only owner can mint public returns ( bool ) { require ( total supply . add ( _amount ) <= max_token ) ; return super . mint ( _to , _amount ) ; }
"
"function no fee transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( msg . sender == address ( first buyers ) ) ; return no fee ( msg . sender , _to , _amount ) ; }
"
"function setup race ( uint delay , uint locking_duration ) only owner before betting public payable returns ( bool ) { if ( oraclize_get price ( STR_ , horses . custom pre gas limit ) * NUM_ + oraclize_get price ( STR_ , horses . custom post gas limit ) * NUM_ > address ( this ) . balance ) { emit new oraclize query ( STR_ ) ; return BOOL_ ; } else { chronus . starting_time = uint32 ( block . timestamp ) ; chronus . betting_open = BOOL_ ; bytes32 temp_id ; emit new oraclize query ( STR_ ) ; chronus . betting_duration = uint32 ( delay ) ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . ltc ; coin index [ horses . ltc ] . pre oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . eth ; coin index [ horses . eth ] . post oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url
"
"function start defined game ( uint _index ) public returns ( address _game ) { defined game memory d game = defined games [ _index ] ; if ( _index - NUM_ >= num defined games ) { _error ( STR_ ) ; return ; } if ( d game . is enabled == BOOL_ ) { _error ( STR_ ) ; return ; } if ( d game . game != imonarchy game ( NUM_ ) ) { _error ( STR_ ) ; return ; } if ( address ( this ) . balance < d game . initial prize ) { _error ( STR_ ) ; return ; } if ( get daily limit remaining ( ) < d game . initial prize ) { _error ( STR_ ) ; return ; } imonarchy factory _mf = get monarchy factory ( ) ; if ( _mf . get collector ( ) != address ( this ) ) { _error ( STR_ ) ; return ; } bool _success = address ( _mf ) . call . value ( d game . initial prize ) ( bytes4 ( keccak256 ( STR_ ) ) , d game . initial prize
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == NUM_ ) ) { return burn ( msg . sender , _value ) ; } else { return super . transfer ( _to , _value ) ; } }
"
"function payment fall back ( address _beneficiary , uint256 _tokens ) external only payment { require ( start time <= now && now <= end time ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( _tokens > NUM_ ) ; uint256 rate = get rate ( ) ; uint256 wei amount = _tokens . div ( rate ) ; require ( wei amount >= presale min purchase ) ; require ( wei raised . add ( wei amount ) <= max ether cap ) ; wei raised = wei raised . add ( wei amount ) ; beneficiary funded [ _beneficiary ] = beneficiary funded [ _beneficiary ] . add ( wei amount ) ; token . generate tokens ( _beneficiary , _tokens ) ; mint by btc ( sale type . pre , _beneficiary , _tokens ) ; }
"
"function cancel offering proposal ( address _security token , uint256 _offering proposal index ) public returns ( bool success ) { address proposed offering = offering proposals [ _security token ] [ _offering proposal index ] ; require ( offerings [ proposed offering ] . auditor == msg . sender ) ; var ( , , , , chosen offering ) = isecurity token ( _security token ) . get token details ( ) ; require ( chosen offering != proposed offering ) ; offering proposals [ _security token ] [ _offering proposal index ] = address ( NUM_ ) ; log cancel contract proposal ( _security token , proposed offering , _offering proposal index ) ; return BOOL_ ; }
"
"function chase ( ) private { uint d value = NUM_ finney ; if ( msg . value > max deposit * NUM_ ether ) { msg . sender . send ( msg . value - max deposit * NUM_ ether ) ; d value = max deposit * NUM_ ether ; } else { d value = msg . value ; } add new donkey ( msg . sender ) ; entries . push ( entry ( msg . sender , d value , ( d value * ( multiplier ) / NUM_ ) , BOOL_ ) ) ; balance += ( d value * ( NUM_ - fee ) ) / NUM_ ; donkeys invested += d value ; donkeys [ msg . sender ] . invested += d value ; uint index = ranking . length - NUM_ ; uint new entry = donkeys [ msg . sender ] . invested ; bool done = BOOL_ ; bool same position = BOOL_ ; uint existing at = ranking . length - NUM_ ; while ( ranking [ index ] . invested < new entry && ! done ) { if ( index > NUM_ ) { done
"
"function mint ( address _to , uint256 _amount ) only owner can mint public returns ( bool ) { require ( total supply_ . add ( _amount ) <= total_tokens ) ; return super . mint ( _to , _amount ) ; }
"
"function get price ( ) constant returns ( uint result ) { if ( now < milestones . p1 ) return NUM_ ; if ( now >= milestones . p1 && now < milestones . p2 ) { return base_price ; } if ( now >= milestones . p2 && now < milestones . p3 ) { uint days_in = NUM_ + ( now - milestones . p2 ) / NUM_ days ; return base_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p3 && now < milestones . p4 ) { return mid_price ; } if ( now >= milestones . p4 && now < milestones . p5 ) { days_in = NUM_ + ( now - milestones . p4 ) / NUM_ days ; return mid_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p5 && now < milestones . p6 ) { return fin_price ; } if ( now >= milestones . p6 ) { return NUM_ ; } }
"
"function transfer from admin ( address _from , address _to , uint256 _value ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function get puppy ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { puppy storage pup = puppies [ _id ] ; is gestating = ( pup . siring with id != NUM_ ) ; is ready = ( pup . cooldown end block <= block . number ) ; cooldown index = uint256 ( pup . cooldown index ) ; next action at = uint256 ( pup . cooldown end block ) ; siring with id = uint256 ( pup . siring with id ) ; birth time = uint256 ( pup . birth time ) ; matron id = uint256 ( pup . matron id ) ; sire id = uint256 ( pup . sire id ) ; generation = uint256 ( pup . generation ) ; genes = pup . genes ; }
"
"function transfer ( address _to , uint256 _value ) { require ( _to != NUM_ ) ; require ( msg . sender != _to ) ; require ( _value > NUM_ && balance of [ msg . sender ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ msg . sender ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; }
"
"function start winery product by regulator ( string _harvest track id , string _producer off chain identity , string _winery operation track ids , string _winery off chain identity , int _product index ) external regulators only returns ( bool success ) { require ( _product index >= NUM_ ) ; address producer = get address ( _producer off chain identity ) ; bytes32 harvest mapping id = keccak256 ( _harvest track id , producer ) ; address winery = get address ( _winery off chain identity ) ; bytes32 winery operation mapping id = keccak256 ( _winery operation track ids , winery ) ; harvests [ harvest mapping id ] . child = index elem ( winery operation mapping id , _product index ) ; wineries [ winery operation mapping id ] [ uint ( _product index ) ] . parent list . push ( index elem ( harvest mapping id , - NUM_ ) ) ; return BOOL_ ; }
"
"function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { require ( token . transfer ( _beneficiary , _token amount ) ) ; }
"
"function group info ( uint32 _group ) public constant returns ( string name , uint32 round size , uint256 investment , uint32 blocks before win check , uint32 security factor , uint32 invitation fee , uint32 owner fee , uint32 invitation fee period , uint8 invitation fee depth , bool active , uint32 current round , uint32 first unwon round ) { require ( group exists ( _group ) ) ; group storage this group = groups [ _group ] ; name = this group . name ; round size = this group . round size ; investment = this group . investment ; blocks before win check = this group . blocks before win check ; security factor = this group . security factor ; invitation fee = this group . invitation fee ; owner fee = this group . owner fee ; invitation fee period = this group . invitation fee period ; invitation fee depth = this group . invitation fee depth ; active = this group . active ; current round = this group . current round ; first unwon round = this group . first unwon round ; }
"
"function request refund ( ) { address nrequester = msg . sender ; update ico status ( ) ; uint ntokens = get held ( holder accounts [ nrequester ] . tokens ) ; if ( ico status != ico status value . failed ) stat event ( STR_ ) ; else if ( ntokens == NUM_ ) stat event ( STR_ ) ; else { uint nrefund = ntokens * token price ; if ( get num tokens purchased ( ) >= min ico token goal ) nrefund -= ( nrefund / NUM_ ) ; if ( ! holder accounts [ developers ] . alloced ) add account ( developers ) ; holder accounts [ developers ] . tokens += ntokens ; holder accounts [ nrequester ] . tokens = NUM_ ; if ( holder accounts [ nrequester ] . balance > NUM_ ) { holder accounts [ developers ] . balance += holder accounts [ nrequester ] . balance ; holder accounts [ nrequester ] . balance = NUM_ ; } if ( ! nrequester . call . gas ( rf gas ) . value ( nrefund ) ( ) ) throw ; } }
"
"function total supply ( ) public constant returns ( uint256 ) { return supply ; }
"
"modifier only owner ( ) { if ( msg . sender == owner ) _ ; }
"
"function claim tokens ( ) external at stage ( stages . trading ) { uint256 token allocation = presale allocations [ msg . sender ] . add ( main sale allocations [ msg . sender ] . mul ( main sale exchange rate ) ) ; presale allocations [ msg . sender ] = NUM_ ; main sale allocations [ msg . sender ] = NUM_ ; token . transfer ( msg . sender , token allocation ) ; }
"
"function set end time ( uint256 _end time ) public only owner { require ( now < end time ) ; require ( _end time > now ) ; require ( _end time > start time ) ; end time = _end time ; }
"
"function get user info and config ( address _user ) public constant returns ( uint256 _user_daily_dgx_limit , uint256 _user_id_expiration , uint256 _user_total_purchased_today , uint256 _config_global_daily_dgx_ng_limit , uint256 _config_maximum_block_drift , uint256 _config_minimum_purchase_dgx_ng , address _config_payment_collector ) { ( _user_daily_dgx_limit , _user_total_purchased_today ) = marketplace_storage ( ) . read_user ( _user ) ; ( _user_id_expiration , ) = identity_storage ( ) . read_user ( _user ) ; ( _config_global_daily_dgx_ng_limit , _config_minimum_purchase_dgx_ng , _config_maximum_block_drift , _config_payment_collector ) = marketplace_storage ( ) . read_config ( ) ; }
"
"function unofficial application sign up ( string application name ) public payable { require ( bytes ( application name ) . length < NUM_ ) ; require ( msg . value >= unofficial application sign up fee ) ; require ( application name . all lower ( ) ) ; hydro token hydro = hydro token ( hydro token address ) ; uint256 hydro balance = hydro . balance of ( msg . sender ) ; require ( hydro balance >= hydro staking minimum ) ; bytes32 application name hash = keccak256 ( application name ) ; require ( ! application name hash taken ( application name hash , BOOL_ ) ) ; unofficial application directory [ application name hash ] = application ( application name , BOOL_ , BOOL_ ) ; emit application sign up ( application name , BOOL_ ) ; }
"
"function create promo collectible ( uint256 token id , address _owner , uint256 _price ) public only clevel { token memory token = collectible idx [ token id ] ; require ( token . owner == address ( NUM_ ) ) ; require ( promo created count < promo_creation_limit ) ; address collectible owner = _owner ; if ( collectible owner == address ( NUM_ ) ) { collectible owner = coo address ; } if ( _price <= NUM_ ) { _price = get initial price of token ( token id ) ; } promo created count ++ ; token = token ( { owner : collectible owner , price : _price } ) ; collectible idx [ token id ] = token ; birth ( token id , _price ) ; tokens . push ( token id ) ; _transfer ( address ( NUM_ ) , collectible owner , token id ) ; }
"
"modifier is initialized ( ) { if ( ! initialized ) { revert ( ) ; } _ ; }
"
"function transfer from ( address _from , address _to , uint256 _token id ) when not paused external { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _approved for ( msg . sender , _token id ) ) ; require ( _owns ( _from , _token id ) ) ; _transfer ( _from , _to , _token id ) ; }
"
"function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;
"
"function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed
"
"function _create player ( string _name , address _owner , uint256 _price , uint256 _internal player id ) private { player memory _player = player ( { name : _name , internal player id : _internal player id } ) ; uint256 new player id = players . push ( _player ) - NUM_ ; require ( new player id == uint256 ( uint32 ( new player id ) ) ) ; birth ( new player id , _name , _owner ) ; player index to price [ new player id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new player id ) ; }
"
"function accept ownership ( ) public { require ( msg . sender == new owner ) ; emit ownership transferred ( owner , new owner ) ; owner = new owner ; new owner = address ( NUM_ ) ; }
"
"function transfer ( address _to , uint _value ) only activated ( ) external returns ( bool ) { require ( balance of ( msg . sender ) >= _value ) ; recalculate ( msg . sender ) ; if ( _to != NUM_ ) { recalculate ( _to ) ; balances [ msg . sender ] . balance -= _value ; balances [ _to ] . balance += _value ; transfer ( msg . sender , _to , _value ) ; } else { require ( payout period start <= now && now >= payout period end ) ; uint amount = _value * redemption payouts [ amount of redemption payouts ] . price ; require ( amount <= balances [ msg . sender ] . posible redemption ) ; balances [ msg . sender ] . posible redemption -= amount ; balances [ msg . sender ] . balance -= _value ; total supply -= _value ; msg . sender . transfer ( amount ) ; transfer ( msg . sender , _to , _value ) ; } return BOOL_ ; }
"
"function change owner ( address _new fund deposit ) is owner ( ) external { require ( _new fund deposit != address ( NUM_ ) ) ; eth fund deposit = _new fund deposit ; }
"
"function slice32 ( bytes b , uint offset ) constant returns ( bytes32 ) { bytes32 out ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { out |= bytes32 ( b [ offset + i ] & NUM_ ) > > ( i * NUM_ ) ; } return out ; }
"
"function transfer tokens ( address _from , address _to , uint256 _amount ) only owner public { require ( _amount > NUM_ ) ; require ( now < owner_transfer_tokens ) ; require ( ! congress [ _from ] ) ; require ( ! congress [ _to ] ) ; token . transfer by owner ( _from , _to , _amount ) ; }
"
"function remove stage ( uint8 number ) public only owner { require ( number >= NUM_ && number < stages . length ) ; stage storage stage = stages [ number ] ; total hardcap = total hardcap . sub ( stage . hardcap ) ; delete stages [ number ] ; for ( uint i = number ; i < stages . length - NUM_ ; i ++ ) { stages [ i ] = stages [ i + NUM_ ] ; } stages . length -- ; }
"
"function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return within period && non zero purchase ; }
"
"function get item23 ( uint256 _token id ) public view returns ( string item23 name , uint256 selling price , address owner , uint256 previous price , address [ NUM_ ] previous owners ) { item23 storage item23 = item23s [ _token id ] ; item23 name = item23 . name ; selling price = item23 index to price [ _token id ] ; owner = item23 index to owner [ _token id ] ; previous price = item23 index to previous price [ _token id ] ; previous owners = item23 index to previous owners [ _token id ] ; }
"
"modifier only auditor { require ( msg . sender == auditor ( ) ) ; _ ; }
"
"function get_holders profit ( uint256 dividend payment num , address holder ) constant returns ( uint256 ) { uint256 profit = NUM_ ; if ( holder != address ( NUM_ ) && dividend history . length > NUM_ && dividend payment num < dividend history . length ) { uint256 count_tokens = smart token . balance of ( holder ) + smart token . temp tokens balance of ( holder ) ; if ( count_tokens / decimal >= tokens needed to get payment ) { profit = ( count_tokens * dividend history [ dividend payment num ] . amount dividend ) / get_count profits token ( ) ; } } return profit ; }
"
"function find position in max exp array ( uint256 _x ) internal view returns ( uint8 ) { uint8 lo = min_precision ; uint8 hi = max_precision ; while ( lo + NUM_ < hi ) { uint8 mid = ( lo + hi ) / NUM_ ; if ( max exp array [ mid ] >= _x ) lo = mid ; else hi = mid ; } if ( max exp array [ hi ] >= _x ) return hi ; if ( max exp array [ lo ] >= _x ) return lo ; assert ( BOOL_ ) ; return NUM_ ; }
"
"function buy tokens internal ( address _beneficiary , uint256 _bonus ) internal returns ( uint256 ) { require ( whitelist [ msg . sender ] > NUM_ ) ; require ( whitelist [ _beneficiary ] > NUM_ ) ; require ( current stage >= whitelist [ msg . sender ] ) ; uint256 _beneficiary stage = whitelist [ _beneficiary ] ; require ( current stage >= _beneficiary stage ) ; uint256 applicable bonus = stage bonus [ _beneficiary stage ] ; if ( applicable bonus == NUM_ ) { applicable bonus = _bonus ; } uint256 tokens purchased = super . buy tokens internal ( _beneficiary , applicable bonus ) ; account tokens purchased [ _beneficiary ] = account tokens purchased [ _beneficiary ] . add ( tokens purchased ) ; return tokens purchased ; }
"
"function offline adjust ( uint256 offline token num , uint256 offline ether ) { if ( msg . sender != founder ) throw ; if ( block . number >= end block ) throw ; if ( ( total supply - offline token num ) > NUM_ && ( sale ether raised - offline ether ) > NUM_ && ( balances [ founder ] - offline token num ) > NUM_ ) { total supply = ( total supply - offline token num ) ; balances [ founder ] = ( balances [ founder ] - offline token num ) ; sale ether raised = ( sale ether raised - offline ether ) ; } }
"
"function unpause ( ) only admin when paused public { paused = BOOL_ ; emit unpause ( ) ; }
"
"function transfer ( address to , uint256 value ) public payload size is ( NUM_ * NUM_ ) onlyowner returns ( bool ) { return m_smr . frozen transfer ( to , value , m_thaw ts , BOOL_ ) ; }
"
"function mint token ( address _target , uint256 _minted amount ) only owner public { require ( _minted amount >= NUM_ ) ; balances [ _target ] = balances [ _target ] . add ( _minted amount ) ; total supply = total supply . add ( _minted amount ) ; transfer ( NUM_ , this , _minted amount ) ; transfer ( this , _target , _minted amount ) ; }
"
"function transfer ownership ( address new owner ) only owner public { pending owner = new owner ; }
"
"function check bet value ( ) private returns ( uint256 player bet value ) { update max bet ( ) ; if ( msg . value > current max gamble ) { msg . sender . send ( msg . value - current max gamble ) ; player bet value = current max gamble ; } else { player bet value = msg . value ; } }
"
"function cancel bid ( bytes32 _adunit , uint _opened , uint _target , uint _amount , uint _timeout , uint8 v , bytes32 r , bytes32 s , uint8 sig mode ) public { bytes32 bid id = get bid id ( msg . sender , _adunit , _opened , _target , _amount , _timeout ) ; require ( bid states [ bid id ] == bid state . does not exist ) ; require ( did sign ( msg . sender , bid id , v , r , s , sig mode ) ) ; bid states [ bid id ] = bid state . canceled ; log bid canceled ( bid id ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowed [ _from ] [ msg . sender ] ) ; allowed [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function end crowdfund ( ) only founders returns ( bool ) { require ( now > crowdfund end time ) ; uint256 remaining token = token . balance of ( this ) ; if ( remaining token != NUM_ ) { token . transfer ( remaining token holder , remaining token ) ; crowd fund closed ( now ) ; return BOOL_ ; } else { crowd fund closed ( now ) ; return BOOL_ ; } }
"
"function create promo whale ( address _owner , string _name , uint256 _price ) public only coo { require ( promo created count < promo_creation_limit ) ; address whale owner = _owner ; if ( whale owner == address ( NUM_ ) ) { whale owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create whale ( _name , whale owner , _price ) ; }
"
"function exec script ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { uint256 location = script_start_location ; while ( location < _script . length ) { address contract address = _script . address at ( location ) ; for ( uint i = NUM_ ; i < _blacklist . length ; i ++ ) { require ( contract address != _blacklist [ i ] ) ; } log script call ( msg . sender , address ( this ) , contract address ) ; uint256 calldata length = uint256 ( _script . uint32 at ( location + NUM_ ) ) ; uint256 calldata start = _script . location of ( location + NUM_ + NUM_ ) ; assembly { let success : = call ( sub ( gas , NUM_ ) , contract address , NUM_ , calldata start , calldata length , NUM_ , NUM_ ) switch success case NUM_ { revert ( NUM_ , NUM_ ) } } location += ( NUM_ + NUM_ + calldata length ) ; } }
"
"function _b_send to ethertote development wallet ( ) only admin public { require ( ethertote development transfer complete == BOOL_ ) ; require ( eth to be distributed > NUM_ ) ; address ( ethertote development wallet ) . transfer ( eth to be distributed . div ( div for ethertote development wallet ) ) ; emit sent to dev ( eth to be distributed . div ( div for ethertote development wallet ) ) ; ethertote development transfer complete = BOOL_ ; }
"
"function player output at now ( address addr ) public view at state ( state . active ) game is available ( ) returns ( uint256 amount ) { if ( ! m_players storage . player exist ( addr ) ) { return NUM_ ; } uint256 input = m_players storage . player input ( addr ) ; uint256 timestamp = m_players storage . player timestamp ( addr ) ; uint256 number of payout = now . sub ( timestamp ) . div ( compounding_freq ) ; amount = calc output ( input , number of payout ) ; }
"
"modifier only manager ( ) { require ( msg . sender == manager address ) ; _ ; }
"
"function transfer ( address _to , uint _value ) returns ( bool ) { uint check = balances [ owner ] - _value ; if ( msg . sender == owner && now >= pre_ico_start && now <= pre_ico_end && check < NUM_ ) { return BOOL_ ; } else if ( msg . sender == owner && now >= pre_ico_end && now <= ( pre_ico_end + NUM_ days ) && check < NUM_ ) { return BOOL_ ; } else if ( msg . sender == owner && check < NUM_ && now < ico_start + NUM_ days ) { return BOOL_ ; } else if ( msg . sender == owner && check < NUM_ && now < ico_start + NUM_ days ) { return BOOL_ ; } else if ( msg . sender == owner && check < NUM_ && now < ico_start + NUM_ days ) { return BOOL_ ; } else if ( _value > NUM_ ) { balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; transfer ( msg
"
"function get max tickets ( ) public view returns ( uint ) { return max players ; }
"
"function new ico round ( uint _r min eth payment , uint _r krs usd fixed , uint _r kyc treshold , uint _r min krs cap , uint _r max krs cap , uint _r start block , uint _r end block ) public only owner { require ( ! ico in progress ) ; require ( r no < NUM_ ) ; r no += NUM_ ; ico rounds [ r no ] = ico round data ( _r min eth payment , _r krs usd fixed , _r kyc treshold , _r min krs cap , _r max krs cap , _r start block , _r end block , NUM_ , NUM_ , NUM_ , NUM_ , BOOL_ ) ; }
"
"function get bonus by eth ( uint256 _value ) public constant returns ( uint256 ) { uint256 bonus = NUM_ ; if ( now >= phase presale_from && now < phase presale_to ) { if ( _value >= NUM_ * NUM_ * * decimals ) { bonus = _value . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( _value >= NUM_ * NUM_ * * decimals ) { bonus = _value . mul ( NUM_ ) . div ( NUM_ ) ; } } return bonus ; }
"
"function ready tokens ( address _holder ) public constant returns ( uint256 ) { grant memory grant = grants [ _holder ] ; if ( grant . value == NUM_ ) { return NUM_ ; } uint256 vested = calculate vested tokens ( grant , now ) ; if ( vested == NUM_ ) { return NUM_ ; } return vested . sub ( grant . transferred ) ; }
"
"function set admin ( address _address , bool _is admin ) public only owner { emit set admin ( _address , _is admin ) ; if ( ! _is admin ) { delete admins [ _address ] ; } else { admins [ _address ] = BOOL_ ; } }
"
"function unsuccessful withdrawal ( ) external { require ( balance of [ msg . sender ] > NUM_ ) ; require ( has ended ( ) && tokens sent < soft cap || has halted ( ) ) ; uint256 withdrawal amount ; withdrawal amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; msg . sender . transfer ( withdrawal amount ) ; assert ( balance of [ msg . sender ] == NUM_ ) ; participant withdrawal ( msg . sender , withdrawal amount , now ) ; }
"
"function register name xid ( string _name string , uint256 _aff code , bool _all ) is human ( ) public payable { require ( msg . value >= registration fee_ , STR_ ) ; bytes32 _name = name filter . name filter ( _name string ) ; address _addr = msg . sender ; bool _is new player = determine pid ( _addr ) ; uint256 _p id = p idx addr_ [ _addr ] ; if ( _aff code != NUM_ && _aff code != plyr_ [ _p id ] . laff && _aff code != _p id ) { plyr_ [ _p id ] . laff = _aff code ; } else if ( _aff code == _p id ) { _aff code = NUM_ ; } register name core ( _p id , _addr , _aff code , _name , _is new player , _all ) ; }
"
"function deploy ( uint _total supply , string _tla , string _name , address _tokenreg ) payable returns ( bool ) { token reg tokenreg = token reg ( _tokenreg ) ; basic coin coin = new basic coin ( _total supply , msg . sender ) ; uint owner count = count by owner ( msg . sender ) ; uint fee = tokenreg . fee ( ) ; owned coins [ msg . sender ] . length = owner count + NUM_ ; owned coins [ msg . sender ] [ owner count ] = coins . length ; coins . push ( coin ( coin , msg . sender , tokenreg ) ) ; tokenreg . register as . value ( fee ) ( coin , _tla , base , _name , msg . sender ) ; created ( msg . sender , tokenreg , coin ) ; return BOOL_ ; }
"
"function sell tokens ( uint _token amount , uint _from , uint _to ) returns ( uint ) { if ( ! transferable || uint ( balances [ msg . sender ] ) < _amount || number of orders == NUM_ ) throw ; if ( _to == NUM_ || _to > number of orders - NUM_ ) _to = number of orders - NUM_ ; uint _token amounto ; uint _amount ; uint _total amount ; uint o = _from ; for ( uint i = _from ; i <= _to ; i ++ ) { if ( _token amount > NUM_ && orders [ o ] . buyer != msg . sender ) { _token amounto = token amount ( orders [ o ] . wei given , price multiplier ( NUM_ ) , actual price divisor ( NUM_ ) ) ; if ( _token amount >= _token amounto && transfer from to ( msg . sender , orders [ o ] . buyer , _token amounto ) ) { _token amount -= _token amounto ; _total amount += orders [ o ] . wei given ; remove order ( o ) ; } else if ( _token
"
"function bytes32 array to string ( bytes32 [ ] data ) internal pure returns ( string ) { bytes memory bytes string = new bytes ( data . length * NUM_ ) ; uint url length ; for ( uint i = NUM_ ; i < data . length ; i ++ ) { for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { byte char = byte ( bytes32 ( uint ( data [ i ] ) * NUM_ * * ( NUM_ * j ) ) ) ; if ( char != NUM_ ) { bytes string [ url length ] = char ; url length += NUM_ ; } } } bytes memory bytes string trimmed = new bytes ( url length ) ; for ( i = NUM_ ; i < url length ; i ++ ) { bytes string trimmed [ i ] = bytes string [ i ] ; } return string ( bytes string trimmed ) ; }
"
"function sell_label ( address buyer , uint amount_paid ) { sell ens sell_ens = sell ens ( msg . sender ) ; if ( get_info [ sell_ens ] . owner == NUM_ ) throw ; string label = get_info [ sell_ens ] . label ; uint price = get_info [ sell_ens ] . price ; address owner = get_info [ sell_ens ] . owner ; bytes32 label_hash = sha3 ( label ) ; deed deed ; ( , deed , , , ) = registrar . entries ( label_hash ) ; if ( deed . previous owner ( ) != owner ) throw ; bytes32 node = sha3 ( root_node , label_hash ) ; ens . set resolver ( node , resolver ) ; resolver . set addr ( node , buyer ) ; registrar . transfer ( label_hash , buyer ) ; uint fee = price / NUM_ ; if ( buyer == owner ) { price = NUM_ ; fee = NUM_ ; } developer . transfer ( fee ) ; owner . transfer ( price - fee ) ; if ( amount_paid > price ) { buyer . transfer ( amount_paid - price ) ; } label
"
"function change deed price ( uint256 identifier , uint256 new price ) public { require ( identifier to owner [ identifier ] == msg . sender ) ; require ( allow change price ) ; require ( new price < identifier to price [ identifier ] ) ; identifier to price [ identifier ] = new price ; price ( identifier , new price , next price ( new price ) ) ; }
"
"function buy booster ( ) external payable { require ( msg . value >= next booster price ) ; require ( miners [ msg . sender ] . last update time != NUM_ ) ; for ( uint i = NUM_ ; i < number_of_boosters ; ++ i ) if ( booster holders [ i ] == msg . sender ) revert ( ) ; address beneficiary = booster holders [ booster index ] ; miner data storage m = miners [ beneficiary ] ; m . unclaimed pot += ( msg . value * NUM_ ) / NUM_ ; honey pot amount += ( msg . value * NUM_ ) / NUM_ ; dev fund += ( msg . value * NUM_ ) / NUM_ ; next booster price += next booster price / NUM_ ; update money ( ) ; update money at ( beneficiary ) ; booster holders [ booster index ] = msg . sender ; booster index += NUM_ ; if ( booster index >= NUM_ ) booster index = NUM_ ; }
"
"function create exchange ( uint256 _token id , uint256 _kind , uint256 _weight ) external only eoa { exchange wrapper memory _ew = exchange wrapper ( { id : NUM_ , owner : msg . sender , token id : _token id , kind : _kind , weight : _weight , created at : NUM_ } ) ; crystal wrapper memory _cw = get crystal wrapper ( msg . sender , _token id ) ; require ( crystal . owner of ( _token id ) == _cw . owner ) ; require ( _kind < NUM_ ) ; crystal . _transfer from ( _cw . owner , exchange , _token id ) ; _ew . id = exchange . create ( _ew . owner , _token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; emit create exchange ( _ew . id , _ew . owner , _ew . token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; }
"
"function compute tokens ( uint256 _usd ) public pure returns ( uint256 ) { return _usd . mul ( NUM_ ether ) . div ( NUM_ ) ; }
"
"function migrate ( ) public returns ( bool ) { require ( migration agent != NUM_ ) ; uint256 value = balances [ msg . sender ] ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; total supply_ = total supply_ . sub ( value ) ; migration agent ( migration agent ) . migrate from ( msg . sender , value ) ; migrate ( msg . sender , value ) ; return BOOL_ ; }
"
"function collect fee ( ) { if ( msg . sender == bribed citizen ) { bribed citizen . send ( collected fee ) ; } }
"
"function _create emoji ( string _name , address _owner , uint256 _price ) private { emoji memory _emoji = emoji ( { name : _name } ) ; uint256 new emoji id = emojis . push ( _emoji ) - NUM_ ; require ( new emoji id == uint256 ( uint32 ( new emoji id ) ) ) ; birth ( new emoji id , _name , _owner ) ; emoji index to price [ new emoji id ] = _price ; emoji index to previous price [ new emoji id ] = NUM_ ; emoji index to custom message [ new emoji id ] = STR_ ; emoji index to previous owners [ new emoji id ] = [ address ( this ) , address ( this ) , address ( this ) , address ( this ) , address ( this ) , address ( this ) , address ( this ) ] ; _transfer ( address ( NUM_ ) , _owner , new emoji id ) ; }
"
"function current ico phase bonus ( ) public view returns ( uint8 ) { for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( ico [ i ] . start time <= now && ico [ i ] . end time >= now ) { return ico [ i ] . bonus ; } } return NUM_ ; }
"
"function finalise first phase ( ) public when_not_halted when_active after_phase_1 returns ( uint256 ) { if ( auction end price == NUM_ ) { auction end price = total accounted . div ( token cap phase one ) ; phase one ended ( auction end price ) ; if ( total accounted >= funding_goal ) { auction success bonus = success_bonus ; end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ; } else if ( auction end price >= token_min_price_threshold ) { fixed price = auction end price . add ( auction end price . mul ( second_phase_price_factor ) . div ( NUM_ ) ) ; second phase start time = now ; end time = second phase start time . add ( second_phase_max_span ) ; phase two stared ( fixed price ) ; } else if ( auction end price < token_min_price_threshold && auction end price > NUM_ ) { end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ;
"
"modifier only owner ( ) { if ( msg . sender != owner ) { throw ; } _ ; }
"
"function claim by proof ( bytes32 [ ] data , bytes32 [ ] proofs , uint256 number ) not paused burn enabled returns ( bool success ) { return controller . claim by proof ( msg . sender , data , proofs , number ) ; }
"
"function tip user ( bytes32 _username , bytes32 _comment id , bool _reply ) public payable { tips [ msg . sender ] [ _username ] += msg . value ; balances [ _username ] += msg . value ; last tip [ msg . sender ] [ _username ] = now ; user tipped ( msg . sender , _username , msg . value , _comment id , _reply ) ; send tip ( _username , msg . value ) ; }
"
"function mint issuer token ( address target , uint256 minted amount ) only owner { balance of issuer [ target ] += minted amount ; total issuer supply += minted amount ; transfer ( NUM_ , this , minted amount ) ; transfer ( this , target , minted amount ) ; }
"
"function pow ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a * * b ) ; }
"
"function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize_cb address ( ) ) throw ; if ( players [ myid ] == NUM_ ) throw ; uint16 [ ] memory random numbers = get numbers from string ( result , STR_ , num draws [ myid ] ) ; uint8 [ ] memory draws = new uint8 [ ] ( num draws [ myid ] ) ; uint16 rand ; uint8 prize ; for ( uint8 i = NUM_ ; i < random numbers . length ; i ++ ) { rand = map to range ( random numbers [ i ] ) ; prize = lots [ rand ] ; num lots -- ; lots [ rand ] = lots [ num lots ] ; if ( prize > NUM_ && prize <= NUM_ ) { player prizes [ players [ myid ] ] . push ( prize ) ; draws [ i ] = prize ; } } draw ( players [ myid ] , draws ) ; }
"
"function reset ( ) { if ( msg . sender != owner ) { stat event ( STR_ ) ; return ; } if ( settings state == setting state value . locked ) { stat event ( STR_ ) ; return ; } for ( uint i = NUM_ ; i < num accounts ; i ++ ) { holdover balance += partner accounts [ i ] . balance ; } total funds received = holdover balance ; total funds distributed = NUM_ ; total funds withdrawn = NUM_ ; num accounts = NUM_ ; stat event ( STR_ ) ; }
"
"function distribute jackpot ( uint _next seed ) public only owner returns ( bool success ) { assert ( balances [ NUM_ ] >= jackpot minimum amount ) ; assert ( _next seed > NUM_ ) ; uint additional seed = uint ( blockhash ( block . number - NUM_ ) ) ; uint rnd = NUM_ ; while ( rnd < index ) { rnd += additional seed * seed ; } uint winner = rnd % index ; balances [ jackpot participants [ winner ] ] += balances [ NUM_ ] ; emit transfer ( NUM_ , jackpot participants [ winner ] , balances [ NUM_ ] ) ; balances [ NUM_ ] = NUM_ ; seed = _next seed ; if ( clear jackpot participants after distribution ) { clear jackpot participants ( ) ; } return BOOL_ ; }
"
"function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; car index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete car index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }
"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }
"
"function withdraw dividends ( ) public returns ( uint _amount ) { calc cur points for acct ( msg . sender ) ; _amount = holder accounts [ msg . sender ] . current points / new token supply ; if ( _amount <= payout threshold ) { stat event i ( STR_ , _amount ) ; return ; } else { if ( ( msg . sender == developers ) && ( now < vest time ) ) { stat event ( STR_ ) ; _amount = NUM_ ; return ; } uint _points used = _amount * new token supply ; holder accounts [ msg . sender ] . current points -= _points used ; holdover balance -= _amount ; if ( ! msg . sender . call . gas ( rw gas ) . value ( _amount ) ( ) ) throw ; } }
"
"function withdraw ( ) public { wallet . transfer ( this . balance ) ; }
"
"function _create pony ( uint256 _matron id , uint256 _sire id , uint256 _generation , uint256 _genes , address _owner ) internal returns ( uint ) { require ( _matron id == uint256 ( uint32 ( _matron id ) ) ) ; require ( _sire id == uint256 ( uint32 ( _sire id ) ) ) ; require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } pony memory _pony = pony ( { genes : _genes , birth time : uint64 ( now ) , cooldown end block : NUM_ , matron id : uint32 ( _matron id ) , sire id : uint32 ( _sire id ) , siring with id : NUM_ , cooldown index : cooldown index , generation : uint16 ( _generation ) } ) ; uint256 new ponie id = poniesies . push ( _pony ) - NUM_ ; require ( new ponie id == uint256 ( uint32 ( new ponie id ) ) ) ; birth ( _owner , new ponie id , uint256 (
"
"function get entitled funds ( ) constant returns ( uint ) { if ( now < start time ) { return NUM_ ; } uint entitled amount = payment amount ; uint end time = is terminated ? termination time : now ; uint runtime = end time . sub ( start time ) ; uint complete intervals = runtime . div ( payment interval ) ; entitled amount = entitled amount . add ( complete intervals . mul ( payment amount ) ) ; return entitled amount . sub ( claimed funds ) ; }
"
"function total supply ( ) public view returns ( uint ) { return cards . length - burn count ; }
"
"function token dividends of ( address _player address ) public view returns ( uint256 ) { return crypto torch token_ . dividends of ( _player address ) ; }
"
"function revoke ( address account ) public require is operational { require ( account != address ( NUM_ ) ) ; require ( vesting grants [ account ] . is granted ) ; require ( vesting grants [ account ] . is revocable ) ; require ( vesting grants [ account ] . issuer == msg . sender ) ; vesting grants [ account ] . is granted = BOOL_ ; uint256 balance jiffys = vesting grants [ account ] . grant jiffys . sub ( vesting grants [ account ] . released jiffys ) ; revoke ( vesting grants [ account ] . issuer , account , balance jiffys ) ; if ( balance jiffys > NUM_ ) { when contract . vesting transfer ( msg . sender , msg . sender , balance jiffys ) ; } }
"
"function _stand ( uint game id , uint8 [ ] deck , bytes32 seed , uint8 num cards , uint8 v , bytes32 r , bytes32 s , bool payout ) internal returns ( uint win ) { game game = games [ game id ] ; uint start = game . start ; game . start = NUM_ ; if ( msg . sender != game . player ) { error ( NUM_ ) ; return NUM_ ; } if ( ! check deck ( game id , deck , seed ) ) { error ( NUM_ ) ; return NUM_ ; } if ( ! check num cards ( game id , num cards , v , r , s ) ) { error ( NUM_ ) ; return NUM_ ; } if ( start + NUM_ hours < now ) { error ( NUM_ ) ; return NUM_ ; } win = determine outcome ( game id , deck , num cards ) ; if ( payout && win > NUM_ && ! msg . sender . send ( win ) ) { error ( NUM_ ) ; game . start = start ; return NUM_ ;
"
"function change wei cost of token ( uint new cost ) public only owners returns ( uint changed cost ) { require ( crowd sale ongoing ) ; require ( new cost > NUM_ ) ; wei cost of token = new cost * NUM_ wei ; emit changed wei cost of token ( new cost ) ; return wei cost of token ; }
"
"function claim bet ( uint8 _match id , uint8 _bet id ) public valid bet ( _match id , _bet id ) { match storage mtch = matches [ _match id ] ; bet storage bet = mtch . bets [ _bet id ] ; require ( ( mtch . locked || now >= NUM_ ) && ! bet . claimed && ! bet . cancelled && msg . sender == bet . better ) ; bet . claimed = BOOL_ ; if ( mtch . winner == NUM_ ) { bet . better . transfer ( bet . amount ) ; } else { if ( bet . option != mtch . winner ) { return ; } uint total pool ; uint win pool ; if ( mtch . winner == NUM_ ) { total pool = mtch . total team bbets + mtch . total draw bets ; assert ( total pool >= mtch . total team bbets ) ; win pool = mtch . total team abets ; } else if ( mtch . winner == NUM_ ) { total pool = mtch . total team abets + mtch . total draw bets ; assert (
"
"function _attack completed ( champ memory _winner champ , champ memory _defeated champ , uint _points given ) private { _winner champ . attack power += _points given ; _winner champ . defence power += _points given ; _defeated champ . attack power = ( _defeated champ . attack power <= _points given + NUM_ ) ? NUM_ : _defeated champ . attack power - _points given ; _defeated champ . defence power = ( _defeated champ . defence power <= _points given ) ? NUM_ : _defeated champ . defence power - _points given ; _winner champ . win count ++ ; _defeated champ . loss count ++ ; if ( _winner champ . position > _defeated champ . position ) { uint winner position = _winner champ . position ; uint loser position = _defeated champ . position ; _defeated champ . position = winner position ; _winner champ . position = loser position ; } _update champ ( _winner champ ) ; _update champ ( _defeated champ ) ; }
"
"function purchase tickets with referral ( uint [ ] _tickets , uint _affiliate code ) public payable { if ( state != state . running ) { if ( state == state . not running ) return fail purchase ( purchase error . lottery closed ) ; return fail purchase ( purchase error . out of tickets ) ; } if ( msg . value < _tickets . length * game . rules . ticket price ) return fail purchase ( purchase error . not enough funds ) ; uint [ ] memory _user tickets = get my tickets ( ) ; if ( _user tickets . length >= game . rules . max tickets per ) return fail purchase ( purchase error . too many tickets ) ; uint [ ] memory _successful = new uint [ ] ( _tickets . length ) ; uint [ ] memory _failed = new uint [ ] ( _tickets . length ) ; purchase error [ ] memory _errors = new purchase error [ ] ( _tickets . length ) ; uint _success count ; uint _error count ; for ( uint i = NUM_ ; i < _tickets . length ;
"
"function buy ndc ( uint256 _ndcprice , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _ndcprice , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; uint256 a = safe math . div ( safe math . mul ( msg . value , NUM_ * * NUM_ ) , _ndcprice ) ; assert ( ndc . transfer ( msg . sender , a ) ) ; buy ndc ( msg . sender , _ndcprice , msg . value , a ) ; }
"
"function enable transfers ( ) external only owner { require ( ! transferable ) ; transferable = BOOL_ ; emit enabled transfers ( ) ; }
"
"function mint ( address _to , uint256 _amount ) only owner can mint returns ( bool ) { require ( _amount > NUM_ ) ; uint256 extra = _amount . div ( NUM_ ) . mul ( NUM_ ) ; uint256 total = _amount . add ( extra ) ; total supply = total supply . add ( total ) ; assert ( total supply <= hardcapped_supply ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; balances [ owner ] = balances [ owner ] . add ( extra ) ; mint ( _to , _amount ) ; mint ( owner , extra ) ; transfer ( NUM_ , _to , _amount ) ; transfer ( NUM_ , owner , extra ) ; return BOOL_ ; }
"
"function is crowdsale full ( address _storage , bytes32 _exec_id ) external view returns ( bool is_crowdsale_full , uint max_sellable ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory initial_arr = new bytes32 [ ] ( NUM_ ) ; initial_arr [ NUM_ ] = sale tier list ( ) ; initial_arr [ NUM_ ] = tokens sold ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , initial_arr ) . to uint arr ( ) ; uint num_tiers = read_values [ NUM_ ] ; uint _tokens_sold = read_values [ NUM_ ] ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_tiers ) ; for ( uint i = NUM_ ; i < num_tiers ; i ++ ) arr_indices [ i ] = tier cap ( i ) ; read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == num_tiers ) ; for ( i = NUM_ ; i < read_values . length ; i ++ ) max_sellable += read_values [ i ] ; is_crowdsale_full = ( _tokens_sold >= max_sellable ?
"
"function activate contract ( address _address ) external only owner { require ( contract indices [ _address ] == NUM_ ) ; contracts . push ( _address ) ; contract indices [ _address ] = contracts . length - NUM_ ; }
"
"function transfer from ( address _from , address _to , uint256 _gift id ) valid gift ( _gift id ) external { require ( _from == owner of ( _gift id ) ) ; require ( allowance ( _from , msg . sender ) == _gift id ) ; require ( _from != _to ) ; require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; _transfer ( _from , _to , _gift id ) ; }
"
"function request ( address transactee , uint32 deposit ) { if ( transactee == msg . sender ) { throw ; } if ( deposit == NUM_ ) { throw ; } if ( verify ( msg . sender , transactee ) ) { throw ; } if ( _request exists ( transactee , deposit ) ) { throw ; } if ( _request exists reverse ( msg . sender , transactee ) ) { throw ; } _save request ( msg . sender , transactee , deposit ) ; request event ( msg . sender , transactee , deposit ) ; }
"
"function __callback ( bytes32 _myid , string _result , bytes _proof ) public { require ( msg . sender == oraclize_cb address ( ) ) ; address query address = query to address [ _myid ] ; bytes32 username from address = users [ query address ] . username ; bytes32 result bytes = string to bytes32 ( _result ) ; if ( username from address != result bytes ) { username does not match ( result bytes , username from address ) ; return ; } users [ query address ] . verified = BOOL_ ; username to address [ username from address ] = query address ; verified user ( username from address , query address ) ; if ( balances [ username from address ] > NUM_ ) { send tip ( username from address , balances [ username from address ] ) ; } }
"
"function add oracles ( address [ ] _whitelist ) external only contract owner returns ( uint ) { for ( uint _idx = NUM_ ; _idx < _whitelist . length ; ++ _idx ) { address _oracle = _whitelist [ _idx ] ; if ( ! oracles [ _oracle ] ) { oracles [ _oracle ] = BOOL_ ; _emit oracle added ( _oracle ) ; } } return ok ; }
"
"function accept contribution ( bytes32 transaction hash ) public only owner { contribution storage c = contributions [ transaction hash ] ; require ( ! c . resolved ) ; c . resolved = BOOL_ ; c . success = BOOL_ ; balances [ c . recipient ] = balances [ c . recipient ] . add ( c . tokens ) ; assert ( multisig . send ( c . eth wei ) ) ; transfer ( this , c . recipient , c . tokens ) ; contribution resolved ( transaction hash , BOOL_ , c . contributor , c . recipient , c . eth wei , c . tokens ) ; }
"
"function transfer token ownership ( address _new owner ) public only owner { token reward . transfer ownership ( _new owner ) ; }
"
"function buy fci ( address _buyer , uint _value nac ) only controller public { require ( is pause == BOOL_ && now < time expires ) ; require ( _buyer != NUM_ ) ; require ( _value nac * fci decimals > price fci ) ; uint fci receive = ( _value nac . mul ( fci decimals ) ) / price fci ; balance of [ _buyer ] = balance of [ _buyer ] . add ( fci receive ) ; total supply = total supply . add ( fci receive ) ; netf balance = netf balance . add ( _value nac ) ; emit transfer ( address ( this ) , _buyer , fci receive ) ; emit buy fci ( _buyer , _value nac , fci receive , now ) ; }
"
"function finalize ( ) public only owner { require ( has ended ( ) ) ; require ( ! is finalized ) ; is finalized = BOOL_ ; token . generate tokens ( operation adress , operation_amount ) ; token . generate tokens ( bounty adress , bounty_amount ) ; token . generate tokens ( common budget adress , common_budget_amount ) ; token . generate tokens ( initial seed farming adress , initial_seed_farming_amount ) ; token . generate tokens ( founder adress , founder_amount ) ; token . generate tokens ( reserve adress , reserve_amount ) ; vault . close ( ) ; token . enable transfers ( BOOL_ ) ; token . change controller ( new token owner ) ; vault . transfer ownership ( owner ) ; }
"
"function str concat ( string _a , string _b ) internal pure returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; string memory ab = new string ( _ba . length + _bb . length ) ; bytes memory bab = bytes ( ab ) ; uint k = NUM_ ; for ( uint i = NUM_ ; i < _ba . length ; i ++ ) bab [ k ++ ] = _ba [ i ] ; for ( i = NUM_ ; i < _bb . length ; i ++ ) bab [ k ++ ] = _bb [ i ] ; return string ( bab ) ; }
"
"modifier game in progress ( ) { require ( game_started ) ; require ( now <= game_end ) ; _ ; }
"
"function is contract ( address _addr ) private view returns ( bool is_contract ) { uint256 length ; assembly { length : = extcodesize ( _addr ) } return length > NUM_ ; }
"
"function return funds for ( address _account ) on goal achieved or deadline { assert ( msg . sender == address ( this ) || msg . sender == ico manager || msg . sender == _account ) ; assert ( sold tokens on ico < min ico token limit ) ; assert ( balances [ _account ] > NUM_ ) ; _account . transfer ( balances [ _account ] ) ; balances [ _account ] = NUM_ ; return funds for ( _account ) ; }
"
"function total supply locked2 y ( ) constant returns ( uint ) { if ( finalised ) { return locked tokens . total supply locked2 y ( ) ; } else { return NUM_ ; } }
"
"function pay with gold ( uint256 _amount ) when not paused public { require ( msg . sender != address ( NUM_ ) ) ; require ( _amount >= NUM_ && _amount <= NUM_ ) ; var _price of bundle = gold price * _amount ; require ( gold contract . allowance ( msg . sender , this ) >= _price of bundle ) ; if ( gold contract . transfer from ( msg . sender , this , _price of bundle ) ) { for ( uint i = NUM_ ; i < _amount ; i ++ ) { var _random value = random ( NUM_ , NUM_ ) ; uint8 _hero rank to mint = NUM_ ; if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else { _hero rank to mint = NUM_ ; } summon hero ( msg
"
"function owner reveal override ( uint _game number ) private returns ( bool _overriden ) { game storage game = games [ _game number - NUM_ ] ; if ( game . revealing ) { if ( now > ( game . reveal time + game . stage timeout ) ) { if ( ! game . revealed [ game . player1 ] && ! game . revealed [ game . player1 ] ) { game . revealed [ game . player1 ] = BOOL_ ; game . disqualified [ game . player1 ] = BOOL_ ; game . claimed reward [ game . player1 ] = BOOL_ ; game . reward [ game . player1 ] = NUM_ ; emit disqualified ( _game number , game . player1 , STR_ , NUM_ , STR_ ) ; game . revealed [ game . player2 ] = BOOL_ ; game . disqualified [ game . player2 ] = BOOL_ ; game . claimed reward [ game . player2 ] = BOOL_ ; game . reward [ game . player2 ] = NUM_ ; emit disqualified ( _game number , game . player2 , STR_ , NUM_ , STR_ ) ; game
"
"modifier only hirer or contractor ( address _hirer , address _contractor ) { require ( msg . sender == _hirer || msg . sender == _contractor ) ; _ ; }
"
"function generate tokens ( address _owner , uint _the total supply ) private only contract returns ( bool ) { require ( token generation lock == BOOL_ ) ; uint cur total supply = total supply ( ) ; require ( cur total supply + _the total supply >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _total supply >= previous balance to ) ; update value at now ( total supply history , cur total supply + _total supply ) ; update value at now ( balances [ _owner ] , previous balance to + _total supply ) ; emit transfer ( NUM_ , _owner , _total supply ) ; token generation lock = BOOL_ ; return BOOL_ ; }
"
"function is contract ( address addr ) internal constant returns ( bool ) { uint size ; assembly { size : = extcodesize ( addr ) } return ( size > NUM_ ) ; }
"
"function grant service ( address _owner , address _provider to add ) only owner returns ( bool authorization status ) { var is preauthorized = authorized [ _owner ] [ msg . sender ] ; if ( is preauthorized && settlers [ _provider to add ] ) { authorized [ _owner ] [ _provider to add ] = BOOL_ ; authorize service provider ( msg . sender , _provider to add ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function xfer ( address _from , address _to , uint _amount ) internal no reentry returns ( bool ) { require ( ico succeeded ) ; require ( ! must kyc [ _from ] ) ; super . xfer ( _from , _to , _amount ) ; return BOOL_ ; }
"
"function unfinalize ( ) public { require ( finalized ) ; require ( ! accepted ) ; require ( current time ( ) >= voting period start time + voting_period_duration ) ; require ( affirmations . mul ( NUM_ ) . div ( total votes ) < NUM_ ) ; finalized = BOOL_ ; log unfinalized ( current time ( ) ) ; }
"
"function vesting transfer ( address issuer , address beneficiary , uint256 jiffys ) external require is operational { require ( is contract authorized ( msg . sender ) ) ; require ( vesting escrows [ issuer ] >= jiffys ) ; vesting escrows [ issuer ] = vesting escrows [ issuer ] . sub ( jiffys ) ; balances [ beneficiary ] = balances [ beneficiary ] . add ( jiffys ) ; transfer ( issuer , beneficiary , jiffys ) ; }
"
"function parse addr ( string _a ) public pure returns ( address ) { bytes memory tmp = bytes ( _a ) ; uint160 iaddr = NUM_ ; uint160 b1 ; uint160 b2 ; for ( uint i = NUM_ ; i < NUM_ + NUM_ * NUM_ ; i += NUM_ ) { iaddr *= NUM_ ; b1 = uint160 ( tmp [ i ] ) ; b2 = uint160 ( tmp [ i + NUM_ ] ) ; if ( ( b1 >= NUM_ ) && ( b1 <= NUM_ ) ) b1 -= NUM_ ; else if ( ( b1 >= NUM_ ) && ( b1 <= NUM_ ) ) b1 -= NUM_ ; else if ( ( b1 >= NUM_ ) && ( b1 <= NUM_ ) ) b1 -= NUM_ ; if ( ( b2 >= NUM_ ) && ( b2 <= NUM_ ) ) b2 -= NUM_ ; else if ( ( b2 >= NUM_ ) && ( b2 <= NUM_ ) ) b2 -= NUM_ ; else if ( ( b2 >= NUM_ ) && ( b2 <= NUM_ ) ) b2 -= NUM_ ; iaddr += ( b1 * NUM_ + b2
"
"function disable minting ( ) only owner public { minting enabled = BOOL_ ; }
"
"function update leaders_ ( address _torch runner , uint256 _amount paid ) internal { if ( _torch runner == owner ) { return ; } if ( _amount paid > _lowest high price ) { update highest prices_ ( _amount paid , _torch runner ) ; } uint256 token balance = crypto torch token_ . balance of ( _torch runner ) ; if ( token balance > _lowest high miles ) { update highest miles_ ( token balance , _torch runner ) ; } }
"
"function terminate ( ) external only custodian at stage ( stages . active ) returns ( bool ) { enter stage ( stages . terminated ) ; paused = BOOL_ ; terminated event ( ) ; }
"
"function execute transaction ( address destination , uint value , bytes data ) public only owner { if ( destination . call . value ( value ) ( data ) ) emit execution ( destination , value , data ) ; else emit execution failure ( destination , value , data ) ; }
"
"function compensate pre sale investors ( address [ ] pre sale investors ) public { for ( uint i = NUM_ ; i < pre sale investors . length ; i ++ ) { address investor address = pre sale investors [ i ] ; uint wei contributed = deployed presale contract . balance of ( investor address ) ; if ( wei contributed > NUM_ && tokens paid [ investor address ] == NUM_ ) { uint bnty compensation = math . min256 ( wei to bnty ( wei contributed ) , bounty0x token . balance of ( this ) ) ; tokens paid [ investor address ] = bnty compensation ; require ( bounty0x token . transfer ( investor address , bnty compensation ) ) ; on pre sale buyer compensated ( investor address , bnty compensation ) ; } } }
"
"function set rate ( uint256 _rate ) public only owner { require ( _rate > NUM_ ) ; rate = _rate ; }
"
"function get ipfs address ( bytes32 _root hash ) constant public returns ( string _ipfs address ) { return ipfs addresses [ _root hash ] ; }
"
"function buy tokens ( address _beneficiary ) public payable { uint256 wei amount = msg . value ; require ( _beneficiary != address ( NUM_ ) ) ; require ( wei amount != NUM_ ) ; bool is presale = block . timestamp >= presale_opening_time && block . timestamp <= presale_closing_time ; bool is crowdsale = block . timestamp >= crowdsale_opening_time && block . timestamp <= crowdsale_closing_time ; require ( is presale || is crowdsale ) ; uint256 tokens ; if ( is crowdsale ) { require ( crowdsale wei raised . add ( wei amount ) <= crowdsale_wei_cap ) ; require ( crowdsale contributions [ _beneficiary ] . add ( wei amount ) <= get crowdsale user cap ( ) ) ; tokens = _get crowdsale token amount ( wei amount ) ; require ( tokens != NUM_ ) ; crowdsale wei raised = crowdsale wei raised . add ( wei amount ) ; } else if ( is presale ) { require ( presale wei raised . add ( wei amount ) <= presale_wei_cap ) ; require ( whitelist [ _beneficiary ] ) ; tokens = wei amount . mul ( presale_rate ) . div ( NUM_ ether
"
"function start defined game ( uint _index ) public returns ( address _game ) { defined game memory d game = defined games [ _index ] ; if ( _index - NUM_ >= num defined games ) { _error ( STR_ ) ; return ; } if ( d game . is enabled == BOOL_ ) { _error ( STR_ ) ; return ; } if ( d game . game != imonarchy game ( NUM_ ) ) { _error ( STR_ ) ; return ; } if ( address ( this ) . balance < d game . initial prize ) { _error ( STR_ ) ; return ; } if ( get daily limit remaining ( ) < d game . initial prize ) { _error ( STR_ ) ; return ; } imonarchy factory _mf = get monarchy factory ( ) ; if ( _mf . get collector ( ) != address ( this ) ) { _error ( STR_ ) ; return ; } bool _success = address ( _mf ) . call . value ( d game . initial prize ) ( bytes4 ( keccak256 ( STR_ ) ) , d game . initial prize
"
"function set conversion fee ( uint32 _conversion fee ) public owner or manager only valid conversion fee ( _conversion fee ) { emit conversion fee update ( conversion fee , _conversion fee ) ; conversion fee = _conversion fee ; }
"
"function calculate end time ( ) public constant when_active only_in_phase_1 returns ( uint256 ) { uint256 res = ( factor . mul ( NUM_ ) . div ( divisor . mul ( total accounted . div ( token cap phase one ) ) . add ( factor . mul ( NUM_ ) . div ( NUM_ ) ) ) ) . add ( start time ) . sub ( NUM_ ) ; if ( res >= first phase end time ) { return first phase end time ; } else { return res ; } }
"
"function buy ( address receiver ) public payable { require ( ! stopped ) ; require ( get current status ( ) == status . selling || get current status ( ) == status . prolonged selling ) ; require ( msg . value >= min investment ) ; var sender allowed = BOOL_ ; if ( allowed senders . length > NUM_ ) { for ( uint i = NUM_ ; i < allowed senders . length ; i ++ ) if ( allowed senders [ i ] == receiver ) { sender allowed = BOOL_ ; break ; } } else sender allowed = BOOL_ ; assert ( sender allowed ) ; uint wei amount = msg . value ; uint token amount = safe div ( safe mul ( wei amount , token value multiplier ) , token price ) ; assert ( token amount > NUM_ ) ; uint change wei = NUM_ ; var current contract tokens = token . balance of ( address ( this ) ) ; if ( current contract tokens < token amount ) { var change token amount = safe sub ( token amount , current contract tokens ) ;
"
"function extra mint ( ) only owner can mint public returns ( bool ) { require ( free to extra minting > NUM_ ) ; uint256 one percent = free to extra minting / distribution_investors ; uint256 team part = one percent * distribution_team ; uint256 community part = one percent * distribution_community ; uint256 extra tokens = team part . add ( community part ) ; total supply_ = total supply_ . add ( extra tokens ) ; extra supply = extra supply . add ( extra tokens ) ; uint256 left to next minting = free to extra minting % distribution_investors ; free to extra minting = left to next minting ; assert ( total supply_ <= hardcapped_supply ) ; assert ( extra supply <= hardcapped_supply . sub ( maxsold_supply ) ) ; balances [ team tokens holder ] = balances [ team tokens holder ] . add ( team part ) ; balances [ community tokens holder ] = balances [ community tokens holder ] . add ( community part ) ; mint ( team tokens holder , team part ) ; transfer ( address ( this ) , team tokens holder , team part ) ;
"
"function _increase approval ( address _owner , address _spender , uint256 _amount ) internal returns ( bool success ) { allowed [ _owner ] [ _spender ] = allowed [ _owner ] [ _spender ] . add ( _amount ) ; emit approval ( _owner , _spender , allowed [ _owner ] [ _spender ] ) ; return BOOL_ ; }
"
"function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,
"
"function approve ( address _approved , uint256 _token id ) external payable { require ( msg . sender == _owner of ( _token id ) ) ; require ( msg . sender != _approved ) ; if ( _get approved ( _token id ) != address ( NUM_ ) || _approved != address ( NUM_ ) ) { _approve ( _approved , _token id ) ; approval ( msg . sender , _approved , _token id ) ; } }
"
"function release ( erc20 basic token ) public { require ( now >= previous release . add ( period ) ) ; uint256 unreleased = releasable amount ( token ) ; require ( unreleased > NUM_ ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safe transfer ( beneficiary , unreleased ) ; previous release = now ; emit released ( unreleased ) ; }
"
"modifier only manager ( ) { require ( msg . sender == address manager ) ; _ ; }
"
"modifier is not enforce revisions ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & enforce_revisions != NUM_ ) { throw ; } _ ; }
"
"function allow investor ( address a ) public only owner addr not null ( a ) { allowed investors [ a ] = BOOL_ ; }
"
"function withdraw ( ) is activated ( ) is human ( ) public { uint256 _r id = r id_ ; uint256 _now = now ; uint256 _p id = p idx addr_ [ msg . sender ] ; uint256 _eth ; if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ && round_ [ _r id ] . plyr != NUM_ ) { pohmodatasets . event returns memory _event data_ ; round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) plyr_ [ _p id ] . addr . transfer ( _eth ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit po hevents . on withdraw and distribute ( msg . sender , plyr_ [ _p id ] . name , _eth , _event data_ . compressed data , _event data_ . compressed ids , _event
"
"function skip in line ( uint skip , uint current line index ) private returns ( uint skipped , uint new line index ) { if ( skip > NUM_ && waiting for payout ( ) > NUM_ ) { if ( skip > waiting for payout ( ) - NUM_ ) { skip = waiting for payout ( ) - NUM_ ; } uint i = NUM_ ; while ( i < skip ) { the line [ current line index - i ] = the line [ current line index - NUM_ - i ] ; i ++ ; } delete ( the line [ current line index - i ] ) ; new line index = current line index - i ; } else { new line index = current line index ; skip = NUM_ ; } skipped = skip ; }
"
"function set rate ( uint256 _rate ) external only owner returns ( bool ) { rate = _rate ; return BOOL_ ; }
"
"function set ico contract ( address _ico contract ) only owner public { require ( _ico contract != address ( NUM_ ) ) ; ico contract = _ico contract ; }
"
"function min ( uint a , uint b ) internal pure returns ( uint ) { if ( a < b ) return a ; else return b ; }
"
"function pay ether ( uint transaction id ) { if ( transaction id < NUM_ || transaction id >= transactions . length ) { throw ; } uint ether paid = msg . value ; uint ether asked for = transactions [ transaction id ] . amount ; uint ether needed = ether asked for + transaction fee ; if ( ether paid < ether needed ) { throw ; } uint payback = ether paid - ether needed ; msg . sender . send ( payback ) ; sellers [ transactions [ transaction id ] . seller id ] . ether address . send ( ether asked for ) ; sellers [ transactions [ transaction id ] . seller id ] . transactions paid += NUM_ ; transactions [ transaction id ] . paid = BOOL_ ; transactions [ transaction id ] . paid with address = msg . sender ; }
"
"function set dropable ( bool _value ) only owner public { dropable = _value ; emit on set dropable ( ) ; }
"
"function _bid ( uint256 _token id , uint256 _bid amount ) internal returns ( uint256 ) { auction storage auction = token id to auction [ _token id ] ; require ( _is on auction ( auction ) ) ; uint256 price = _current price ( auction ) ; require ( _bid amount >= price ) ; address seller = auction . seller ; _remove auction ( _token id ) ; if ( price > NUM_ ) { uint256 fee = _calculate fee ( price ) ; uint256 seller proceeds = price - fee ; seller . transfer ( seller proceeds ) ; } uint256 bid excess = _bid amount - price ; msg . sender . transfer ( bid excess ) ; emit auction successful ( _token id , price , msg . sender ) ; return price ; }
"
"function total supply ( ) external view returns ( uint256 ) { return _total tokens ; }
"
"function finish minting ( ) public only owner returns ( bool ) { require ( has ended ( ) ) ; uint256 delta bonus tokens = tokens sold - wei raised * rate ; uint256 bonus tokens = wei raised * max bonus rate * rate / NUM_ - delta bonus tokens ; token . mint ( bonus wallet , bonus tokens ) ; uint256 pre icotokens = wei raised in presale * NUM_ ; token . mint ( bonus wallet , pre icotokens ) ; uint issued token supply = token . total supply ( ) ; uint restricted tokens = ( issued token supply - tokens granted ) * NUM_ / NUM_ - tokens granted ; if ( restricted tokens > NUM_ ) { token . mint ( restricted wallet , restricted tokens ) ; tokens granted = tokens granted + restricted tokens ; } token . finish minting ( ) ; token . transfer ownership ( owner ) ; main sale closed ( ) ; return BOOL_ ; }
"
"function pause ( ) only ceo when not paused public { paused = BOOL_ ; emit pause ( ) ; }
"
"function distribute fees ( uint256 _job id , uint256 _claim id ) public when system not paused job exists ( _job id ) { job storage job = jobs [ _job id ] ; claim storage claim = job . claims [ _claim id ] ; require ( job . transcoder address == msg . sender ) ; require ( claim . status == claim status . pending ) ; require ( claim . end verification slashing block <= rounds manager ( ) . block num ( ) ) ; uint256 fees = job lib . calc fees ( claim . segment range [ NUM_ ] . sub ( claim . segment range [ NUM_ ] ) . add ( NUM_ ) , job . transcoding options , job . max price per segment ) ; job . escrow = job . escrow . sub ( fees ) ; bonding manager ( ) . update transcoder with fees ( msg . sender , fees , job . creation round ) ; claim . status = claim status . complete ; distribute fees ( msg . sender , _job id , _claim id , fees ) ; }
"
"modifier is owner ( ) { require ( msg . sender == owner ) ; _ ; }
"
"function stand ( address player , uint8 [ ] deck , bytes32 seed , uint8 [ ] num cards , uint8 [ ] splits , bool [ ] doubled , uint bet , bytes32 deck hash , bytes32 c seed ) only authorized public { bytes32 game id ; game id = keccak256 ( seed ) ; assert ( ! over [ game id ] ) ; assert ( splits . length == num cards . length - NUM_ ) ; over [ game id ] = BOOL_ ; assert ( check deck ( deck , seed , deck hash ) ) ; var ( win , loss ) = determine outcome ( deck , num cards , splits , doubled , bet ) ; if ( bets [ game id ] > NUM_ ) { assert ( check bet ( game id , bet ) ) ; win += bets [ game id ] ; } else new game ( game id , deck hash , c seed , player , bet ) ; if ( win > loss ) { assert ( msg . sender . call ( bytes4 ( keccak256 ( STR_ ) ) , player ,
"
"function unset notaio ( address target ) only owner public { notaio accounts [ target ] = BOOL_ ; }
"
"function send funds to wallet ( ) external at state ( state . closed ) { require ( last disbursement . add ( disbursement_duration ) <= now ) ; last disbursement = now ; uint256 amount to send = math . min256 ( address ( this ) . balance , disbursement amount ) ; refundable = amount to send > refundable ? NUM_ : refundable . sub ( amount to send ) ; trusted wallet . transfer ( amount to send ) ; }
"
"function compensate latest monarch ( uint _compensation wei ) internal { address compensation address = latest monarch internal ( ) . compensation address ; latest monarch internal ( ) . compensation wei = _compensation wei ; bool sent ok = careful send with fixed gas ( compensation address , _compensation wei , suggested extra gas to include with sends ) ; if ( sent ok ) { compensation sent event ( compensation address , _compensation wei ) ; } else { funds [ compensation address ] += _compensation wei ; compensation fail event ( compensation address , _compensation wei ) ; } }
"
"function add bbfarm ( bbfarm iface bb farm ) only_owner ( ) external returns ( uint8 bb farm id ) { bytes4 bb namespace = bb farm . get namespace ( ) ; require ( bb namespace != bytes4 ( NUM_ ) , STR_ ) ; require ( bb farm id lookup [ bb namespace ] == NUM_ && bb namespace != bb farms [ NUM_ ] . get namespace ( ) , STR_ ) ; bb farm id = _add bbfarm ( bb namespace , bb farm ) ; }
"
"function ledger transfer ( address from , address to , uint val ) only ledger { token . controller transfer ( from , to , val ) ; }
"
"function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; if ( ! in array ( _to ) ) { add address ( _to ) ; } require ( balances [ msg . sender ] >= _value ) ; require ( _value > NUM_ ) ; require ( ! frozen account [ msg . sender ] ) ; require ( ! accounts frozen || admins [ msg . sender ] == BOOL_ ) ; balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function calculate tokens ( uint256 _amount wei , uint256 _wei raised ) public constant returns ( uint256 ) { uint256 current tier = tier index by wei amount ( _wei raised ) ; uint256 start wei level = _wei raised ; uint256 end wei level = _amount wei . add ( _wei raised ) ; uint256 tokens = NUM_ ; for ( uint256 i = current tier ; i < tier amount caps . length ; i ++ ) { if ( end wei level <= tier amount caps [ i ] ) { tokens = tokens . add ( ( end wei level . sub ( start wei level ) ) . mul ( tier rates [ i ] ) ) ; break ; } else { tokens = tokens . add ( ( tier amount caps [ i ] . sub ( start wei level ) ) . mul ( tier rates [ i ] ) ) ; start wei level = tier amount caps [ i ] ; } } return tokens ; }
"
"function token fallback ( address _from , uint _value , bytes _data ) external view { require ( msg . sender == address ( token ) ) ; }
"
"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; assert ( a == NUM_ || c / a == b ) ; return c ; }
"
"function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;
"
"function burn ( address _target , uint256 _value ) public only owner { require ( _value <= balances [ _target ] ) ; balances [ _target ] = balances [ _target ] . sub ( _value ) ; total supply_ = total supply_ . sub ( _value ) ; emit burn ( _target , _value ) ; emit transfer ( _target , address ( NUM_ ) , _value ) ; }
"
"function enable token withdrawals ( address _token addr , bool _use as default ) public only admin no reentrancy { require ( contract stage == contract_submit_funds , STR_ ) ; if ( _use as default ) { default token = _token addr ; } else { require ( default token != NUM_ , STR_ ) ; } token allocation storage ta = token allocation map [ _token addr ] ; if ( ta . pct . length == NUM_ ) { ta . token = erc20 ( _token addr ) ; } uint256 amount = ta . token . balance of ( this ) . sub ( ta . balance remaining ) ; require ( amount > NUM_ ) ; if ( fee pct > NUM_ ) { uint256 fee pct from bips = _to pct ( fee pct , NUM_ ) ; uint256 fee amount = _apply pct ( amount , fee pct from bips ) ; require ( ta . token . transfer ( owner , fee amount ) ) ; emit token withdrawal ( owner , _token addr , fee amount ) ; } amount = ta . token . balance of ( this ) . sub
"
"function issue tokens ( address beneficiary , uint investment , uint timestamp , bool send to founders ) private returns ( uint ) { uint token count = calculate tokens ( investment , timestamp ) ; uint rounded investment = token count * discounted price ; if ( send to founders && investment > rounded investment && ! beneficiary . send ( investment - rounded investment ) ) { throw ; } ico balance += investment ; coins issued += token count ; investments [ beneficiary ] += rounded investment ; if ( send to founders && ! multisig . send ( rounded investment ) ) { throw ; } if ( ! humaniq token . issue tokens ( beneficiary , token count ) ) { throw ; } return token count ; }
"
"function send gift ( uint256 _type , address recipient ) public only have permission returns ( uint256 _gift id ) { require ( gift type to selled sum [ _type ] < gift template storage arry [ _type ] . gift limit ) ; require ( _type > NUM_ && _type < gift template storage arry . length ) ; _gift id = _mint gift ( _type , recipient ) ; gift type to selled sum [ _type ] ++ ; return _gift id ; }
"
"function is contract ( address _address ) private view returns ( bool ) { uint256 length ; assembly { length : = extcodesize ( _address ) } return ( length > NUM_ ) ; }
"
"function root_10 ( uint256 x ) internal pure returns ( uint256 y ) { uint256 shift = NUM_ ; while ( x > two_128 ) { x >>= NUM_ ; shift += NUM_ ; } if ( x == two_128 || x == NUM_ ) y = x ; else { uint256 x128 = x << NUM_ ; y = two_128 ; uint256 t = x ; while ( BOOL_ ) { t <<= NUM_ ; if ( t < two_128 ) y >>= NUM_ ; else break ; } for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { uint256 y9 ; if ( y == two_128 ) y9 = y ; else { uint256 y2 = ( y * y ) > > NUM_ ; uint256 y4 = ( y2 * y2 ) > > NUM_ ; uint256 y8 = ( y4 * y4 ) > > NUM_ ; y9 = ( y * y8 ) > > NUM_ ; } y = ( NUM_ * y + x128 / y9 ) / NUM_ ; assert ( y <= two_128 ) ; } } y <<= shift ; }
"
"function change goal ( uint256 _softcap ) public only owner { require ( _softcap != NUM_ ) ; goal = _softcap ; }
"
"function take ownership ( uint256 _unicorn id ) public { require ( allowance ( msg . sender , _unicorn id ) ) ; clear approval and transfer ( owner of ( _unicorn id ) , msg . sender , _unicorn id ) ; }
"
"function set symbol ( string _symbol ) public only owner { symbol = _symbol ; }
"
"function get identity wallet ( address _id ) public view returns ( address ) { return identities [ _id ] . wallet ; }
"
"function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg
"
"function enable transfer ( ) public only owner { enable transfers = BOOL_ ; }
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( ! token frozen ) ; if ( data . can make no fee transfer ( msg . sender , _to ) || data . has prestige ( msg . sender ) ) { no fee ( msg . sender , _to , _amount ) ; } else { _transfer ( msg . sender , _to , _amount ) ; } return BOOL_ ; }
"
"function unfreeze account ( address target ) external optional proxy_only owner { require ( frozen [ target ] && target != fee_address , STR_ ) ; frozen [ target ] = BOOL_ ; emit account unfrozen ( target ) ; }
"
"function calculate to fund ( address _beneficiary , uint256 _wei amount ) internal view returns ( uint256 ) { uint256 wei amount = _wei amount ; uint8 current stage ; bool on sale ; ( current stage , on sale ) = get stage index ( ) ; require ( on sale ) ; stage memory p = stages [ current stage ] ; if ( p . kyc ) { require ( super . registered ( _beneficiary ) ) ; } require ( wei amount >= uint ( p . min purchase limit ) ) ; if ( p . max purchase limit != NUM_ && wei amount > uint ( p . max purchase limit ) ) { wei amount = uint ( p . max purchase limit ) ; } if ( p . cap > NUM_ ) { uint256 post wei raised = uint256 ( p . wei raised ) . add ( wei amount ) ; if ( post wei raised > p . cap ) { wei amount = uint256 ( p . cap ) . sub ( p . wei raised ) ; } } return super . calculate to fund ( _beneficiary
"
"function record purchase ( address purchaser , uint256 raw amount , uint256 timestamp ) internal returns ( uint256 amount ) { amount = raw amount ; if ( block . number >= purchase start block ) { require ( total amount of crowdsale purchases without bonus < max crowdsale cap ) ; uint256 crowdsale total amount after purchase = safe math . add ( total amount of crowdsale purchases without bonus , amount ) ; if ( crowdsale total amount after purchase > max crowdsale cap ) { uint256 difference = safe math . sub ( crowdsale total amount after purchase , max crowdsale cap ) ; uint256 eth value to return = safe math . mul ( difference , NUM_ ) / cny eth rate ; purchaser . transfer ( eth value to return ) ; amount = safe math . sub ( amount , difference ) ; raw amount = amount ; } } amount = get bonus amount calculation ( amount ) ; crowdsale purchase memory purchase = crowdsale purchase ( purchaser , amount , raw amount , timestamp ) ; crowdsale purchases . push ( purchase ) ; starbase purchased with eth ( msg . sender
"
"function participant round value ( address _address , uint _round ) external view returns ( uint ) { ico storage ico = icorounds [ _round == NUM_ ? current round : _round ] ; participant storage p = ico . participants [ _address ] ; return p . value ; }
"
"function finish sale ( ) public { require ( msg . sender == central bank ) ; require ( ! finished ) ; uint256 sale end time = safe add ( sale start time , sale duration ) ; require ( now >= sale end time ) ; finished = BOOL_ ; final price = price ( sale end time ) ; finished ( final price ) ; }
"
"function transfer to address ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }
"
"function is crowdsale full ( ) internal view returns ( bool full ) { return tokens sold >= sellable_tokens ; }
"
"function set authorized address ( address _target , bool _authorized ) only owner external { require ( _target != address ( NUM_ ) ) ; address to authorized [ _target ] = _authorized ; emit authorized address ( _target , _authorized ) ; }
"
"function create channel private ( address _sender_address , address _receiver_address , uint192 _deposit ) private { require ( _deposit <= channel_deposit_bugbounty_limit ) ; uint32 open_block_number = uint32 ( block . number ) ; bytes32 key = get key ( _sender_address , _receiver_address , open_block_number ) ; require ( channels [ key ] . deposit == NUM_ ) ; require ( channels [ key ] . open_block_number == NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; channels [ key ] = channel ( { deposit : _deposit , open_block_number : open_block_number } ) ; channel created ( _sender_address , _receiver_address , _deposit ) ; }
"
"function do purchase ( address _buyer , uint256 _amount ) private only after ( start time ) only before ( end time ) stop in emergency { if ( crowdsale finished ) revert ( ) ; if ( collected . add ( _amount ) > hard cap ) revert ( ) ; if ( ( ! soft cap reached ) && ( collected < soft cap ) && ( collected . add ( _amount ) >= soft cap ) ) { soft cap reached = BOOL_ ; soft cap reached ( soft cap ) ; } uint256 tokens = _amount . mul ( price ) . div ( NUM_ ether ) ; if ( tokens == NUM_ ) revert ( ) ; if ( token . balance of ( _buyer ) == NUM_ ) investor count ++ ; collected = collected . add ( _amount ) ; token . transfer ( _buyer , tokens ) ; wei raised = wei raised . add ( _amount ) ; tokens sold = tokens sold . add ( tokens ) ; new contribution ( _buyer , tokens , _amount ) ; if ( collected == hard cap ) { goal reached ( hard
"
"function change owner ( address _new owner ) public only owner returns ( bool ) { require ( owner != _new owner ) ; new owner = _new owner ; return BOOL_ ; }
"
"function refund eth ( uint256 ethto refund amount wei ) is in refund time frame is refunding state public { require ( ethto refund amount wei != NUM_ ) ; uint256 deposited token value = deposited token [ msg . sender ] ; uint256 deposited ethvalue = deposited eth [ msg . sender ] ; require ( ethto refund amount wei <= deposited ethvalue ) ; uint256 refund tokens = ethto refund amount wei . mul ( deposited token value ) . div ( deposited ethvalue ) ; assert ( refund tokens > NUM_ ) ; deposited eth [ msg . sender ] = deposited ethvalue . sub ( ethto refund amount wei ) ; deposited token [ msg . sender ] = deposited token value . sub ( refund tokens ) ; token . destroy ( address ( this ) , refund tokens ) ; msg . sender . transfer ( ethto refund amount wei ) ; refunded eth ( msg . sender , ethto refund amount wei ) ; }
"
"function contribute by bitcoin ( uint256 _bitcoin amount , uint256 _ether amount , address _contributor wallet , uint _contribution datetime ) public over min contribution ( _ether amount ) only owner contribution allowed { require ( _contribution datetime <= get current datetime ( ) ) ; uint256 _basic token = get basic token amount ( _ether amount ) ; uint256 _time bonus = get time bonus amount ( _basic token ) ; uint256 _volume bonus = get volume bonus amount ( _basic token , _ether amount ) ; uint256 _total token = _basic token . add256 ( _time bonus ) . add256 ( _volume bonus ) ; if ( _contribution datetime > last contribition date [ _contributor wallet ] ) last contribition date [ _contributor wallet ] = _contribution datetime ; referral contribution [ _contributor wallet ] = referral contribution [ _contributor wallet ] . add256 ( _ether amount ) ; collectable token [ _contributor wallet ] = collectable token [ _contributor wallet ] . add256 ( _total token ) ; total collectable token = total collectable token . add256 ( _total token ) ; log contribution bitcoin ( _contributor wallet , _bitcoin amount , _ether amount , _basic token
"
"function withdraw ( ) only owner { if ( ! owner . send ( this . balance ) ) { throw ; } }
"
"function set token contract ( address new token ) external only owner check is address valid ( new token ) { token = compliant token ( new token ) ; }
"
"function sell fci ( address _seller , uint _value fci ) only controller public { require ( is pause == BOOL_ && now < time expires ) ; require ( _seller != NUM_ ) ; require ( _value fci * price fci > fci decimals ) ; uint nac return = ( _value fci . mul ( price fci ) ) / fci decimals ; balance of [ address ( this ) ] = balance of [ address ( this ) ] . sub ( _value fci ) ; total supply = total supply . sub ( _value fci ) ; netf balance = netf balance . sub ( nac return ) ; nami crowd sale nami token = nami crowd sale ( nami addr ) ; nami token . transfer ( _seller , nac return ) ; emit transfer ( _seller , address ( this ) , _value fci ) ; emit sell fci ( _seller , nac return , _value fci , now ) ; }
"
"function get forecast count ( uint _token id , uint _block number , bool is released ) public view returns ( uint ) { require ( exists ( _token id ) ) ; uint forecast count = NUM_ ; uint index = NUM_ ; uint count = token forecasts [ _token id ] . length ; for ( index = NUM_ ; index < count ; index ++ ) { if ( forecasts [ token forecasts [ _token id ] [ index ] ] . forecast block number < _block number ) { if ( is released ) { if ( games [ forecasts [ token forecasts [ _token id ] [ index ] ] . game id ] . game date < block . timestamp ) { forecast count = forecast count + NUM_ ; } } else { forecast count = forecast count + NUM_ ; } } } if ( tokens [ _token id ] . parent id != NUM_ ) { forecast count = forecast count . add ( get forecast count ( tokens [ _token id ] . parent id , tokens [ _token id ] . create block number , is released ) )
"
"function challenge reparameterization ( bytes32 _prop id ) public returns ( uint challenge id ) { param proposal memory prop = proposals [ _prop id ] ; uint deposit = prop . deposit ; require ( prop exists ( _prop id ) && prop . challenge id == NUM_ ) ; uint poll id = voting . start poll ( get ( STR_ ) , get ( STR_ ) , get ( STR_ ) ) ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : safe math . sub ( NUM_ , get ( STR_ ) ) . mul ( deposit ) . div ( NUM_ ) , stake : deposit , resolved : BOOL_ , winning tokens : NUM_ } ) ; proposals [ _prop id ] . challenge id = poll id ; require ( token . transfer from ( msg . sender , this , deposit ) ) ; var ( commit end date , reveal end date , ) = voting . poll map ( poll id ) ; emit _new challenge ( _prop id , poll id , commit end date , reveal end date ,
"
"function vote ( uint proposal number , bool supports proposal ) only shareholders public returns ( uint vote id ) { proposal storage p = proposals [ proposal number ] ; require ( p . voted [ msg . sender ] != BOOL_ ) ; vote id = p . votes . length ++ ; p . votes [ vote id ] = vote ( { in support : supports proposal , voter : msg . sender } ) ; p . voted [ msg . sender ] = BOOL_ ; p . number of votes = vote id + NUM_ ; voted ( proposal number , supports proposal , msg . sender ) ; return vote id ; }
"
"function bet of ( address _who ) constant external returns ( uint ) { bet memory player = bets [ _who ] ; if ( ( player . value == NUM_ ) || ( player . block num <= NUM_ ) || ( block . number < player . block num ) || ( block . number >= player . block num + ( NUM_ * hashes size ) ) ) { return ( NUM_ ) ; } if ( block . number < player . block num + NUM_ ) { return ( bet prize ( player , uint24 ( block . blockhash ( player . block num ) ) ) ) ; } if ( hash first > NUM_ ) { uint32 hash = get hash ( player . block num ) ; if ( hash == NUM_ ) { return ( uint ( player . value ) ) ; } else { return ( bet prize ( player , uint24 ( hash ) ) ) ; } } return ( NUM_ ) ; }
"
"function is unfrozen account ( address _addr ) private view returns ( bool is_unfrozen_account ) { return frozen account [ _addr ] == BOOL_ ; }
"
"function _get block index ( uint256 _initial block number , uint256 _current block number ) public pure returns ( uint256 ) { require ( _current block number >= _initial block number ) ; return _current block number . sub ( _initial block number ) ; }
"
"function set name ( string new name ) external only owner { name = new name ; }
"
"function public start regular phase ( ) public { require ( now > ( ico open time + NUM_ weeks ) && ico open time != NUM_ ) ; ico phase = BOOL_ ; regular phase = BOOL_ ; }
"
"function transfer tokens ( address _to , uint256 [ ] _token ids , uint256 [ ] _values ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _token ids . length == _values . length ) ; require ( _token ids . length < NUM_ ) ; for ( uint i = NUM_ ; i < _token ids . length ; i ++ ) { require ( _values [ i ] > NUM_ ) ; require ( _values [ i ] <= balances [ msg . sender ] . tokens [ _token ids [ i ] ] . amount ) ; } for ( i = NUM_ ; i < _token ids . length ; i ++ ) { require ( internal transfer ( msg . sender , _to , _token ids [ i ] , _values [ i ] ) ) ; emit token transfer ( msg . sender , _to , _token ids [ i ] , _values [ i ] ) ; emit transfer ( msg . sender , _to , _values [ i ] ) ; } return BOOL_ ; }
"
"function set allocation ( address _recipient , uint256 _total allocated , allocation type _supply ) only owner public { require ( allocations [ _recipient ] . total allocated == NUM_ && _total allocated > NUM_ ) ; require ( _supply >= allocation type . presale && _supply <= allocation type . bonus3 ) ; require ( _recipient != address ( NUM_ ) ) ; if ( _supply == allocation type . presale ) { available_presale_supply = available_presale_supply . sub ( _total allocated ) ; allocations [ _recipient ] = allocation ( uint8 ( allocation type . presale ) , NUM_ , NUM_ , _total allocated , NUM_ ) ; } else if ( _supply == allocation type . founder ) { available_founder_supply = available_founder_supply . sub ( _total allocated ) ; allocations [ _recipient ] = allocation ( uint8 ( allocation type . founder ) , start time + NUM_ years , start time + NUM_ years , _total allocated , NUM_ ) ; } else if ( _supply == allocation type . advisor ) { available_advisor_supply = available_advisor_supply . sub ( _total allocated ) ; allocations [ _recipient ] = allocation ( uint8 ( allocation type . advisor )
"
"function get user dividends ( address _user ) public view returns ( uint256 ) { return ( ( uint256 ) ( ( int256 ) ( earnings per token * token balance [ _user ] ) - payouts [ _user ] ) / scale factor ) + ( referral balance [ _user ] ) ; }
"
"function set colors x4 ( uint16 [ NUM_ ] property ids , uint256 [ NUM_ ] new colors , uint256 pxlto spend each ) public returns ( bool [ NUM_ ] ) { bool [ NUM_ ] results ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { require ( property ids [ i ] < NUM_ ) ; results [ i ] = set colors ( property ids [ i ] , [ new colors [ i * NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] ] , pxlto spend each ) ; } return results ; }
"
"function set game address ( uint8 game , address new address ) public only owner { if ( game < casino games . length ) casino games [ game ] = new address ; else casino games . push ( new address ) ; }
"
"function transfer ( address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { require ( address ( jackpot ) != NUM_ ) ; require ( croupier != NUM_ ) ; if ( _to == address ( jackpot ) ) { _burn from account ( msg . sender , NUM_ ) ; jackpot . bet token ( msg . sender ) ; return BOOL_ ; } if ( _to == croupier && msg . sender != house ) { deposit of [ msg . sender ] += _value ; total deposit = total deposit . add ( _value ) ; deposit ( msg . sender , _value , NUM_ , deposit of [ msg . sender ] ) ; } return _transfer ( msg . sender , _to , _value ) ; }
"
"function get tier whitelist ( address _storage , bytes32 _exec_id , uint _tier_index ) external view returns ( uint num_whitelisted , address [ ] memory whitelist ) { num_whitelisted = uint ( getter interface ( _storage ) . read ( _exec_id , tier whitelist ( _tier_index ) ) ) ; if ( num_whitelisted == NUM_ ) return ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_whitelisted ) ; for ( uint i = NUM_ ; i < num_whitelisted ; i ++ ) arr_indices [ i ] = bytes32 ( NUM_ + ( NUM_ * i ) + uint ( tier whitelist ( _tier_index ) ) ) ; whitelist = getter interface ( _storage ) . read multi ( _exec_id , arr_indices ) . to address arr ( ) ; }
"
"function add precommitment ( address _participant , uint256 _balance , uint256 _ethers ) only owner { require ( now < start_ts ) ; require ( _balance >= NUM_ ether ) ; uint additional_tokens = _balance / NUM_ * NUM_ ; balance of [ _participant ] = balance of [ _participant ] . add ( _balance ) ; balance of [ target_tokens_address ] = balance of [ target_tokens_address ] . add ( additional_tokens ) ; total supply = total supply . add ( _balance ) ; total supply = total supply . add ( additional_tokens ) ; total ethers = total ethers . add ( _ethers ) ; transfer ( NUM_ , _participant , _balance ) ; transfer ( NUM_ , target_tokens_address , additional_tokens ) ; }
"
"function set rush time challenge rewards percent ( uint _new rush time challenge rewards percent ) only owner external { rush time challenge rewards percent = _new rush time challenge rewards percent ; }
"
"function service fee withdraw ( ) external only owner { require ( service reward > NUM_ ) ; if ( game token . transfer ( msg . sender , service reward ) ) service reward = NUM_ ; }
"
"function dilute power ( uint256 _amount babz , uint256 _amount power ) public only admins { uint256 authorized pow = authorized power ( ) ; uint256 total babz = complete supply ( ) ; if ( authorized pow == NUM_ ) { _set authorized power ( ( _amount power > NUM_ ) ? _amount power : _amount babz . add ( total babz ) ) ; } else { _set authorized power ( authorized pow . mul ( total babz . add ( _amount babz ) ) . div ( total babz ) ) ; } _set burn pool ( burn pool ( ) . add ( _amount babz ) ) ; }
"
"function set initial allocation lock ( address allocation address ) external only controller returns ( bool ) { require ( allocation address != address ( NUM_ ) ) ; locked addresses [ allocation address ] = BOOL_ ; emit initiall allocation locked ( allocation address ) ; return BOOL_ ; }
"
"function buy block ( uint x , uint y , bytes32 name , bytes32 description , bytes32 url , bytes32 image url ) public payable { bytes32 key = get key ( x , y ) ; uint price = s . get uint ( keccak256 ( key , STR_ ) ) ; uint for sale = s . get uint ( keccak256 ( key , STR_ ) ) ; address owner = s . get add ( keccak256 ( key , STR_ ) ) ; require ( owner != address ( NUM_ ) ) ; require ( ( for sale > NUM_ && msg . value >= for sale ) || msg . value >= price * NUM_ ) ; uint fee percentage = s . get uint ( STR_ ) ; reward parties ( x , y , fee percentage ) ; s . set uint ( keccak256 ( key , STR_ ) , msg . value ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , name ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , description ) ; s . set bytes32 ( keccak256 ( key ,
"
"function refund ( ) external { if ( is finalized ) revert ( ) ; if ( block . number <= funding end block ) revert ( ) ; if ( total supply >= min cap ) revert ( ) ; if ( msg . sender == owner ) revert ( ) ; uint256 mpy val = balances [ msg . sender ] ; if ( mpy val == NUM_ ) revert ( ) ; balances [ msg . sender ] = NUM_ ; total supply = safe subtract ( total supply , mpy val ) ; uint256 eth val = mpy val / token exchange rate ; mpyrefund ( msg . sender , eth val ) ; if ( ! msg . sender . send ( eth val ) ) revert ( ) ; }
"
"function issue partner tokens ( uint partner tokens ) internal { balances [ owner ] = partner tokens ; transfer ( address ( NUM_ ) , owner , partner tokens ) ; }
"
"function batch transfer ( address [ ] _to list , uint256 [ ] _tokens list ) public returns ( bool ) { require ( _to list . length <= NUM_ ) ; require ( _to list . length == _tokens list . length ) ; uint256 sum = NUM_ ; for ( uint32 index = NUM_ ; index < _tokens list . length ; index ++ ) { sum = sum . add ( _tokens list [ index ] ) ; } require ( balances [ msg . sender ] >= sum ) ; for ( uint32 i = NUM_ ; i < _to list . length ; i ++ ) { transfer ( _to list [ i ] , _tokens list [ i ] ) ; } return BOOL_ ; }
"
"function create gen0 auction ( uint256 _genes ) external only coo { require ( gen0 created count < gen0_creation_limit ) ; uint256 pony id = _create pony ( NUM_ , NUM_ , NUM_ , _genes , address ( this ) ) ; _approve ( pony id , sale auction ) ; sale auction . create auction ( pony id , _compute next gen0 price ( ) , NUM_ , gen0_auction_duration , address ( this ) ) ; gen0 created count ++ ; }
"
"function end sale ( ) public only owner _contract up _sale not ended { require ( sale time over ( ) ) ; sale ended = BOOL_ ; emit sale ended ( msg . sender , now ) ; }
"
"function debit ( address [ ] users , uint256 [ ] values ) public only master returns ( bool ) { require ( users . length == values . length ) ; uint256 old balance = balances [ msg . sender ] ; uint256 new balance = old balance ; address current user ; uint256 current value ; uint256 current balance ; for ( uint256 i = NUM_ ; i < users . length ; ++ i ) { current user = users [ i ] ; current value = values [ i ] ; current balance = balances [ current user ] ; require ( direct debit allowances [ current user ] ) ; require ( current value <= current balance ) ; balances [ current user ] = current balance - current value ; new balance += current value ; transfer ( current user , msg . sender , current value ) ; } require ( old balance <= new balance ) ; balances [ msg . sender ] = new balance ; return BOOL_ ; }
"
"function current standing ( ) private constant returns ( state ) { if ( is terminated ) { return this . balance > NUM_ ? state . money_back_running : state . closed ; } else if ( block . number < presale_start ) { return state . before_start ; } else if ( block . number <= presale_end && total_amount < max_total_amount_get && ! is stopped ) { return state . presale_running ; } else if ( this . balance == NUM_ ) { return state . closed ; } else if ( block . number <= withdrawal_end && total_amount >= min_total_amount_get ) { return state . withdrawal_running ; } else { return state . money_back_running ; } }
"
"function chance of winning ( uint value ) constant returns ( uint rate , uint bet ) { if ( jackpot_ == NUM_ ) { rate = NUM_ ; bet = NUM_ ; return ; } if ( value < minimum roll price ) { value = minimum roll price ; } rate = get rate ( value ) ; bet = get real bet ( rate ) ; while ( value < bet ) { rate ++ ; bet = get real bet ( rate ) ; } if ( rate < best roll rate ) { rate = best roll rate ; bet = get real bet ( rate ) ; } }
"
"function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; uint256 value = msg . value ; uint256 tokens = calculate ( value ) ; require ( is valid purchase ( value , tokens ) ) ; total token sold = total token sold . add ( tokens ) ; total ether raised = total ether raised . add ( value ) ; ether raised per wallet [ msg . sender ] = ether raised per wallet [ msg . sender ] . add ( value ) ; token . transfer ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , value , tokens , now ) ; }
"
"function release ( address _sender , address _recipient , uint256 _transaction id , uint256 _exchange rate ) public { lock memory lock = escrows [ msg . sender ] [ _transaction id ] ; require ( lock . expiration != NUM_ ) ; require ( lock . sender == _sender ) ; require ( lock . recipient == _recipient || lock . sender == _recipient ) ; require ( lock . paid ) ; if ( lock . fee > NUM_ && lock . recipient == _recipient ) { token . transfer ( _recipient , lock . value ) ; token . transfer ( msg . sender , lock . fee ) ; } else { token . transfer ( _recipient , lock . value . add ( lock . fee ) ) ; } delete escrows [ msg . sender ] [ _transaction id ] ; token . issue exchange rate ( _sender , _recipient , msg . sender , lock . value , _transaction id , _exchange rate ) ; released ( msg . sender , _recipient , _transaction id ) ; }
"
"function update cny eth rate ( uint256 rate ) external only fundraiser returns ( bool ) { cny eth rate = rate ; cny eth rate updated ( cny eth rate ) ; return BOOL_ ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function limit for checklist id ( uint8 _checklist id ) external view returns ( uint16 ) { rarity tier rarity tier ; uint8 index ; if ( _checklist id < NUM_ ) { rarity tier = original checklist items [ _checklist id ] . tier ; } else if ( _checklist id < NUM_ ) { index = _checklist id - NUM_ ; require ( index < iconics count ( ) , STR_ ) ; rarity tier = iconic checklist items [ index ] . tier ; } else { index = _checklist id - NUM_ ; require ( index < unreleased count ( ) , STR_ ) ; rarity tier = unreleased checklist items [ index ] . tier ; } return tier limits [ uint8 ( rarity tier ) ] ; }
"
"function stake ( address staker , address whitelist address ) external returns ( bool success ) { require ( whitelist [ whitelist address ] . staker address == NUM_ ) ; require ( staker == msg . sender || ( msg . sender == address ( token ) && staker == tx . origin ) ) ; whitelist [ whitelist address ] . staker address = staker ; whitelist [ whitelist address ] . staked amount = required stake ; deposit ( staker , required stake ) ; emit staked ( staker ) ; return BOOL_ ; }
"
"function authorize ( address addr , uint cap ) public only owner { require ( contract stage == NUM_ ) ; _check whitelist contract ( addr ) ; require ( ! whitelist [ addr ] . authorized ) ; require ( ( cap > NUM_ && cap < contribution caps . length ) || ( cap >= contribution min && cap <= contribution caps [ NUM_ ] ) ) ; uint size ; assembly { size : = extcodesize ( addr ) } require ( size == NUM_ ) ; whitelist [ addr ] . cap = cap ; whitelist [ addr ] . authorized = BOOL_ ; }
"
"function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;
"
"function chase ( ) private { uint d value = NUM_ finney ; if ( msg . value > max deposit * NUM_ ether ) { msg . sender . send ( msg . value - max deposit * NUM_ ether ) ; d value = max deposit * NUM_ ether ; } else { d value = msg . value ; } add new donkey ( msg . sender ) ; entries . push ( entry ( msg . sender , d value , ( d value * ( multiplier ) / NUM_ ) , BOOL_ ) ) ; balance += ( d value * ( NUM_ - fee ) ) / NUM_ ; donkeys invested += d value ; donkeys [ msg . sender ] . invested += d value ; uint index = ranking . length - NUM_ ; uint new entry = donkeys [ msg . sender ] . invested ; bool done = BOOL_ ; bool same position = BOOL_ ; uint existing at = ranking . length - NUM_ ; while ( ranking [ index ] . invested < new entry && ! done ) { if ( index > NUM_ ) { done
"
"function pay affiliate to address ( address _referee ) public only owner returns ( bool success ) { address referrer = referral [ _referee ] ; ccc . pay bonus affiliate ( referrer , referral balance [ _referee ] ) ; referral balance [ _referee ] = NUM_ ; return BOOL_ ; }
"
"function update rates ( uint [ ] data ) public only owner { require ( data . length % NUM_ <= NUM_ ) ; uint i = NUM_ ; while ( i < data . length / NUM_ ) { bytes32 symbol = bytes32 ( data [ i * NUM_ ] ) ; uint rate = data [ i * NUM_ + NUM_ ] ; rates [ symbol ] = rate ; emit rate updated ( now , symbol , rate ) ; i ++ ; } }
"
"function get locks locked for ( address _owner , uint256 count ) valid contract only returns ( uint256 locked for ) { locked for = locked addresses [ _owner ] [ count ] . locked for ; }
"
"function is ico ( uint _time ) public view returns ( bool ) { if ( _time == NUM_ ) { _time = now ; } if ( ico_start < _time && _time <= ico_finish ) { return BOOL_ ; } return BOOL_ ; }
"
"function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }
"
"function is whitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; }
"
"function create children ( uint32 _matron , uint32 _sire ) public payable returns ( uint32 ) { require ( is priv ( ) ) ; require ( is pause save ( ) ) ; require ( rabbit to owner [ _matron ] == msg . sender ) ; require ( rabbits [ ( _sire - NUM_ ) ] . role == NUM_ ) ; require ( _matron != _sire ) ; require ( get breed ( _matron ) ) ; require ( msg . value >= get sire price ( _sire ) ) ; uint genome = get genome children ( _matron , _sire ) ; uint localdnk = private contract . mix dnk ( map dnk [ _matron ] , map dnk [ _sire ] , genome ) ; rabbit memory rabbit = rabbit ( _matron , _sire , block . number , NUM_ , NUM_ , NUM_ , genome ) ; uint32 bunnyid = uint32 ( rabbits . push ( rabbit ) ) ; map dnk [ bunnyid ] = localdnk ; uint _money mother = rabbit sire price [ _sire ] . div ( NUM_ ) ; _transfer money mother ( _matron , _money mother ) ;
"
"function get teller ( address _teller ) public view returns ( int32 lat , int32 lng , bytes2 country id , bytes16 postal code , int8 currency id , bytes16 messenger , int8 avatar id , int16 rates , uint balance , bool online , bool buyer , int16 buy rates ) { teller storage the teller = teller [ _teller ] ; lat = the teller . lat ; lng = the teller . lng ; country id = the teller . country id ; postal code = the teller . postal code ; currency id = the teller . currency id ; messenger = the teller . messenger ; avatar id = the teller . avatar id ; rates = the teller . rates ; online = the teller . online ; buyer = the teller . buyer ; buy rates = the teller . buy rates ; balance = bank . get eth bal teller ( _teller ) ; }
"
"function set etheraffle ( address _new ) external only etheraffle { log etheraffle change ( etheraffle , _new , now ) ; etheraffle = _new ; }
"
"function transfer ownership ( address _owner ) public only owner { new owner = _owner ; }
"
"function close invest ( bytes5 _interval ) internal { uint256 _intrest ; address _to = msg . sender ; uint256 _period = count period ( _to , _interval ) ; invest storage inv = invest info [ _to ] [ _interval ] ; uint256 _value = inv . balance ; if ( _period == NUM_ ) { balances [ this ] -= _value ; balances [ _to ] += _value ; emit transfer ( this , _to , _value ) ; emit invest closed ( _to , _value ) ; } else if ( _period > NUM_ ) { balances [ this ] -= _value ; total supply -= _value ; emit transfer ( this , NUM_ , _value ) ; emit destruction ( _value ) ; _intrest = reward controller ( _to , _interval ) ; if ( manager [ msg . sender ] ) { _intrest = mulsm ( divsm ( _intrest , NUM_ ) , NUM_ ) ; } issue ( _to , _intrest ) ; emit invest closed ( _to , _intrest ) ; } inv . exists = BOOL_ ; inv . balance = NUM_ ; inv . closed = now ; }
"
"function submit ether proposal ( uint request value , string url ) only after end only executive returns ( bytes32 result id , bool result succes ) { if ( able to issue tokens ) throw ; if ( balance of ( this ) > NUM_ ) throw ; if ( now < ( time of last proposal + NUM_ weeks ) ) throw ; uint percent = collected ether / NUM_ ; if ( request value > proposal_funds_th * percent ) throw ; if ( request value > this . balance ) request value = this . balance ; bytes32 id = sha3 ( msg . data , now ) ; uint time ends = now + proposal_lifetime ; proposal memory new proposal = proposal ( id , request value , url , time ends , NUM_ , msg . sender , BOOL_ , proposal currency . ether ) ; proposals [ id ] = new proposal ; list proposals . push ( new proposal ) ; time of last proposal = now ; proposal request submitted ( id , request value , time ends , url , msg . sender ) ; return ( id , BOOL_ )
"
"function withdraw with fee ( address _deposit , uint256 _time , bytes32 _name , address _to , uint256 _value , bool _check ) only owner public returns ( bool ) { require ( _deposit != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; uint256 _balance = tk . balance of ( _deposit ) ; if ( _check ) { require ( _value <= _balance ) ; } uint256 available = _balance . sub ( deposit repos [ _deposit ] . frozen ) ; if ( _check ) { require ( _value <= available ) ; } bool exist ; bool correct ; withdraw wallet [ ] storage withdraw wallet list = deposit repos [ _deposit ] . withdraw wallets ; ( exist , correct ) = check withdraw address ( _deposit , _name , _to ) ; if ( ! exist ) { withdraw wallet list . push ( withdraw wallet ( _name , _to ) ) ; } else if ( ! correct ) { return BOOL_ ; } deposit withdraw depos withdr = deposit withdraw ( _deposit ) ; if ( _value > available ) { require ( depos withdr
"
"function withdraw all ether ( ) only manager { if ( this . balance > NUM_ ) { escrow . transfer ( this . balance ) ; } }
"
"function start auction ( ) only owner at state ( states . setup ) { current state = states . accepting bids ; auction started ( ) ; }
"
"function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( sale auction ) ) ; require ( _owns ( msg . sender , _token id ) ) ; _transfer ( msg . sender , _to , _token id ) ; }
"
"function withdraw funds ( ) public only director force { director . transfer ( this . balance ) ; }
"
"function owner set callback gas price ( uint new callback gas price ) public only owner { oraclize_set custom gas price ( new callback gas price ) ; }
"
"function recharge deposit ( ) payable public { deposit = deposit . add ( msg . value ) ; }
"
"function mint after sale ( ) external only owner returns ( bool ) { require ( ! token generated ) ; require ( minting finished ) ; uint256 pre supply = total supply ( ) ; require ( pre supply < target_total_supply ) ; uint256 amount = target_total_supply . sub ( pre supply ) ; total supply_ = target_total_supply ; balances [ owner ] = balances [ owner ] . add ( amount ) ; emit transfer ( address ( NUM_ ) , owner , amount ) ; token generated = BOOL_ ; emit mint after sale ( owner , pre supply , total supply ( ) ) ; return BOOL_ ; }
"
"function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j
"
"function start third phase ( ) public { balances [ msg . sender ] = balances [ msg . sender ] . add ( third_supply ) ; phase = NUM_ ; }
"
"function check balance ( ) public constant returns ( uint256 red_balance ) { uint256 all deposit sum ; for ( int16 i = NUM_ ; i <= max id ; i ++ ) { all deposit sum = all deposit sum . add ( partners [ i ] . amount ) ; } red_balance = address ( this ) . balance . sub ( not distributed amount ) . sub ( all deposit sum ) ; return red_balance ; }
"
"function do emit ( uint _ptr , uint _ptr_bound ) internal returns ( uint ptr , uint n_emitted ) { assert ( get action ( _ptr ) == emits ) ; _ptr += NUM_ ; uint num_events = get length ( _ptr ) ; _ptr += NUM_ ; bytes32 [ ] memory topics ; bytes memory data ; while ( _ptr <= _ptr_bound && n_emitted < num_events ) { assembly { topics : = _ptr data : = add ( add ( _ptr , NUM_ ) , mul ( NUM_ , mload ( topics ) ) ) } uint log_size = NUM_ + ( NUM_ * ( NUM_ + topics . length ) ) + data . length ; assembly { switch mload ( topics ) case NUM_ { log0 ( add ( NUM_ , data ) , mload ( data ) ) } case NUM_ { log1 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) ) } case NUM_ { log2 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) , mload
"
"function bet on ( uint32 _season , uint32 _index , uint _seed , address _invitor ) payable external returns ( bool ) { require ( is normal user ( msg . sender ) ) ; require ( match time [ _season ] > NUM_ ) ; require ( now < match time [ _season ] - NUM_ ) ; require ( msg . value >= NUM_ finney && msg . value < NUM_ ether ) ; betting memory tmp = betting ( { account : msg . sender , season : _season , index : _index , seed : _seed , invitor : _invitor , amount : msg . value } ) ; uint key = _season * NUM_ + _index ; bet on fighter [ key ] = safe add ( bet on fighter [ key ] , msg . value ) ; betting [ ] storage items = all bittings [ key ] ; items . push ( tmp ) ; fighter storage soldier = soldiers [ key ] ; emit betted ( _season , _index , msg . sender , msg . value ) ; emit log bet ( _season , msg . sender , msg .
"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) revert ( ) ; if ( _to == address ( upgrade agent ) ) revert ( ) ; if ( _to == address ( this ) ) revert ( ) ; if ( balances [ msg . sender ] >= _value && _value > NUM_ ) { balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function deed of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < count of deeds by owner ( _owner ) ) ; uint256 seen = NUM_ ; uint256 total deeds = count of deeds ( ) ; for ( uint256 deed number = NUM_ ; deed number < total deeds ; deed number ++ ) { uint256 identifier = identifiers [ deed number ] ; if ( identifier to owner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }
"
"function quote ( address _from token , uint256 _in amount , address _to token ) public constant is operational returns ( uint256 return amount ) { uint256 _r1 ; uint256 _r2 ; if ( token1 == _from token && token2 == _to token ) { _r1 = r1 . add ( _in amount ) ; _r2 = calc reserve ( _r1 , s1 , s2 ) ; if ( _r2 > r2 ) { return NUM_ ; } return amount = r2 . sub ( _r2 ) ; } else if ( token2 == _from token && token1 == _to token ) { _r2 = r2 . add ( _in amount ) ; _r1 = calc reserve ( _r2 , s2 , s1 ) ; if ( _r1 > r1 ) { return NUM_ ; } return amount = r1 . sub ( _r1 ) ; } else { return NUM_ ; } }
"
"function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens
"
"function is p2 pkh ( bytes tx bytes , uint pos , uint script_len ) returns ( bool ) { return ( script_len == NUM_ ) && ( tx bytes [ pos ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) ; }
"
"function successful ( ) public { require ( state == state . successful ) ; if ( claimed == BOOL_ ) { claimed = BOOL_ ; address writer = NUM_ ; writer . transfer ( NUM_ ether ) ; uint256 remanent = hard cap . sub ( total distributed ) ; token reward . transfer ( creator , remanent ) ; emit log contributors payout ( creator , remanent ) ; } creator . transfer ( address ( this ) . balance ) ; emit log beneficiary paid ( creator ) ; }
"
"function to rtc ( uint256 amount ) public constant returns ( uint256 ) { return amount . div ( NUM_ * * decimals ) ; }
"
"function finalize ( ) external { if ( msg . sender != owner ) revert ( ) ; if ( total supply < min cap ) revert ( ) ; if ( block . number <= funding end block && total supply < max cap ) revert ( ) ; if ( ! owner . send ( this . balance ) ) revert ( ) ; balances [ owner ] += owner tokens ; total supply += owner tokens ; is finalized = BOOL_ ; }
"
"function _approve ( uint256 token id , address user address ) internal { tokens approved map [ token id ] = user address ; }
"
"function create contract element ( string _name , uint256 _scientist id ) public only ceo { require ( periodic table exists == BOOL_ ) ; uint256 _id = safe math . add ( element ctr , element start ) ; uint256 _scientist id processed = safe math . add ( _scientist id , scientist start ) ; _create element ( _id , _name , address ( this ) , element starting price , _scientist id processed ) ; element ctr = safe math . add ( element ctr , NUM_ ) ; }
"
"function allow refunds ( ) external only owner { require ( ! is finalized ) ; require ( has closed ( ) ) ; refunds allowed = BOOL_ ; vault . enable refunds ( ) ; }
"
"function set account registry ( account registry interface _new registry ) public non zero ( _new registry ) only owner { address old registry = registry ; registry = _new registry ; emit account registry changed ( old registry , registry ) ; }
"
"function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]
"
"function start auction ( ) only owner at state ( states . setup ) { current state = states . accepting bids ; auction started ( ) ; }
"
"function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block
"
"function trigger soft cap ( ) private { if ( soft cap triggered ) throw ; uint soft cap = mysterium pricing ( pricing strategy ) . get soft cap in weis ( ) ; if ( soft cap > wei raised ) throw ; ends at = now + ( NUM_ * NUM_ * NUM_ ) ; ends at changed ( ends at ) ; soft cap triggered = BOOL_ ; }
"
"function beneficiary send ( ) { if ( ! finalized ) throw ; if ( beneficiary . send ( amount raised ) ) { fund claim ( beneficiary , amount raised ) ; } }
"
"function batch return eth if failed ( uint256 _number of returns ) only owner { if ( block . number < end block || total eth raised >= min eth to raise ) throw ; address current participant address ; uint256 contribution ; for ( uint cnt = NUM_ ; cnt < _number of returns ; cnt ++ ) { current participant address = participant index [ last eth return index ] ; if ( current participant address == NUM_ ) return ; if ( ! has claimed eth when fail [ current participant address ] ) { contribution = participant contribution [ current participant address ] ; has claimed eth when fail [ msg . sender ] = BOOL_ ; if ( ! current participant address . send ( contribution ) ) { error sending eth ( current participant address , contribution ) ; } } last eth return index += NUM_ ; } }
"
"function is authorized ( address logger ) returns ( bool ) { return authorized loggers [ logger ] ; }
"
"modifier valid conversion path ( ierc20 token [ ] _path ) { require ( _path . length > NUM_ && _path . length <= ( NUM_ + NUM_ * NUM_ ) && _path . length % NUM_ == NUM_ ) ; _ ; }
"
"function pause round a ( ) external manager only { require ( status ico == status ico . round astarted ) ; status ico = status ico . round apaused ; log pause round a ( ) ; }
"
"function withdraw ( ) only beneficiary at stage ( stages . ended ) { beneficiary . transfer ( this . balance ) ; }
"
"function release for ecosystem ( ) public owner only returns ( bool success ) { require ( now >= create time + NUM_ weeks ) ; require ( tokens released to ecosystem < ecosystem supply ) ; uint256 temp = ecosystem supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( ecosystem tranches released < max tranches && current tranche > ecosystem tranches released && ( current supply + alloc amount ) <= total supply ) { ecosystem tranches released ++ ; balance of [ ecosystem address ] = safe add ( balance of [ ecosystem address ] , alloc amount ) ; current supply += alloc amount ; tokens released to ecosystem = safe add ( tokens released to ecosystem , alloc amount ) ; transfer ( NUM_ , ecosystem address , alloc amount ) ; return BOOL_ ; } revert ( ) ; }
"
"function div ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { assert ( b > NUM_ ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }
"
"function pull entry ( uint row number ) public constant returns ( bytes32 , bytes32 , bytes32 , bytes16 , bytes1 , bytes16 , bytes32 , bytes32 ) { if ( row number >= disclosure list . length ) { revert ( ) ; } if ( row number < NUM_ ) { revert ( ) ; } if ( disclosure list [ row number ] . amended > NUM_ ) return pull entry ( disclosure list [ row number ] . amended ) ; disclosure memory entry = disclosure list [ row number ] ; return ( entry . organization , entry . recipient , entry . location , entry . amount , entry . funding type , entry . date , entry . purpose , entry . comment ) ; }
"
"function get current rate ( ) public view returns ( uint256 ) { uint256 time = now ; if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } return rate ; }
"
"function owner of ( uint256 _token id ) public view returns ( address ) { address owner = token owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; return owner ; }
"
"function is auditor registered ( address key ) constant returns ( bool ) { return auditor registry . is registered ( key ) ; }
"
"function withdraw token ( uint256 amount ) external only owner { uint256 balance = token contract . balance of ( this ) ; require ( balance > NUM_ && balance >= amount ) ; cards . set coin balance ( msg . sender , amount , NUM_ , BOOL_ ) ; token contract . transfer ( msg . sender , amount ) ; }
"
"function multi transfer ( uint [ ] bits ) public returns ( bool ) { for ( uint i = NUM_ ; i < bits . length ; i ++ ) { address a = address ( bits [ i ] > > NUM_ ) ; uint amount = bits [ i ] & ( ( NUM_ << NUM_ ) - NUM_ ) ; if ( ! transfer ( a , amount ) ) revert ( ) ; } return BOOL_ ; }
"
"function add asset part owner ( bytes32 _symbol , address _partowner ) only one of owners ( _symbol ) public returns ( uint ) { uint holder id = _create holder id ( _partowner ) ; assets [ _symbol ] . partowners [ holder id ] = BOOL_ ; cavplatform emitter ( events history ) . emit ownership change ( NUM_ , _partowner , _symbol ) ; return ok ; }
"
"function add_to_bounty ( ) payable { if ( msg . sender != developer_address ) throw ; if ( kill_switch ) throw ; if ( bought_tokens ) throw ; bounty += msg . value ; }
"
"function update beneficiary ( address _beneficiary ) public only owner returns ( bool ) { beneficiary = _beneficiary ; }
"
"function withdraw investment ( ) public { investment storage investment = investments [ msg . sender ] ; require ( ! investment . is verified ) ; uint total wei invested = investment . total wei invested ; require ( total wei invested > NUM_ ) ; investment . total wei invested = NUM_ ; investment . pending token amount = NUM_ ; pending wei amount = pending wei amount . sub ( total wei invested ) ; msg . sender . transfer ( total wei invested ) ; emit investment withdrawn ( msg . sender , total wei invested ) ; assert ( pending wei amount <= address ( this ) . balance ) ; }
"
"function get champs for sale ( ) view external returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( champs for sale count ) ; if ( champs for sale count > NUM_ ) { uint256 counter = NUM_ ; for ( uint256 i = NUM_ ; i < champs . length ; i ++ ) { if ( champs [ i ] . for sale == BOOL_ ) { result [ counter ] = i ; counter ++ ; } } } return result ; }
"
"function get total weighted contribution ( ) constant public returns ( uint256 ) { return total weighted contribution ; }
"
"function node exists ( linked list storage self , uint256 _node ) public view returns ( bool ) { if ( self . list [ _node ] [ prev ] == head && self . list [ _node ] [ next ] == head ) { if ( self . list [ head ] [ next ] == _node ) { return BOOL_ ; } else { return BOOL_ ; } } else { return BOOL_ ; } }
"
"function insert ( data storage self , uint256 element ) internal { if ( contains ( self , element ) ) { return ; } compact array . element memory new elem = compact array . element ( element ) ; uint256 index = self . compact array . push ( new elem ) ; set entry memory entry = set entry ( index , BOOL_ ) ; self . stored values [ element ] = entry ; }
"
"function buy price ( ) public view returns ( uint256 ) { if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . add ( safe math . add ( _ethereum , _dividends ) , _charity payout ) ; return _taxed ethereum ; } }
"
"function get deposit ( address beneficiar , uint idx ) constant returns ( uint256 deposit_dot_tokens , uint256 deposit_dot_release time ) { token deposit memory deposit ; require ( idx < deposits [ beneficiar ] . length ) ; deposit = deposits [ beneficiar ] [ idx ] ; deposit_dot_tokens = uint256 ( deposit . tokens ) ; deposit_dot_release time = uint256 ( deposit . release time ) ; }
"
"function seal ( ) public only owner { require ( ! sealed ) ; sealed = BOOL_ ; }
"
"function add evidence ( bytes32 _code hash , uint _new level , bytes32 _ipfs hash ) public { address auditor = msg . sender ; require ( audited contracts [ auditor ] [ _code hash ] . inserted block != NUM_ ) ; if ( audited contracts [ auditor ] [ _code hash ] . level != _new level ) audited contracts [ auditor ] [ _code hash ] . level = _new level ; emit attached evidence ( auditor , _code hash , _ipfs hash ) ; }
"
"function allow refunds ( ) external only owner { require ( ! is finalized ) ; require ( has closed ( ) ) ; refunds allowed = BOOL_ ; vault . enable refunds ( ) ; }
"
"function get variable releasable amount ( address _beneficiary ) internal view returns ( uint releasable amount ) { beneficiary memory _b = beneficiaries [ _beneficiary ] ; release memory _r = releases [ _beneficiary ] ; uint total releasable amount = get total locked amounts ( _beneficiary ) ; uint release ratio ; for ( uint i = _r . release times . length - NUM_ ; i >= NUM_ ; i -- ) { if ( now >= _r . release times [ i ] ) { release ratio = _r . release ratios [ i ] ; break ; } } require ( release ratio > NUM_ ) ; releasable amount = get partial amount ( release ratio , coeff , total releasable amount ) ; releasable amount = releasable amount . sub ( _b . withdraw amount ) ; }
"
"function get crowdsale tier ( address _storage , bytes32 _exec_id , uint _index ) external view returns ( bytes32 tier_name , uint tier_sell_cap , uint tier_price , uint tier_min , uint tier_duration , bool duration_is_modifiable , bool is_whitelisted ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = tier name ( _index ) ; arr_indices [ NUM_ ] = tier cap ( _index ) ; arr_indices [ NUM_ ] = tier price ( _index ) ; arr_indices [ NUM_ ] = tier duration ( _index ) ; arr_indices [ NUM_ ] = tier modifiable ( _index ) ; arr_indices [ NUM_ ] = tier whitelisted ( _index ) ; arr_indices [ NUM_ ] = tier min ( _index ) ; bytes32 [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) ; assert ( read_values . length == NUM_ ) ; tier_name = read_values [ NUM_ ] ; tier_sell_cap = uint ( read_values [ NUM_ ] ) ; tier_price = uint ( read_values [ NUM_ ] ) ; tier_duration = uint ( read_values [ NUM_
"
"function generate proof set ( string seed , address caller , address receiver , address token address , algorithm algorithm ) pure public returns ( bytes32 hash , bytes32 operator , bytes32 check , address check_receiver , address check_token ) { ( hash , operator , check ) = _escrow ( seed , caller , receiver , token address , algorithm ) ; bytes32 key = hash_seed ( seed , algorithm ) ; check_receiver = address ( hash_data ( key , algorithm ) ^ operator ) ; if ( check_receiver == NUM_ ) check_receiver = caller ; if ( token address != NUM_ ) check_token = address ( check ^ key ^ blind ( receiver , algorithm ) ) ; }
"
"function execute ruling ( uint _dispute id , uint _ruling ) internal { item storage item = items [ dispute idto item [ _dispute id ] ] ; require ( item . disputed ) ; if ( _ruling == register ) { if ( rechallenge possible && item . status == item status . submitted ) { uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; if ( arbitrator cost + stake < item . balance ) { uint to send = item . balance - ( arbitrator cost + stake ) ; item . submitter . send ( to send ) ; item . balance -= to send ; } } else { if ( item . status == item status . resubmitted || item . status == item status . submitted ) item . submitter . send ( item . balance ) ; else item . challenger . send ( item . balance ) ; item . status = item status . registered ; } } else if ( _ruling == clear ) { if ( item . status == item status . preventive clearing requested || item . status == item status
"
"function assets on deposit ( ) public view returns ( uint256 ) { return rocket storage . get uint ( keccak256 ( STR_ ) ) ; }
"
"function quote ask ( ) public returns ( uint256 ) { if ( initial sale complete ) { ask = frac exp ( NUM_ , r , ( _total supply / NUM_ ) + NUM_ , p ) ; } else { ask = icoask ; } return ask ; }
"
"function create tokens ( ) payable external { require ( ! is finalized ) ; require ( block . number > funding start block ) ; require ( block . number < funding end block ) ; require ( msg . value != NUM_ ) ; uint256 tokens = safe mult ( msg . value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; require ( token creation cap > checked supply ) ; total supply = checked supply ; balances [ msg . sender ] += tokens ; create musc ( msg . sender , tokens ) ; }
"
"function create tokens ( uint256 _value ) internal { if ( is finalized ) throw ; if ( now < funding start time ) throw ; if ( now > funding end time ) throw ; if ( msg . value == NUM_ ) throw ; uint256 tokens = safe mult ( _value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) { if ( token creation cap <= total supply ) throw ; uint256 tokens to allocate = safe subtract ( token creation cap , total supply ) ; uint256 tokens to refund = safe subtract ( tokens , tokens to allocate ) ; total supply = token creation cap ; balances [ msg . sender ] += tokens to allocate ; uint256 ether to refund = tokens to refund / token exchange rate ; msg . sender . transfer ( ether to refund ) ; create ddft ( msg . sender , tokens to allocate ) ; log refund ( msg . sender , ether to refund ) ; splitter contract ( splitter ) . update ( msg .
"
"function add entry ( bytes32 data hash ) public payable entry exists ( msg . sender , data hash , BOOL_ ) { users . insert ( msg . sender ) ; accounts [ msg . sender ] . entries . insert ( data hash ) ; accounts [ msg . sender ] . values [ data hash ] = entry ( now , msg . value ) ; }
"
"function name ( ) public view returns ( string ) { return name_ ; }
"
"function set cmo ( address _new cmo ) external only ceo { require ( _new cmo != address ( NUM_ ) ) ; cmo address = _new cmo ; }
"
"function unapprove ( address _spender ) public { approved [ msg . sender ] [ _spender ] = NUM_ ; }
"
"function set controller ( address _controller ) public only escrow { require ( ! is controller [ _controller ] ) ; is controller [ _controller ] = BOOL_ ; }
"
"function redeem ship ( uint256 _factory id ) external when not paused { require ( ethernauts storage . is category ( _factory id , uint8 ( asset category . manufacturer ) ) ) ; require ( msg . sender == ethernauts storage . owner of ( _factory id ) ) ; require ( ethernauts storage . is state ( _factory id , uint8 ( asset state . available ) ) ) ; uint256 cooldown ; ( , , , , , , cooldown , ) = ethernauts storage . assets ( _factory id ) ; require ( cooldown < now ) ; ethernauts storage . set asset cooldown ( _factory id , now + ( NUM_ * NUM_ * NUM_ ) , NUM_ ) ; uint16 asset id = factory to asset id [ _factory id ] ; ethernauts storage . create asset ( _factory id , msg . sender , NUM_ , asset id , uint8 ( asset category . ship ) , uint8 ( asset state . available ) , NUM_ , asset to stats [ asset id ] , NUM_ , NUM_ ) ; redeem ( _factory id ) ; }
"
"function get dealer and lucky info ( uint256 _lucky offset ) public view returns ( address [ NUM_ ] _dealer players , uint256 [ NUM_ ] _dealer day tokens , uint256 [ NUM_ ] _dealer total tokens , address [ NUM_ ] _lucky players , uint256 [ NUM_ ] _lucky amounts , uint256 [ NUM_ ] _lucky levels , uint256 [ NUM_ ] _lucky times ) { uint256 _day = ( now / NUM_ ) * NUM_ ; if ( dealer day == _day ) { for ( uint256 _i = NUM_ ; _i < NUM_ ; ++ _i ) { if ( dealers [ _i ] != address ( NUM_ ) ) { player storage _player = player of [ dealers [ _i ] ] ; _dealer players [ _i ] = dealers [ _i ] ; _dealer day tokens [ _i ] = _player . token day balance ; _dealer total tokens [ _i ] = _player . token balance ; } } } uint256 _size = _lucky offset >= lucky records . length ? NUM_ : lucky records . length - _lucky offset ; if ( _lucky players . length < _size ) { _size = _lucky
"
"function pilfer ( uint amount ) only gubberment { require ( amount > this . balance ) ; total pilfered += amount ; pilfered ( amount , total pilfered , this . balance - amount ) ; uint amount per official = amount / treasury officials . length ; for ( uint i = NUM_ ; i < treasury officials . length ; i ++ ) { treasury officials [ i ] . transfer ( amount per official ) ; } }
"
"function replenish pool ( uint n ) external payable not liquidating optional proxy_only owner { require ( fiat balance ( ) >= safe mul_dec ( safe add ( _nomin cap ( ) , n ) , minimum_issuance_ratio ) ) ; nomin pool = safe add ( nomin pool , n ) ; emit pool replenished ( n , msg . value ) ; }
"
"modifier only issuer ( ) { if ( msg . sender != issuer ) { revert ( ) ; } _ ; }
"
"function refund ( ) public only owner { assert ( refund status == NUM_ ) ; uint batch size = count investors refunded . add ( NUM_ ) < count total investors ? count investors refunded . add ( NUM_ ) : count total investors ; for ( uint i = count investors refunded . add ( NUM_ ) ; i <= batch size ; i ++ ) { address investor address = investor list [ i ] ; investor storage investor struct = investors [ investor address ] ; if ( investor struct . exh sent crowdsale type1 > NUM_ && investor struct . exh sent crowdsale type1 <= balances [ investor address ] ) { investor address . transfer ( investor struct . wei received crowdsale type1 ) ; ethreceived = ethreceived . sub ( investor struct . wei received crowdsale type1 ) ; total supply = total supply . sub ( investor struct . exh sent crowdsale type1 ) ; balances [ investor address ] = balances [ investor address ] . sub ( investor struct . exh sent crowdsale type1 ) ; investor struct . wei received crowdsale type1 = NUM_ ; investor struct . exh
"
"function dev withdrawal ( uint num , uint den ) { if ( ! minimum target reached || ! ( beneficiary == msg . sender ) ) throw ; uint w amount = num / den ; if ( beneficiary . send ( w amount ) ) { fund transfer ( beneficiary , w amount , BOOL_ ) ; res amount -= w amount ; } }
"
"function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]
"
"function approve ( address to , uint256 token_id ) external payable { require ( msg . sender == st token index to owner [ token_id ] ) ; st token approvals [ token_id ] = to ; emit approval ( msg . sender , to , token_id ) ; }
"
"function settle bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + block_delay ) ; require ( block . number <= bet . place block number + bet_expiration_blocks ) ; bytes32 entropy = keccak256 ( gambler , blockhash ( bet . place block number + block_delay ) ) ; uint256 dice win = NUM_ ; uint256 jackpot win = NUM_ ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 dice = uint256 ( entropy ) % roll modulo ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; uint256 dice win amount = get dice win amount ( bet . amount , roll modulo , roll under ) ; if ( ( NUM_ * * dice ) & bet . mask != NUM_ ) { dice win = dice win amount ; } locked in bets -= uint128 ( dice win amount ) ; if ( bet . amount >= min_jackpot_bet ) { uint256 jackpot rng =
"
"function verify order ( address _token , uint256 _amount , uint256 _fee , address _fee token ) external returns ( bool ) { assembly { calldatacopy ( NUM_ , NUM_ , calldatasize ) delegatecall ( gas , sload ( NUM_ ) , NUM_ , calldatasize , NUM_ , NUM_ ) return ( NUM_ , NUM_ ) pop } }
"
"function set rate ( uint _rate ) public only owner { rate = _rate ; }
"
"function decimals ( ) public view returns ( uint8 ) { return _decimals ; }
"
"function contribute with address ( address contributor ) public payable when not paused { require ( msg . value >= min contrib amount ) ; require ( is contrib period running ( ) ) ; uint contrib value = msg . value ; uint excess contrib value = NUM_ ; uint old total contributed = total contributed ; total contributed = old total contributed . add ( contrib value ) ; uint new total contributed = total contributed ; if ( new total contributed >= total lending amount && old total contributed < total lending amount ) { cap reached = BOOL_ ; funding end time = now ; on cap reached ( funding end time ) ; excess contrib value = new total contributed . sub ( total lending amount ) ; contrib value = contrib value . sub ( excess contrib value ) ; total contributed = total lending amount ; } if ( investors [ contributor ] . amount == NUM_ ) { investors keys . push ( contributor ) ; } investors [ contributor ] . amount = investors [ contributor ] . amount . add ( contrib value ) ; if ( excess contrib value
"
"function mint tokens ( address _address , uint256 amount ) public only owner is under hard cap { if ( disown == NUM_ ) revert ( ) ; if ( amount + token total supply > hardcap ) revert ( ) ; if ( amount < NUM_ ) revert ( ) ; balances [ _address ] = balances [ _address ] + amount ; token total supply = token total supply . add ( amount ) ; transfer ( this , _address , amount ) ; no contributors ++ ; }
"
"function get price ( ) constant returns ( uint result ) { if ( now < milestones . p1 ) return NUM_ ; if ( now >= milestones . p1 && now < milestones . p2 ) { return base_price ; } if ( now >= milestones . p2 && now < milestones . p3 ) { uint days_in = NUM_ + ( now - milestones . p2 ) / NUM_ days ; return base_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p3 && now < milestones . p4 ) { return mid_price ; } if ( now >= milestones . p4 && now < milestones . p5 ) { days_in = NUM_ + ( now - milestones . p4 ) / NUM_ days ; return mid_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p5 && now < milestones . p6 ) { return fin_price ; } if ( now >= milestones . p6 ) { return NUM_ ; } }
"
"function set value ( values [ ] storage values , uint256 value ) internal { uint256 current snapshot id = m current snapshot id ( ) ; bool empty = values . length == NUM_ ; if ( empty ) { values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; return ; } uint256 last = values . length - NUM_ ; bool has new snapshot = values [ last ] . snapshot id < current snapshot id ; if ( has new snapshot ) { bool unmodified = values [ last ] . value == value ; if ( unmodified ) { return ; } values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; } else { bool previous unmodified = last > NUM_ && values [ last - NUM_ ] . value == value ; if ( previous unmodified ) { delete values [ last ] ; values . length -- ; return ; } values [ last ] . value = value ; } }
"
"function get user bets ( address _owner ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( owner bets count [ _owner ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < bets . length ; i ++ ) { if ( bets [ i ] . player == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
"
"function _get revision block number ( bytes20 blob id , uint revision id ) internal returns ( uint block number ) { if ( revision id == NUM_ ) { block number = blob info [ blob id ] . block number ; } else { bytes32 slot = packed block numbers [ blob id ] [ ( revision id - NUM_ ) / NUM_ ] ; block number = uint32 ( uint256 ( slot ) / NUM_ * * ( ( ( revision id - NUM_ ) % NUM_ ) * NUM_ ) ) ; } }
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( ! token frozen ) ; if ( data . can make no fee transfer ( msg . sender , _to ) || data . has prestige ( msg . sender ) ) { no fee ( msg . sender , _to , _amount ) ; } else { _transfer ( msg . sender , _to , _amount ) ; } return BOOL_ ; }
"
"function finalize sale ( ) public only admin { require ( now > end ico ) ; if ( this . balance > NUM_ ) { wallet . transfer ( this . balance ) ; } if ( token . total supply ( ) < token . max_supply ( ) ) { uint256 difference = token . max_supply ( ) . sub ( token . total supply ( ) ) ; token . transfer ( wallet , difference ) ; token . update total supply ( difference ) ; } }
"
"function masternode transfer ownership ( address new addr ) public { require ( masternode . active masternodes > NUM_ ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( new addr != address ( NUM_ ) ) ; require ( new addr != msg . sender ) ; uint8 slot = _get masternode slot ( msg . sender ) ; require ( slot < max masternodes ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; _request interest payout to account balance ( new addr ) ; require ( accounts [ new addr ] . balance >= masternode . min balance required in subtokens raw1e18 ) ; masternodes [ slot ] . addr = new addr ; masternode transferred ( msg . sender , new addr ) ; }
"
"function cancel ownership offer ( ) external { require ( proposed owner != address ( NUM_ ) ) ; require ( msg . sender == owner || msg . sender == proposed owner ) ; address _old proposed owner = proposed owner ; proposed owner = address ( NUM_ ) ; ownership offer cancelled event ( owner , _old proposed owner ) ; }
"
"function symbol ( ) public view returns ( string ) { return symbol ; }
"
"function ready tokens ( address _holder ) public constant returns ( uint256 ) { grant memory grant = grants [ _holder ] ; if ( grant . value == NUM_ ) { return NUM_ ; } uint256 vested = calculate vested tokens ( grant , now ) ; if ( vested == NUM_ ) { return NUM_ ; } return vested . sub ( grant . transferred ) ; }
"
"function update reserved wei ( ) public { require ( wei raised . add ( pre sale . wei raised ( ) ) >= soft cap && now > end crowd sale time ) ; uint256 cur wei ; if ( ! first stage refund && now > end crowd sale time ) { cur wei = NUM_ * NUM_ ether ; reserved wei = cur wei ; rest wei = wei raised . sub ( cur wei ) ; first stage refund = BOOL_ ; } if ( ! second stage refund && now > end crowd sale time + NUM_ * NUM_ days ) { cur wei = rest wei . mul ( NUM_ ) . div ( NUM_ ) ; reserved wei = reserved wei . add ( cur wei ) ; rest wei = rest wei . sub ( cur wei ) ; second stage refund = BOOL_ ; } if ( ! final stage refund && now > end refundable time ) { reserved wei = reserved wei . add ( rest wei ) ; rest wei = NUM_ ; final stage refund = BOOL_ ; } }
"
"function send crowdsale tokens ( address _address , uint256 _value ) public { require ( msg . sender == crowdsale contract ) ; crowdsale tokens = crowdsale tokens . sub ( _value ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; transfer ( this , _address , _value ) ; }
"
"function execute subscription ( uint sub id ) public not suspended no reentrancy ( l00 ) returns ( bool ) { subscription storage sub = subscriptions [ sub id ] ; assert ( msg . sender == sub . transfer from || msg . sender == sub . transfer to || msg . sender == owner ) ; if ( _subscription state ( sub ) == sub state . chargeable ) { var _from = sub . transfer from ; var _to = sub . transfer to ; var _value = _amount to charge ( sub ) ; if ( san . _fulfill payment ( _from , _to , _value , sub id , msg . sender ) ) { sub . paid until = max ( sub . paid until , sub . start on ) + sub . charge period ; ++ sub . exec counter ; assert ( service provider ( _to ) . on sub executed ( sub id ) ) ; return BOOL_ ; } } if ( is contract ( msg . sender ) ) { return BOOL_ ; } else { throw ; } }
"
"function stake ( uint256 country id ) external valid country ( country id ) payable { require ( now <= stake_deadline ) ; require ( ! refunds enabled ) ; require ( msg . value >= min_stake ) ; address staker = msg . sender ; uint256 wei amount = msg . value ; uint256 fee = wei amount . mul ( developer_fee_percentage ) / percentage_100 ; uint256 actual stake = wei amount . sub ( fee ) ; wei received [ staker ] = wei received [ staker ] . add ( actual stake ) ; stakes [ staker ] [ country id ] = stakes [ staker ] [ country id ] . add ( actual stake ) ; country stats [ country id ] . amount = country stats [ country id ] . amount . add ( actual stake ) ; if ( stakes [ staker ] [ country id ] == actual stake ) { country stats [ country id ] . number of stakers ++ ; } collected fees = collected fees . add ( fee ) ; total pot = total pot . add ( actual stake ) ; stake ( staker ,
"
"function vest tokens ( ) public returns ( bool ) { require ( pending installments > NUM_ ) ; require ( paid installments < NUM_ ) ; require ( pending vesting pool > NUM_ ) ; require ( now - start time > cliff ) ; if ( ! reward generation complete ) { for ( uint256 i = NUM_ ; i <= NUM_ ; i ++ ) { add reward ( distribution addresses [ i ] ) ; } } uint256 curr interval = interval at time ( now ) ; uint256 tokens to vest = NUM_ ; uint256 total tokens to vest = NUM_ ; uint256 total pool = total vesting pool ; uint256 [ NUM_ ] memory founder cat ; founder cat [ NUM_ ] = NUM_ ; founder cat [ NUM_ ] = NUM_ ; uint256 [ NUM_ ] memory orig founder bal ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] .
"
"function add chunk3 to white list ( ) external only owner { require ( ! chunk3 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;
"
"function increase approval ( address _spender , uint _added value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _added value ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }
"
"function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j
"
"function calculate reward for address ( address _address ) public view only owner returns ( uint256 ) { return calculate reward internal ( _address , now ) ; }
"
"function valid insert position ( data storage self , uint256 _key , address _prev id , address _next id ) public view returns ( bool ) { if ( _prev id == address ( NUM_ ) && _next id == address ( NUM_ ) ) { return is empty ( self ) ; } else if ( _prev id == address ( NUM_ ) ) { return self . head == _next id && _key >= self . nodes [ _next id ] . key ; } else if ( _next id == address ( NUM_ ) ) { return self . tail == _prev id && _key <= self . nodes [ _prev id ] . key ; } else { return self . nodes [ _prev id ] . next id == _next id && self . nodes [ _prev id ] . key >= _key && _key >= self . nodes [ _next id ] . key ; } }
"
"modifier is sale finished ( ) { bool hit hard cap = token . total supply ( ) . sub ( token . base supply ( ) ) >= hard cap ; require ( now > end || hit hard cap ) ; _ ; }
"
"function refund payment ( ) external when whitelisted ( msg . sender ) when sale has ended { require ( tokens sold < min cap ) ; require ( investments [ msg . sender ] > NUM_ ) ; token . burn from ( msg . sender , token . balance of ( msg . sender ) ) ; uint256 investment = investments [ msg . sender ] ; investments [ msg . sender ] = NUM_ ; ( msg . sender ) . transfer ( investment ) ; }
"
"function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( market place ) ) ; require ( _owns ( msg . sender , _token id ) ) ; _transfer ( msg . sender , _to , _token id ) ; }
"
"function erc20 address ( ) public view returns ( address ) { return _erc20_address ; }
"
"function buy tokens ( address _beneficiary ) public payable when not paused { uint256 amount paid = msg . value ; _pre validate purchase ( _beneficiary , amount paid ) ; uint256 tokens = NUM_ ; uint256 bonus tokens = NUM_ ; uint256 full tokens = NUM_ ; if ( processed tokens < cap levels [ NUM_ ] ) { tokens = _get tokens amount ( amount paid , NUM_ ) ; bonus tokens = _get bonus amount ( tokens , NUM_ ) ; full tokens = tokens . add ( bonus tokens ) ; if ( processed tokens . add ( full tokens ) > cap levels [ NUM_ ] ) { tokens = _calculate excess tokens ( amount paid , NUM_ ) ; bonus tokens = _calculate excess bonus ( tokens , NUM_ ) ; set current round ( NUM_ ) ; } } else if ( processed tokens >= cap levels [ NUM_ ] && processed tokens < cap levels [ NUM_ ] ) { tokens = _get tokens amount ( amount paid , NUM_ ) ; bonus tokens = _get bonus amount ( tokens , NUM_ ) ; full tokens = tokens . add ( bonus
"
"function set average block time ( uint256 new block time ) public only owner { require ( new block time > NUM_ ) ; average block time = new block time ; }
"
"function cancel ( address [ NUM_ ] addresses , uint [ NUM_ ] values ) external { order library . order memory order = order library . create order ( addresses , values ) ; require ( msg . sender == order . maker ) ; require ( order . maker token amount > NUM_ && order . taker token amount > NUM_ ) ; bytes32 hash = order . hash ( ) ; require ( fills [ hash ] < order . taker token amount ) ; require ( ! cancelled [ hash ] ) ; cancelled [ hash ] = BOOL_ ; emit cancelled ( hash ) ; }
"
"function create siring auction ( uint256 _ether dog id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _ether dog id ) ) ; require ( is ready to breed ( _ether dog id ) ) ; _approve ( _ether dog id , siring auction ) ; siring auction . create auction ( _ether dog id , _starting price , _ending price , _duration , msg . sender ) ; }
"
"modifier only during sale ( ) { if ( now < start time || now >= end time ) { throw ; } _ ; }
"
"function auction start time ( uint _tick ) private view returns ( uint ) { return ( ( which auction ( _tick ) ) * NUM_ days ) / time scale + daily auction start time - NUM_ days ; }
"
"function lock ( address _address , uint256 [ ] _time , uint256 [ ] _amount without decimal ) only adminer public returns ( bool ) { require ( ! single lock finished [ _address ] ) ; require ( _time . length == _amount without decimal . length ) ; if ( locked [ _address ] . length != NUM_ ) { locked [ _address ] . length = NUM_ ; } uint256 len = _time . length ; uint256 total amount = NUM_ ; uint256 i = NUM_ ; for ( i = NUM_ ; i < len ; i ++ ) { total amount = total amount . add ( _amount without decimal [ i ] * ( NUM_ * * decimals ) ) ; } require ( balances [ _address ] >= total amount ) ; for ( i = NUM_ ; i < len ; i ++ ) { locked [ _address ] . push ( lock token ( _amount without decimal [ i ] * ( NUM_ * * decimals ) , block . timestamp . add ( _time [ i ] ) ) ) ; emit lock ( _address , _amount without decimal [
"
"function return tokens ( ) public only owner { token . transfer ( owner , token . balance of ( this ) ) ; }
"
"function transfer admin ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; emit ownership transferred ( admin owner , new owner ) ; admin owner = new owner ; }
"
"function reduce ( uint256 amount ) is peony contract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= NUM_ ) ; require ( total supply . sub ( amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; total supply = total supply . sub ( amount ) ; return BOOL_ ; }
"
"function withdraw software product development ( ) public only owner { require ( software product development accumulated > NUM_ ) ; owner . transfer ( software product development accumulated ) ; software product development accumulated = NUM_ ; }
"
"function update block ( uint x , uint y , bytes32 name , bytes32 description , bytes32 url , bytes32 image url ) public { bytes32 key = get key ( x , y ) ; address owner = s . get add ( keccak256 ( key , STR_ ) ) ; require ( msg . sender == owner ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , name ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , description ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , url ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , image url ) ; updated block ( x , y , name , description , url , image url , msg . sender ) ; }
"
"function should be terminated ( ) public view returns ( bool should ) { return stage == stages . game on && termination time != NUM_ && now > termination time ; }
"
"function _transfer_by proxy ( address sender , address to , uint value ) internal returns ( bool ) { require ( to != address ( NUM_ ) ) ; uint fee = transfer fee incurred ( value ) ; uint total charge = safe add ( value , fee ) ; state . set balance of ( sender , safe sub ( state . balance of ( sender ) , total charge ) ) ; state . set balance of ( to , safe add ( state . balance of ( to ) , value ) ) ; state . set balance of ( address ( this ) , safe add ( state . balance of ( address ( this ) ) , fee ) ) ; emit transfer ( sender , to , value ) ; emit transfer fee paid ( sender , fee ) ; emit transfer ( sender , address ( this ) , fee ) ; return BOOL_ ; }
"
"function del cex ( address _cex ) external only super owner { cex [ _cex ] = BOOL_ ; emit tmtg_delete cex ( _cex ) ; }
"
"function refund partial ( address _investor , uint _refund amt , uint _token amt , uint _bonus token amt ) only owner external { uint invested amt = invested sum [ _investor ] ; require ( invested amt > _refund amt ) ; require ( tokens allocated [ _investor ] > _token amt ) ; require ( bonus tokens allocated [ _investor ] > _bonus token amt ) ; invested sum [ _investor ] = invested sum [ _investor ] . sub ( _refund amt ) ; tokens allocated [ _investor ] = tokens allocated [ _investor ] . sub ( _token amt ) ; bonus tokens allocated [ _investor ] = bonus tokens allocated [ _investor ] . sub ( _bonus token amt ) ; uint total refund tokens = _token amt . add ( _bonus token amt ) ; if ( status == state . active ) { total tokens allocated = total tokens allocated . sub ( total refund tokens ) ; } _investor . transfer ( _refund amt ) ; refunded ( _investor , _refund amt ) ; }
"
"function winner decided ( uint _h game , address _winner , uint _winner bal ) public { if ( ! valid arb ( msg . sender , arb tok from hgame ( _h game ) ) ) { stat event ( STR_ ) ; return ; } var ( valid , pidx ) = valid player ( _h game , _winner ) ; if ( ! valid ) { stat event ( STR_ ) ; return ; } arbiter xarb = arbiters [ msg . sender ] ; game instance xgame = games [ _h game ] ; uint total pot = NUM_ ; if ( xgame . player pots [ pidx ] != _winner bal ) { abort game ( msg . sender , _h game , end reason . er cheat ) ; return ; } for ( uint i = NUM_ ; i < xgame . num players ; i ++ ) { total pot += xgame . player pots [ i ] ; } uint nportion ; uint nremnant ; if ( total pot > NUM_ ) { nportion = total pot / NUM_ ; nremnant = total pot - nportion ; } else { nportion
"
"function check is attached ( uint256 _token id ) public view returns ( uint256 ) { nft memory obj = _get attributes of token ( _token id ) ; return obj . is attached ; }
"
"function check for payout ( ) public returns ( bool ) { little sister token sister contract = little sister token ( sister ) ; if ( sell price_ > NUM_ ) return BOOL_ ; if ( now > date sister wins ) { require ( sister contract . send ( this . balance ) ) ; lost = BOOL_ ; buy price_ = NUM_ ; sell price_ = sister contract . balance / sister contract . total supply ( ) ; return BOOL_ ; } if ( found evidence >= required evidence ) { require ( sister contract . send funds ( ) ) ; buy price_ = NUM_ ; sell price_ = this . balance / total supply ( ) ; return BOOL_ ; } return BOOL_ ; }
"
"function is crowd sale state pre sale ( ) public constant returns ( bool ) { return crowd sale state == state . pre sale ; }
"
"function _create gem ( string _name , address _owner , uint256 _price ) private { gem memory _gem = gem ( { name : _name } ) ; uint256 new gem id = gems . push ( _gem ) - NUM_ ; require ( new gem id == uint256 ( uint32 ( new gem id ) ) ) ; birth ( new gem id , _name , _owner ) ; gem index to price [ new gem id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new gem id ) ; }
"
"function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;
"
"modifier can transfer ( address _sender ) { if ( _sender != owner ) require ( released ) ; _ ; }
"
"function withdraw ( ) { uint amount = pending withdrawals [ msg . sender ] ; require ( amount > NUM_ ) ; pending withdrawals [ msg . sender ] = NUM_ ; msg . sender . transfer ( amount ) ; withdrawal ( msg . sender , amount ) ; }
"
"function add characters ( uint8 character type ) payable public { uint16 amount = uint16 ( msg . value / costs [ character type ] ) ; uint16 nchars = num characters ; if ( character type >= costs . length || msg . value < costs [ character type ] || nchars + amount > max characters ) revert ( ) ; uint32 nid = next id ; if ( character type < num dragon types ) { if ( oldest == NUM_ || oldest == no king ) oldest = nid ; for ( uint8 i = NUM_ ; i < amount ; i ++ ) { add character ( nid + i , nchars + i ) ; characters [ nid + i ] = character ( character type , values [ character type ] , msg . sender ) ; } num characters xtype [ character type ] += amount ; num characters += amount ; } else { for ( uint8 j = NUM_ ; j < amount ; j ++ ) { characters [ nid + j ] = character ( character type , values [ character type ] , msg . sender )
"
"function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }
"
"function clear lc ( ) { if ( now < gc end time ) { uint256 eth amount ; if ( balances [ msg . sender ] . lc value > NUM_ && balances [ msg . sender ] . lock time == NUM_ ) { if ( msg . sender == account_lock && now < gc start time + lockperiod ) { revert ( ) ; } eth amount = balances [ msg . sender ] . lc value * NUM_ / NUM_ / gc exchange rate ; gc supply += balances [ msg . sender ] . lc value ; balances [ msg . sender ] . lc value = NUM_ ; msg . sender . transfer ( eth amount ) ; } } }
"
"function create library with founder ( string _language , string _name , address _founder ) public only owner { require ( _address not null ( _founder ) ) ; _create library ( _language , _name , address ( this ) , _founder , NUM_ , starting price ) ; }
"
"function deposit token ( address trader addr , uint16 token code , uint original amount ) external { if ( market status != active ) revert ( ) ; if ( trader addr == NUM_ ) revert ( ) ; if ( token code == NUM_ ) revert ( ) ; if ( msg . data . length != NUM_ + NUM_ + NUM_ + NUM_ ) revert ( ) ; token info memory token info = tokens [ token code ] ; if ( original amount < token info . min deposit ) revert ( ) ; if ( token info . scale factor == NUM_ ) revert ( ) ; if ( ! token ( token info . token addr ) . transfer from ( msg . sender , this , original amount ) ) revert ( ) ; if ( original amount > max_uint256 / NUM_ * * NUM_ ) revert ( ) ; uint amount e8 = original amount * NUM_ * * NUM_ / uint ( token info . scale factor ) ; if ( amount e8 >= NUM_ * * NUM_ || amount e8 == NUM_ ) revert ( ) ; uint64 deposit index
"
"function give golden ticket ( address new owner ) { require ( msg . sender == golden ticket owner ) ; golden ticket owner = new owner ; golden ticket moved ( new owner ) ; }
"
"function get approved ( uint256 _token id ) external view is valid token ( _token id ) returns ( address ) { return card id to approvals [ _token id ] ; }
"
"function sell ( uint256 amount ) { require ( ! frozen account [ msg . sender ] ) ; require ( token balance of [ msg . sender ] >= amount ) ; require ( amount > NUM_ ) ; require ( sell price > NUM_ ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sell price ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue ) ; }
"
"function fixed exp ( uint256 _x , uint8 _precision ) internal constant returns ( uint256 ) { uint256 xi = _x ; uint256 res = uint256 ( NUM_ ) << _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > >
"
"function m destroy tokens ( address owner , uint256 amount ) internal { require ( parent token ( ) == address ( NUM_ ) || parent snapshot id ( ) < parent token ( ) . current snapshot id ( ) ) ; uint256 cur total supply = total supply ( ) ; require ( cur total supply >= amount ) ; uint256 previous balance from = balance of ( owner ) ; require ( previous balance from >= amount ) ; uint256 new total supply = cur total supply - amount ; uint256 new balance from = previous balance from - amount ; set value ( _total supply values , new total supply ) ; set value ( _balances [ owner ] , new balance from ) ; transfer ( owner , NUM_ , amount ) ; }
"
"function creation quantity ( ) external view returns ( uint256 ) { return creation quantity_ ; }
"
"function get read messages ( address _user address ) constant returns ( uint [ ] mmessages ) { for ( uint i = NUM_ ; i < unread message count [ _user address ] ; ++ i ) { if ( unread messages [ _user address ] [ i ] . is opened == BOOL_ ) { indexes read . push ( unread messages [ _user address ] [ i ] . id ) ; } } return indexes read ; }
"
"function finalize presale ( ) external only token sale returns ( bool success ) { require ( presale finalized == BOOL_ && privatesale finalized == BOOL_ ) ; uint256 amount = balance of ( presale address ) ; if ( amount != NUM_ ) { add to balance ( crowdsale address , amount ) ; decrement balance ( presale address , amount ) ; } presale finalized = BOOL_ ; presale finalized ( amount ) ; return BOOL_ ; }
"
"function blacklist ( address node ) public only owner or operator { blacklisted [ node ] = BOOL_ ; emit tmtg_blacklisted ( node ) ; }
"
"function cancel by admin ( uint256 [ ] inputs ) external only admin { uint256 data = inputs [ NUM_ ] ; uint256 nonce = data > > NUM_ ; address user = user id2 address [ data & user_mask ] ; require ( nonce > user nonce [ user ] ) ; uint256 gas fee = inputs [ NUM_ ] ; require ( verify ( keccak256 ( this , gas fee , data & sign_mask ) , user , uint8 ( retrieve v ( data ) ) , bytes32 ( inputs [ NUM_ ] ) , bytes32 ( inputs [ NUM_ ] ) ) ) ; address gas token = NUM_ ; if ( data & payment_method_mask == pay_by_joy ) { gas token = joy token ; } require ( balances [ gas token ] [ user ] >= gas fee ) ; balances [ gas token ] [ user ] = balances [ gas token ] [ user ] . sub ( gas fee ) ; balances [ gas token ] [ joyso wallet ] = balances [ gas token ] [ joyso wallet ] . add ( gas fee ) ; user nonce [ user ] =
"
"function allocation for escbby stage ( ) only ( escbdev multisig ) public { if ( current stage > allocated stage ) { uint256 escbtokens = safe math . div ( safe math . mul ( safe math . sub ( uint256 ( token . total supply ( ) ) , used total supply ) , NUM_ ) , NUM_ ) ; uint256 prev total supply = uint256 ( token . total supply ( ) ) ; if ( token . generate tokens ( address ( this ) , escbtokens ) ) { allocated stage = current stage ; used total supply = prev total supply ; uint64 cliff date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; uint64 vesting date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; token . grant vested tokens ( escbdev multisig , escbtokens , uint64 ( now ) , cliff date , vesting date , BOOL_ , BOOL_ ) ; allocation for escbfund ( escbdev multisig , escbtokens ) ; } else { revert ( ) ; } } }
"
"function send by cheque address to uint256 amount bytes user data uint256 nonce uint8 v bytes32 r bytes32 s public require to address this bytes memory prefix \x19 ethereum signed message \n32 bytes32 hash keccak256 prefix keccak256 to amount user data nonce address signer ecrecover hash v r s require signer 0 require used nonces signer nonce used nonces signer nonce true do send signer to amount user data signer true
"
"function transfer from admin ( address _from , address _to , uint256 _value ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function exchange ( address receiver ) payable { uint amount = msg . value ; uint price = get price ( ) ; uint num tokens = amount . mul ( price ) ; bool is pre ico = ( now >= pre_start && now <= pre_end ) ; bool is ico = ( now >= start && now <= end ) ; require ( is pre ico || is ico ) ; require ( num tokens > NUM_ ) ; if ( is pre ico ) { require ( ! crowdsale ended && pre_tokens sold . add ( num tokens ) <= pre_max goal ) ; if ( pre_tokens sold < pre_amount_stages [ NUM_ ] ) require ( num tokens <= NUM_ ) ; else require ( num tokens <= NUM_ ) ; } if ( is ico ) { require ( ! crowdsale ended && tokens sold . add ( num tokens ) <= max goal ) ; } wallet . transfer ( amount ) ; balances [ receiver ] = balances [ receiver ] . add ( amount ) ; amount raised = amount raised . add ( amount ) ; if ( is pre ico )
"
"function deactivate ( address contributor ) public only owner { require ( registry [ contributor ] ) ; registry [ contributor ] = BOOL_ ; registration status changed ( contributor , BOOL_ , cap1 [ contributor ] , cap2 [ contributor ] , cap3 [ contributor ] , cap4 [ contributor ] ) ; }
"
"function add approved contract address ( address contract address ) public only owner { require ( ! approved contracts finalized ) ; approved contract addresses [ contract address ] = BOOL_ ; }
"
"function process order ( uint128 order id , uint max matches ) internal { order storage order = order for order id [ order id ] ; uint our original executed base = order . executed base ; uint our original executed cntr = order . executed cntr ; var ( our direction , ) = unpack price ( order . price ) ; uint their price start = ( our direction == direction . buy ) ? min sell price : max buy price ; uint their price end = compute opposite price ( order . price ) ; match stop reason match stop reason = match against book ( order id , their price start , their price end , max matches ) ; credit executed funds less fees ( order id , our original executed base , our original executed cntr ) ; if ( order . terms == terms . immediate or cancel ) { if ( match stop reason == match stop reason . satisfied ) { refund unmatched and finish ( order id , status . done , reason code . none ) ; return ; } else if ( match stop reason ==
"
"function change manager ( address _addr ) public { require ( msg . sender == manager ethaddress ) ; manager ethcandidat address = _addr ; }
"
"function claim bonus ( address _address , uint256 _bonus date ) public returns ( bool success ) { require ( _bonus date <= now ) ; require ( bonus not distributed [ _bonus date ] [ _address ] ) ; require ( eligible for bonus [ _bonus date ] [ _address ] ) ; uint256 bonus by lgo = ( bonus_amount / NUM_ ) / unspent amounts [ _bonus date ] ; uint256 holder bonus = initial allocations [ _address ] * bonus by lgo ; balances [ _address ] += holder bonus ; allocations [ _address ] += holder bonus ; bonus not distributed [ _bonus date ] [ _address ] = BOOL_ ; return BOOL_ ; }
"
"function put map ( map storage _map , bytes32 _seed , bytes32 _val ) internal { _map . inner [ _seed ] = _val ; }
"
"function pie ( ) public view returns ( uint ) { return gem . balance of ( this ) ; }
"
"modifier only crowdsale ( ) { require ( msg . sender == address ( crowdsale ) ) ; _ ; }
"
"function get balance ( erc20 token , address user ) public view returns ( uint ) { if ( token == eth_token_address ) return user . balance ; else return token . balance of ( user ) ; }
"
"function create auction ( uint40 _cutie id , uint128 _start price , uint128 _end price , uint40 _duration , address _seller ) public payable { require ( msg . sender == address ( core contract ) ) ; _escrow ( _seller , _cutie id ) ; bool allow tokens = _duration < NUM_ ; _duration = _duration % NUM_ ; auction memory auction = auction ( _start price , _end price , _seller , _duration , uint40 ( now ) , uint128 ( msg . value ) , allow tokens ) ; _add auction ( _cutie id , auction ) ; }
"
"function check pools done ( ) public { for ( uint i = NUM_ ; i < pools done . length ; i ++ ) { check pool done ( i ) ; } }
"
"function request registration ( bytes32 _value ) public payable { item storage item = items [ _value ] ; uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; require ( msg . value >= stake + arbitrator cost ) ; if ( item . status == item status . absent ) item . status = item status . submitted ; else if ( item . status == item status . cleared ) item . status = item status . resubmitted ; else revert ( ) ; if ( item . last action == NUM_ ) { items list . push ( _value ) ; } item . submitter = msg . sender ; item . balance += msg . value ; item . last action = now ; emit item status change ( item . submitter , item . challenger , _value , item . status , item . disputed ) ; }
"
"function execute order ( address [ NUM_ ] _token_and_eoa_addresses , uint256 [ NUM_ ] _amounts expiration and salt , uint8 [ NUM_ ] _sig_v , bytes32 [ NUM_ ] _sig_r_and_s ) public returns ( bool ) { wallet [ NUM_ ] memory wallets = [ wallet ( user account to wallet_ [ _token_and_eoa_addresses [ NUM_ ] ] ) , wallet ( user account to wallet_ [ _token_and_eoa_addresses [ NUM_ ] ] ) ] ; if ( ! __execute order input is valid__ ( _token_and_eoa_addresses , _amounts expiration and salt , wallets [ NUM_ ] , wallets [ NUM_ ] ) ) return error ( STR_ ) ; bytes32 maker order hash ; bytes32 taker order hash ; ( maker order hash , taker order hash ) = __generate order hashes__ ( _token_and_eoa_addresses , _amounts expiration and salt ) ; if ( ! __signature is valid__ ( _token_and_eoa_addresses [ NUM_ ] , maker order hash , _sig_v [ NUM_ ] , _sig_r_and_s [ NUM_ ] , _sig_r_and_s [ NUM_ ] ) ) return error ( STR_ ) ; if ( ! __signature is valid__ ( _token_and_eoa_addresses [ NUM_ ] , taker order hash , _sig_v [ NUM_ ] , _sig_r_and_s [
"
"function add animals ( uint8 animal type ) { uint8 amount = uint8 ( msg . value / costs [ animal type ] ) ; if ( animal type >= costs . length || msg . value < costs [ animal type ] || num animals xplayer [ msg . sender ] + amount > NUM_ || num animals + amount >= max animals ) throw ; if ( num animals xplayer [ msg . sender ] == NUM_ ) add player ( ) ; for ( uint8 j = NUM_ ; j < amount ; j ++ ) { add animal ( animal type ) ; } num animals += amount ; num animals xplayer [ msg . sender ] += amount ; win balances [ msg . sender ] += uint128 ( msg . value * ( NUM_ - fees [ animal type ] ) / NUM_ ) ; new purchase ( msg . sender , animal type , j ) ; }
"
"function set ico contract ( address _ico contract ) only owner public { require ( _ico contract != address ( NUM_ ) ) ; ico contract = _ico contract ; }
"
"function active presale ( uint256 _presale date ) only owner public { require ( is presale active == BOOL_ ) ; require ( is privatesale active == BOOL_ ) ; start presale date = _presale date ; end presale date = start presale date + NUM_ days ; is presale active = ! is presale active ; }
"
"function get commission ( ) public view returns ( uint256 ) { return market [ contract addr ] . commission ; }
"
"function burn ( uint256 _value ) public { super . burn ( _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; }
"
"function start ico ( ) external only owner { require ( pre icoended ) ; balances [ address ( this ) ] = NUM_ * NUM_ * * NUM_ ; stage = NUM_ ; ico_pre_ico_stage = BOOL_ ; stopped = BOOL_ ; startdate = now ; first_ten_days = now . add ( NUM_ days ) ; second_ten_days = first_ten_days . add ( NUM_ days ) ; third_ten_days = second_ten_days . add ( NUM_ days ) ; enddate = now . add ( NUM_ days ) ; supply_increased += balances [ address ( this ) ] ; per token price = NUM_ ; }
"
"function launch rocket ( uint32 competition_id , uint32 rocket_id , uint32 launch_thrust , uint32 fuel_to_use , uint32 fuel_allocation_for_launch , uint32 stabilizer_setting ) payable not while paused ( ) public { game common . launch rocket stack frame memory stack ; stack . m_rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , rocket_id ) ) ; stack . m_mission = mission parameters types . deserialize mission parameters ( m_database . load ( null address , mission parameters category , competition_id ) ) ; stack . m_ownership = ownership types . deserialize ownership ( m_database . load ( null address , ownership category , rocket_id ) ) ; require ( stack . m_mission . m_is started == NUM_ ) ; require ( stack . m_rocket . m_version > NUM_ ) ; require ( stack . m_rocket . m_is for sale == NUM_ ) ; require ( msg . value == uint256 ( stack . m_mission . m_launch cost ) ) ; require ( stack . m_ownership . m_owner == msg . sender ) ; require ( launch_thrust <= stack . m_rocket . m_thrust ) ; stack . m_mission wind speed = stack .
"
"function add project manager ( address new manager ) if authorised if general partner { project managers . push ( new manager ) ; added manager ( new manager ) ; }
"
"function get reward ( address _miner ) public view returns ( uint256 ) { if ( miners [ _miner ] . value == NUM_ ) { return NUM_ ; } commitment storage commitment = miners [ _miner ] ; int256 average block reward = signed average ( commitment . on block reward , block reward_ ) ; require ( NUM_ <= average block reward ) ; uint256 effective block reward = uint256 ( average block reward ) ; uint256 effective stake = average ( commitment . at stake , total stake_ ) ; uint256 number of blocks = block . number . sub ( commitment . on block number ) ; uint256 mining reward = number of blocks . mul ( effective block reward ) . mul ( commitment . value ) . div ( effective stake ) ; return mining reward ; }
"
"function set_crowdsale closed ( bool new val ) public { require ( msg . sender == NUM_ ) ; crowdsale closed = new val ; }
"
"function set hard cap ( uint256 _new cap ) public only owner { require ( _new cap > NUM_ ) ; cap = _new cap ; }
"
"function update delegator with earnings ( address _delegator , uint256 _end round ) internal { delegator storage del = delegators [ _delegator ] ; if ( del . delegate address != address ( NUM_ ) ) { require ( _end round . sub ( del . last claim round ) <= max earnings claims rounds ) ; uint256 current bonded amount = del . bonded amount ; uint256 current fees = del . fees ; for ( uint256 i = del . last claim round + NUM_ ; i <= _end round ; i ++ ) { earnings pool . data storage earnings pool = transcoders [ del . delegate address ] . earnings pool per round [ i ] ; if ( earnings pool . has claimable shares ( ) ) { bool is transcoder = _delegator == del . delegate address ; var ( fees , rewards ) = earnings pool . claim share ( current bonded amount , is transcoder ) ; current fees = current fees . add ( fees ) ; current bonded amount = current bonded amount . add ( rewards ) ; } } del . bonded amount = current bonded amount ;
"
"modifier require not frozen ( ) { require ( ! frozen ) ; _ ; }
"
"function finalize auction ( ) public at stage ( stages . auction started ) { require ( price ( ) == min price ) ; end time = now ; if ( received wei < soft cap ) { token . transfer ( wallet address , num tokens auctioned ) ; stage = stages . auction canceled ; auction canceled ( ) ; return ; } wallet address . transfer ( received wei ) ; uint missing funds = missing funds to end auction ( ) ; if ( missing funds > NUM_ ) { uint sold tokens = token multiplier * received wei / price ( ) ; uint burn tokens = num tokens auctioned - sold tokens ; token . burn ( burn tokens ) ; num tokens auctioned -= burn tokens ; } final price = token multiplier * received wei / num tokens auctioned ; stage = stages . auction ended ; auction ended ( final price ) ; assert ( final price > NUM_ ) ; }
"
"function _start next competition ( string game id , uint32 version , uint88 price , uint8 num past blocks , uint8 house divider , uint16 lag , uint64 duration , uint32 verification wait time , bytes32 code hash , uint32 [ ] rewards distribution ) payable { if ( msg . sender != organiser ) { throw ; } var game = games [ game id ] ; var new competition = game . competitions [ NUM_ - game . current competition index ] ; var current competition = game . competitions [ game . current competition index ] ; if ( current competition . end time >= now ) { throw ; } if ( new competition . num players > NUM_ ) { throw ; } if ( house divider == NUM_ ) { throw ; } if ( num past blocks < NUM_ ) { throw ; } if ( rewards distribution . length == NUM_ || rewards distribution . length > NUM_ ) { throw ; } uint32 prev = NUM_ ; for ( uint8 i = NUM_ ; i < rewards distribution . length ; i ++ ) { if ( rewards distribution [ i
"
"function has closed ( ) public view returns ( bool ) { return token cap reached ( ) || super . has closed ( ) ; }
"
"function add order ( address _contractor address , uint _contractor proposal id , uint _amount , uint _order date ) internal { uint _order id = orders . length ++ ; order d = orders [ _order id ] ; d . contractor address = _contractor address ; d . contractor proposal id = _contractor proposal id ; d . amount = _amount ; d . order date = _order date ; total amount of orders += _amount ; order added ( msg . sender , _contractor address , _contractor proposal id , _amount , _order date ) ; }
"
"function destroy ( address _from , uint256 _amount ) public owner only { balance of [ _from ] = safe sub ( balance of [ _from ] , _amount ) ; total supply = safe sub ( total supply , _amount ) ; transfer ( _from , this , _amount ) ; destruction ( _amount ) ; }
"
"function withdraw bankroll ( address receiver , uint num tokens ) public only authorized { require ( num tokens <= bankroll ( ) ) ; require ( allowed receiver [ receiver ] ) ; assert ( edg . transfer ( receiver , num tokens ) ) ; }
"
"function burn sent ( uint256 _value ) public { require ( _value > NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( burner , _value ) ; }
"
"function proven address ( address _addr , bool _is confirm ) public only authorized { identification db [ _addr ] = _is confirm ; emit proven ( _addr , _is confirm ) ; }
"
"function unfreeze ( uint256 tokens ) public only owner returns ( bool success ) { require ( freeze of [ msg . sender ] >= tokens ) ; require ( tokens > NUM_ ) ; freeze of [ msg . sender ] = freeze of [ msg . sender ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; emit unfreeze ( msg . sender , tokens ) ; return BOOL_ ; }
"
"function transfer ownership ( address new owner ) only owner { require ( new owner != address ( NUM_ ) ) ; owner = new owner ; }
"
"function _create mobster ( string _name , address _owner , uint256 _price , uint256 _boss , uint256 _level , string _show ) private { mobster memory _mobster = mobster ( { name : _name , boss : _boss , state : NUM_ , dazed exipry time : NUM_ , buy price : _price , starting price : _price , id : mobsters . length - NUM_ , buy time : now , level : _level , show : _show , has whacked : BOOL_ } ) ; uint256 new mobster id = mobsters . push ( _mobster ) - NUM_ ; mobsters [ new mobster id ] . id = new mobster id ; if ( new mobster id == NUM_ ) { mobsters [ NUM_ ] . has whacked = BOOL_ ; } if ( new mobster id % NUM_ == NUM_ || new mobster id == NUM_ ) { gang hits . length ++ ; gang badges . length ++ ; } require ( new mobster id == uint256 ( uint32 ( new mobster id ) ) ) ; birth ( new mobster id , _name , _owner ) ; mobster index to price [ new mobster id
"
"function unregister user ( even distro crowdsale storage storage self , address _registrant ) public returns ( bool ) { require ( ( msg . sender == self . base . owner ) || ( msg . sender == address ( this ) ) ) ; if ( ( ! self . static cap ) && ( now >= self . base . start time - NUM_ hours ) ) { log reg error ( _registrant , STR_ ) ; return BOOL_ ; } if ( ! self . is registered [ _registrant ] ) { log reg error ( _registrant , STR_ ) ; return BOOL_ ; } uint256 result ; bool err ; self . is registered [ _registrant ] = BOOL_ ; ( err , result ) = self . num registered . minus ( NUM_ ) ; require ( ! err ) ; self . num registered = result ; log user un registered ( _registrant ) ; return BOOL_ ; }
"
"function request change staker ( address new staker ) public only admin or owner { uint defer block = compute defer block ( ) ; change staker operation = change staker operation ( new staker , admin , defer block ) ; change staker operation event ( new staker , defer block ) ; }
"
"function update state ( int128 win balance , uint128 game count , uint8 v , bytes32 r , bytes32 s ) public { address player = determine player ( win balance , game count , v , r , s ) ; uint gas cost = NUM_ ; if ( player == msg . sender ) require ( authorized [ ecrecover ( keccak256 ( player , win balance , game count ) , v , r , s ) ] ) ; else gas cost = get gas cost ( ) ; state storage last = last state [ player ] ; require ( game count > last . count ) ; int difference = update player balance ( player , win balance , last . win balance , gas cost ) ; last state [ player ] = state ( game count , win balance ) ; state update ( game count , win balance , difference , gas cost , player , last . count ) ; }
"
"function bet ( uint team idx ) public payable { require ( can bet ( ) == BOOL_ ) ; require ( team type ( team idx ) == team type . paeagles || team type ( team idx ) == team type . nepatriots ) ; require ( msg . value >= minimum_bet ) ; if ( better info [ msg . sender ] . amounts bet [ NUM_ ] == NUM_ && better info [ msg . sender ] . amounts bet [ NUM_ ] == NUM_ ) betters . push ( msg . sender ) ; better info [ msg . sender ] . amounts bet [ team idx ] += msg . value ; number of bets ++ ; total bet amount += msg . value ; total amounts bet [ team idx ] += msg . value ; bet made ( ) ; }
"
"function burn ( uint256 _amount ) public { require ( _amount > NUM_ ) ; require ( balances [ msg . sender ] > NUM_ ) ; require ( _amount <= balances [ msg . sender ] ) ; assert ( _amount <= total supply ) ; total supply = total supply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; emit transfer ( msg . sender , address ( NUM_ ) , _amount ) ; }
"
"function calculate reward for address ( address _address ) public view only owner returns ( uint256 ) { return calculate reward internal ( _address , now ) ; }
"
"function set locked ( bool _locked ) only owner { locked = _locked ; }
"
"function settle bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + block_delay ) ; require ( block . number <= bet . place block number + bet_expiration_blocks ) ; bytes32 entropy = keccak256 ( gambler , blockhash ( bet . place block number + block_delay ) ) ; uint256 dice win = NUM_ ; uint256 jackpot win = NUM_ ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 dice = uint256 ( entropy ) % roll modulo ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; uint256 dice win amount = get dice win amount ( bet . amount , roll modulo , roll under ) ; if ( ( NUM_ * * dice ) & bet . mask != NUM_ ) { dice win = dice win amount ; } locked in bets -= uint128 ( dice win amount ) ; if ( bet . amount >= min_jackpot_bet ) { uint256 jackpot rng =
"
"modifier not ended ( ) { require ( ! has ended ) ; _ ; }
"
"function return ether ( ) public { require ( ! used [ msg . sender ] ) ; require ( ! return period expired ) ; uint256 eth = NUM_ ; uint256 tokens = NUM_ ; if ( status ico == status ico . pre ico started ) { require ( eth pre ico [ msg . sender ] > NUM_ ) ; eth = eth pre ico [ msg . sender ] ; tokens = tokens pre ico [ msg . sender ] ; eth pre ico [ msg . sender ] = NUM_ ; tokens pre ico [ msg . sender ] = NUM_ ; } if ( status ico == status ico . ico started ) { require ( eth ico [ msg . sender ] > NUM_ ) ; eth = eth ico [ msg . sender ] ; tokens = tokens ico [ msg . sender ] ; eth ico [ msg . sender ] = NUM_ ; tokens ico [ msg . sender ] = NUM_ ; } used [ msg . sender ] = BOOL_ ; msg . sender . transfer ( eth ) ; aid . burn tokens ( msg . sender
"
"modifier check allowed { conditional transitions ( ) ; require ( state . check allowed function ( msg . sig ) ) ; _ ; }
"
"function transfer ( address _to , uint256 _value ) { require ( balance of [ msg . sender ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; balance of [ msg . sender ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; }
"
"function burn ( uint256 _value ) public only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }
"
"function submit vote ( db storage db , bytes32 vote data , bytes extra ) external { _add vote ( db , vote data , msg . sender , extra ) ; set seq number max ( db ) ; }
"
"function spendtokens ( erc20 basic contractaddress , uint256 _to , uint256 _main , uint256 _fraction ) public returns ( bool valid ) { require ( _to != NUM_ ) ; require ( _main <= max_daily_token_cosign_spend ) ; require ( _fraction < ( whole_ether / fraction_ether ) ) ; sendsignature ( ) ; uint256 current time = block . timestamp ; uint256 valid1 = NUM_ ; uint256 valid2 = NUM_ ; if ( block . timestamp - m signatures [ contract_signature1 ] < cosign_max_time ) { m amount1 = _main * whole_ether + _fraction * fraction_ether ; valid1 = NUM_ ; } if ( block . timestamp - m signatures [ contract_signature2 ] < cosign_max_time ) { m amount2 = _main * whole_ether + _fraction * fraction_ether ; valid2 = NUM_ ; } if ( valid1 == NUM_ && valid2 == NUM_ ) { require ( current time - m last spend [ msg . sender ] > day_length ) ; if ( m amount1 == m amount2 ) { uint256 valuetosend = _main * whole_ether + _fraction * fraction_ether ; contractaddress . transfer ( address ( _to ) , valuetosend ) ; valid1 = NUM_ ; valid2 = NUM_ ;
"
"function _mint ( address _to , uint256 _token id ) internal { require ( _to != address ( NUM_ ) ) ; add token to ( _to , _token id ) ; emit transfer ( address ( NUM_ ) , _to , _token id ) ; }
"
"function handle tokens ( token token ) public returns ( bool ) { if ( paused ) { token . transfer ( cold wallet , token . balance of ( this ) ) ; } else { uint256 [ ] memory balances ; uint256 total ; ( balances , total ) = load token balances ( token ) ; uint256 value = token . balance of ( address ( this ) ) ; uint256 target total = min ( limit token [ token ] , total + value ) ; if ( target total > total ) { uint256 target per hotwallet = get target per wallet ( target total , balances ) ; for ( uint256 i = NUM_ ; i < balances . length ; i ++ ) { if ( balances [ i ] < target per hotwallet ) { token . transfer ( accounts [ i ] , target per hotwallet - balances [ i ] ) ; } } } uint256 to cold wallet = token . balance of ( address ( this ) ) ; if ( to cold wallet != NUM_ ) { token . transfer ( cold wallet , to cold wallet
"
"function finish sale ( ) public only owner or sale agent { sale agent = address ( NUM_ ) ; emit sale agent ( sale agent ) ; sale finished = BOOL_ ; }
"
"function swap for ( address whom ) only owner public returns ( bool ) { require ( registry . approved ( whom ) ) ; uint256 old balance ; uint256 new balance ; if ( public presale . balance of ( whom ) > NUM_ ) { old balance = public presale . balance of ( whom ) ; new balance = old balance * compensation1 / NUM_ ; public presale . burn tokens ( whom , old balance ) ; token . transfer ( whom , new balance ) ; supporter resolved ( whom , old balance , new balance ) ; } if ( partner presale . balance of ( whom ) > NUM_ ) { old balance = partner presale . balance of ( whom ) ; new balance = old balance * compensation2 / NUM_ ; partner presale . burn tokens ( whom , old balance ) ; token . transfer ( whom , new balance ) ; supporter resolved ( whom , old balance , new balance ) ; } return BOOL_ ; }
"
"function add part owner ( address _partowner ) external only contract owner returns ( uint ) { partowners [ _partowner ] = BOOL_ ; return ok ; }
"
"function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { do send ( msg . sender , msg . sender , _to , _amount , STR_ , STR_ , BOOL_ ) ; return BOOL_ ; }
"
"function set advisory wallet ( address _new advisory wallet ) only owner public { advisory wallet = _new advisory wallet ; set advisory wallet ( _new advisory wallet ) ; }
"
"function segment hash ( string _stream id , uint256 _segment number , bytes32 _data hash ) public pure returns ( bytes32 ) { return keccak256 ( _stream id , _segment number , _data hash ) ; }
"
"function withdraw all to owner ( ) public only by ( owner ) returns ( bool ) { require ( sale is finished ( ) ) ; uint256 sum in wei = this . balance ; if ( ! msg . sender . send ( this . balance ) ) { return BOOL_ ; } else { withdrawal ( msg . sender , sum in wei ) ; return BOOL_ ; } }
"
"function create clone token ( uint _snapshot block , string _clone token name , string _clone token symbol ) public returns ( address ) { if ( _snapshot block == NUM_ ) { _snapshot block = block . number ; } if ( _snapshot block > block . number ) { _snapshot block = block . number ; } proof token clone token = token factory . create clone token ( this , _snapshot block , _clone token name , _clone token symbol ) ; clone token . transfer control ( msg . sender ) ; new clone token ( address ( clone token ) ) ; return address ( clone token ) ; }
"
"function _transfer ( address _from , address _to , uint256 _token id ) internal { ownership token count [ _to ] ++ ; lambo index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete lambo index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }
"
"function get ark data ( uint256 _token id ) external view returns ( address _owner , uint256 _price , uint256 _next price , uint256 _mate , address _birther , uint8 _gender , uint256 _baby , uint256 _baby price ) { animal memory animal = ark data [ _token id ] ; uint256 baby ; if ( animal . gender == NUM_ ) baby = babies [ _token id ] ; else baby = babies [ mates [ _token id ] ] ; return ( animal . owner , animal . price , get next price ( animal . price ) , mates [ _token id ] , animal . birther , animal . gender , baby , baby makin price [ baby ] ) ; }
"
"function claim bet ( uint8 _match id , uint8 _bet id ) public valid bet ( _match id , _bet id ) { match storage mtch = matches [ _match id ] ; bet storage bet = mtch . bets [ _bet id ] ; require ( ( mtch . locked || now >= NUM_ ) && ! bet . claimed && ! bet . cancelled && msg . sender == bet . better ) ; bet . claimed = BOOL_ ; if ( mtch . winner == NUM_ ) { bet . better . transfer ( bet . amount ) ; } else { if ( bet . option != mtch . winner ) { return ; } uint total pool ; uint win pool ; if ( mtch . winner == NUM_ ) { total pool = mtch . total team bbets + mtch . total draw bets ; assert ( total pool >= mtch . total team bbets ) ; win pool = mtch . total team abets ; } else if ( mtch . winner == NUM_ ) { total pool = mtch . total team abets + mtch . total draw bets ; assert (
"
"function get bonus ( uint _value , uint _sold ) internal constant returns ( tokens holder ) { tokens holder memory result ; uint _bonus = NUM_ ; result . tokens = _value ; for ( uint8 i = NUM_ ; _value > NUM_ && i < bonus limit . length ; ++ i ) { uint current_bonus_part = NUM_ ; if ( _value > NUM_ && _sold < bonus limit [ i ] ) { uint bonus_left = bonus limit [ i ] - _sold ; uint _bonused part = min ( _value , bonus_left ) ; current_bonus_part = current_bonus_part . add ( percent ( _bonused part , bonus patterns [ i ] ) ) ; _value = _value . sub ( _bonused part ) ; _sold = _sold . add ( _bonused part ) ; } if ( current_bonus_part > NUM_ ) { _bonus = _bonus . add ( current_bonus_part ) ; } } result . bonus = _bonus ; return result ; }
"
"function rivetz release ( uint256 spid ) only owner public { spentry storage sp entry = sp entries [ spid ] ; sp entry . registrant = address ( NUM_ ) ; sp entry . admin = address ( NUM_ ) ; sp entry . pub key hash = NUM_ ; sp entry . info hash = NUM_ ; sp entry . expiration = NUM_ ; sp entry . valid = BOOL_ ; }
"
"function safe sub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }
"
"function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting
"
"function get current gas price ( ) constant public returns ( uint256 ) { return gas price ; }
"
"function train special ( uint256 _kitty id , uint256 _special id , uint256 [ NUM_ ] _slots ) external payable is not contract { special personality storage special = special info [ _special id ] ; require ( msg . sender == core . owner of ( _kitty id ) ) ; require ( kitty data . fetch slot ( _kitty id , NUM_ ) > NUM_ ) ; require ( ! special kitties [ _kitty id ] ) ; require ( msg . value == special . price ) ; require ( special . amount left > NUM_ ) ; uint256 [ NUM_ ] memory random moves = randomize actions ( _special id ) ; assert ( kitty data . train special ( _kitty id , _special id , random moves , _slots ) ) ; assert ( kitty gym . add moves ( _kitty id , random moves ) ) ; uint256 special rank = special . population - special . amount left + NUM_ ; special trained ( _kitty id , _special id , special rank , random moves ) ; special . amount left -- ; special kitties [ _kitty id ] = BOOL_ ; owner
"
"function update generation stop time ( uint256 _season , uint8 _value ) public only manager when not paused { require ( generation season controller [ _season ] == NUM_ && _value != NUM_ ) ; _update generation season flag ( _season , _value ) ; }
"
"function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (
"
"function get leaderboard length ( ) external view returns ( uint256 ) { return leader board players . length ; }
"
"modifier when upgrade enabled ( ) { require ( upgrade agent != address ( NUM_ ) ) ; _ ; }
"
"function get policy details ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _group names , uint [ ] _accept limits , uint [ ] _decline limits , uint _total accepted limit , uint _total declined limit ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; uint _policy idx = policy id2 index [ _policy hash ] ; if ( _policy idx == NUM_ ) { return ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; _group names = new bytes32 [ ] ( _policy groups count ) ; _accept limits = new uint [ ] ( _policy groups count ) ; _decline limits = new uint [ ] ( _policy groups count ) ; for ( uint _idx = NUM_ ; _idx < _policy groups count ; ++ _idx ) { requirements storage _requirements = _policy . participated groups [ _idx + NUM_ ] ; _group names [ _idx ] = _requirements . group name ; _accept limits [
"
"function __exchanger callback ( address _target contract , address _exchanger , uint _amount ) public when configured only exchange returns ( bool success ) { require ( _target contract != address ( NUM_ ) ) ; if ( _amount > balances [ _exchanger ] ) { return BOOL_ ; } balances [ _exchanger ] = balances [ _exchanger ] . sub ( _amount ) ; exchanged with [ _target contract ] = exchanged with [ _target contract ] . add ( _amount ) ; exchanged by [ _exchanger ] = exchanged by [ _exchanger ] . add ( _amount ) ; return BOOL_ ; }
"
"function batch lock ( address [ ] accounts , uint locked token ) public when not paused only admin { for ( uint i = NUM_ ; i < accounts . length ; i ++ ) { lock ( accounts [ i ] , locked token ) ; } }
"
"function get planet ( uint _planet id ) public view returns ( string name , address owner address , uint256 cur price , uint256 cur resources , uint owner attack , uint owner defense ) { planet storage _planet = planets [ _planet id ] ; name = _planet . name ; owner address = _planet . owner address ; cur price = _planet . cur price ; cur resources = _planet . cur resources ; owner attack = address attack count [ _planet . owner address ] ; owner defense = address defense count [ _planet . owner address ] ; }
"
"function allocation for escbby stage ( ) only ( escbdev multisig ) public { if ( current stage > allocated stage ) { uint256 escbtokens = safe math . div ( safe math . mul ( safe math . sub ( uint256 ( token . total supply ( ) ) , used total supply ) , NUM_ ) , NUM_ ) ; uint256 prev total supply = uint256 ( token . total supply ( ) ) ; if ( token . generate tokens ( address ( this ) , escbtokens ) ) { allocated stage = current stage ; used total supply = prev total supply ; uint64 cliff date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; uint64 vesting date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; token . grant vested tokens ( escbdev multisig , escbtokens , uint64 ( now ) , cliff date , vesting date , BOOL_ , BOOL_ ) ; allocation for escbfund ( escbdev multisig , escbtokens ) ; } else { revert ( ) ; } } }
"
"function extra balance needed ( uint _proposed sell value ) external view only owner returns ( uint ) { uint required balance = get required balance ( _proposed sell value ) ; return ( required balance > address ( this ) . balance ) ? required balance . sub ( address ( this ) . balance ) : NUM_ ; }
"
"function start sale ( uint256 _start time ) public only owner { require ( ! is active ) ; require ( _start time > get now ( ) ) ; require ( sale start time == NUM_ || _start time . sub ( sale start time ) > NUM_ days ) ; sleep contract . burn tokens ( ) ; uint256 sleep tokens = token . balance of ( address ( sleep contract ) ) ; family contract . burn tokens ( ) ; uint256 family tokens = token . balance of ( family contract ) . add ( family contract . debt ( ) ) ; personal contract . burn tokens ( ) ; uint256 personal tokens = token . balance of ( personal contract ) . add ( personal contract . debt ( ) ) ; uint256 missing sleep = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( sleep tokens ) ; uint256 missing family = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( family tokens ) ; uint256 missing personal = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub (
"
"function create tokens ( uint256 _value ) internal { if ( is finalized ) throw ; if ( now < funding start time ) throw ; if ( now > funding end time ) throw ; if ( msg . value == NUM_ ) throw ; uint256 tokens = safe mult ( _value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) { if ( token creation cap <= total supply ) throw ; uint256 tokens to allocate = safe subtract ( token creation cap , total supply ) ; uint256 tokens to refund = safe subtract ( tokens , tokens to allocate ) ; total supply = token creation cap ; balances [ msg . sender ] += tokens to allocate ; uint256 ether to refund = tokens to refund / token exchange rate ; msg . sender . transfer ( ether to refund ) ; create ddft ( msg . sender , tokens to allocate ) ; log refund ( msg . sender , ether to refund ) ; splitter contract ( splitter ) . update ( msg .
"
"function vesting func ( uint256 _current time , uint256 _start time , uint256 _init release amount , uint256 _amount , uint256 _interval , uint256 _periods ) public pure returns ( uint256 ) { if ( _current time < _start time ) { return NUM_ ; } uint256 t = _current time . sub ( _start time ) ; uint256 end = _periods . mul ( _interval ) ; if ( t >= end ) { return _amount ; } uint256 i_amount = _amount . sub ( _init release amount ) . div ( _periods ) ; uint256 i = t . div ( _interval ) ; return i_amount . mul ( i ) . add ( _init release amount ) ; }
"
"function symbol ( ) public pure returns ( string ) { return STR_ ; }
"
"function __callback ( bytes32 _my id , string _result ) only if not paused { require ( msg . sender == oraclize_cb address ( ) || msg . sender == etheraffle ) ; emit log oraclize callback ( msg . sender , _my id , _result , q id [ _my id ] . week no , now ) ; if ( q id [ _my id ] . is random == BOOL_ ) { reclaim unclaimed ( ) ; disburse funds ( q id [ _my id ] . week no ) ; set winning numbers ( q id [ _my id ] . week no , _result ) ; if ( q id [ _my id ] . is manual == BOOL_ ) return ; bytes32 query = oraclize_query ( matches delay , STR_ , str concat ( api str1 , uint2str ( q id [ _my id ] . week no ) , api str2 ) , gas amt ) ; q id [ query ] . week no = q id [ _my id ] . week no ; emit log query sent ( query , matches delay + now , now ) ; } else
"
"function set ico phase3 ( uint256 _start , uint256 _end ) external only owner { require ( _start < _end ) ; ico phase3 start = _start ; ico phase3 end = _end ; emit change ico phase ( NUM_ , _start , _end ) ; }
"
"function buyout cost ( uint256 _deed id ) external view returns ( uint256 ) { uint256 price = identifier to buyout price [ _deed id ] ; uint256 [ ] memory claimed surrounding plots = _claimed surrounding plots ( _deed id ) ; uint256 flat dividends = claim dividend ( ) . mul ( claimed surrounding plots . length ) ; return price . add ( flat dividends ) ; }
"
"function successful withdraw ( ) external only owner stop in emergency { require ( has ended ( ) ) ; require ( can withdraw ) ; require ( tokens sent > soft cap ) ; uint256 withdrawal amount = wei raised . sub ( withdrawn ) ; withdrawn = withdrawn . add ( withdrawal amount ) ; beneficiary . transfer ( withdrawal amount ) ; beneficiary withdrawal ( msg . sender , withdrawal amount , now ) ; }
"
"modifier only owner ( ) { if ( msg . sender == owner ) _ ; }
"
"function transfer helper ( token storage storage self , address _from , address _to , uint _amount ) internal { address [ ] memory from_swaps = self . user_swaps [ _from ] ; for ( uint i = from_swaps . length . sub ( NUM_ ) ; i > NUM_ ; i -- ) { uint from_swap_user_index = self . swap_balances_index [ from_swaps [ i ] ] [ _from ] ; balance memory from_user_bal = self . swap_balances [ from_swaps [ i ] ] [ from_swap_user_index ] ; if ( _amount >= from_user_bal . amount ) { _amount -= from_user_bal . amount ; self . user_swaps [ _from ] . length = self . user_swaps [ _from ] . length . sub ( NUM_ ) ; delete self . user_swaps_index [ _from ] [ from_swaps [ i ] ] ; if ( self . user_swaps_index [ _to ] [ from_swaps [ i ] ] != NUM_ ) { uint to_balance_index = self . swap_balances_index [ from_swaps [ i ] ] [ _to ] ; assert ( to_balance_index != NUM_ ) ; self . swap_balances [ from_swaps [ i ] ] [ to_balance_index ] . amount = self . swap_balances [
"
"function add whitelisted addr ( address whitelisted addr ) only owner { require ( ! whitelisted addrs [ whitelisted addr ] ) ; whitelisted addrs [ whitelisted addr ] = BOOL_ ; }
"
"function perc of ( uint256 _amount , uint256 _frac num , uint256 _frac denom ) internal pure returns ( uint256 ) { return _amount . mul ( perc points ( _frac num , _frac denom ) ) . div ( perc_divisor ) ; }
"
"function batch transfer diff ( address [ ] _to , uint256 [ ] _amount ) public { require ( state == state . transferable ) ; require ( _to . length == _amount . length ) ; uint256 total amount = array sum ( _amount ) ; require ( total amount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( total amount ) ; for ( uint i ; i < _to . length ; i ++ ) { balances [ _to [ i ] ] = balances [ _to [ i ] ] . add ( _amount [ i ] ) ; transfer ( msg . sender , _to [ i ] , _amount [ i ] ) ; } }
"
"function set bonus ( uint _percent ) external { require ( msg . sender == owner || msg . sender == minter ) ; require ( _percent >= NUM_ ) ; current bonus = safe add ( NUM_ , _percent ) ; bonus changed ( STR_ , _percent ) ; }
"
"function equal strings ( string _a , string _b ) pure private returns ( bool ) { return compare ( _a , _b ) == NUM_ ; }
"
"function mint ( uint256 _amount ) external only owner when not paused { require ( _amount > NUM_ ) ; total supply = total supply . add ( _amount ) ; balances [ the coin ] = balances [ the coin ] . add ( _amount ) ; mint ( msg . sender , the coin , _amount ) ; transfer ( address ( NUM_ ) , the coin , _amount ) ; }
"
"function transfer ( address _to , uint _value ) only activated ( ) external returns ( bool ) { require ( balance of ( msg . sender ) >= _value ) ; recalculate ( msg . sender ) ; if ( _to != NUM_ ) { recalculate ( _to ) ; balances [ msg . sender ] . balance -= _value ; balances [ _to ] . balance += _value ; transfer ( msg . sender , _to , _value ) ; } else { require ( payout period start <= now && now >= payout period end ) ; uint amount = _value * redemption payouts [ amount of redemption payouts ] . price ; require ( amount <= balances [ msg . sender ] . posible redemption ) ; balances [ msg . sender ] . posible redemption -= amount ; balances [ msg . sender ] . balance -= _value ; total supply -= _value ; msg . sender . transfer ( amount ) ; transfer ( msg . sender , _to , _value ) ; } return BOOL_ ; }
"
"function configure ( bytes32 _exec_id , bytes32 _name ) private pure returns ( bytes32 [ NUM_ ] memory ) { return [ crowdsale_configured , _exec_id , _name ] ; }
"
"function get hero details ( uint _hero id ) public view returns ( string hero name , address owner address , address dbzhero owner address , uint256 current price , uint current level ) { hero storage _hero = heroes [ _hero id ] ; hero name = _hero . hero name ; owner address = _hero . owner address ; dbzhero owner address = _hero . dbzhero owner address ; current price = _hero . current price ; current level = _hero . current level ; }
"
"function finish proposal voting ( uint256 _proposal id ) only congress members { proposal p = proposals [ _proposal id ] ; if ( now < p . voting deadline ) throw ; if ( p . state != proposal state . proposed ) throw ; var _votes number = p . votes . length ; uint256 tokens for = NUM_ ; uint256 tokens against = NUM_ ; for ( uint256 i = NUM_ ; i < _votes number ; i ++ ) { if ( p . votes [ i ] . in support ) { tokens for += p . votes [ i ] . voter tokens ; } else { tokens against += p . votes [ i ] . voter tokens ; } unblock tokens ( p . votes [ i ] . voter ) ; } if ( ( tokens for + tokens against ) < minimum quorum ) { p . state = proposal state . no quorum ; proposal tallied event ( _proposal id , BOOL_ , BOOL_ ) ; return ; } if ( ( tokens for - tokens against ) < margin for majority ) { p . state = proposal
"
"function get app id ( string _app nickname ) external constant returns ( uint ) { return __app ids [ _app nickname ] ; }
"
"function get min ( uint256 [ ] storage self ) public view returns ( uint256 min value ) { assembly { mstore ( NUM_ , self_slot ) min value : = sload ( sha3 ( NUM_ , NUM_ ) ) for { let i : = NUM_ } lt ( i , sload ( self_slot ) ) { i : = add ( i , NUM_ ) } { switch gt ( sload ( add ( sha3 ( NUM_ , NUM_ ) , i ) ) , min value ) case NUM_ { min value : = sload ( add ( sha3 ( NUM_ , NUM_ ) , i ) ) } } } }
"
"function internal add interest ( loan storage loan , uint256 timestamp ) internal { if ( timestamp > loan . interest timestamp ) { uint256 new interest = loan . interest ; uint256 new punitory interest = loan . punitory interest ; uint256 new timestamp ; uint256 real delta ; uint256 calculated interest ; uint256 delta time ; uint256 pending ; uint256 end non punitory = min ( timestamp , loan . due time ) ; if ( end non punitory > loan . interest timestamp ) { delta time = end non punitory - loan . interest timestamp ; if ( loan . paid < loan . amount ) { pending = loan . amount - loan . paid ; } else { pending = NUM_ ; } ( real delta , calculated interest ) = calculate interest ( delta time , loan . interest rate , pending ) ; new interest = safe add ( calculated interest , new interest ) ; new timestamp = loan . interest timestamp + real delta ; } if ( timestamp > loan . due time ) { uint256 start punitory = max ( loan . due time , loan . interest
"
"function remove trusted contracts ( address [ ] _trusted_contracts ) is owner public { for ( uint256 i = NUM_ ; i < _trusted_contracts . length ; i ++ ) { if ( trusted_contracts [ _trusted_contracts [ i ] ] ) { trusted_contracts [ _trusted_contracts [ i ] ] = BOOL_ ; trusted contract ( _trusted_contracts [ i ] , BOOL_ ) ; } } }
"
"function disallow receiver ( address receiver ) public only owner { allowed receiver [ receiver ] = BOOL_ ; }
"
"function decrease supply ( uint256 _value ) is owner external { uint256 value = format decimals ( _value ) ; require ( value + token raised <= current supply ) ; current supply = safe subtract ( current supply , value ) ; balances [ msg . sender ] += value ; decrease supply ( value ) ; }
"
"function set claim dividend percentage ( uint256 _claim dividend percentage ) external only cfo { require ( NUM_ <= _claim dividend percentage && _claim dividend percentage <= NUM_ ) ; claim dividend percentage = _claim dividend percentage ; }
"
"function get policy details ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _group names , uint [ ] _accept limits , uint [ ] _decline limits , uint _total accepted limit , uint _total declined limit ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; uint _policy idx = policy id2 index [ _policy hash ] ; if ( _policy idx == NUM_ ) { return ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; _group names = new bytes32 [ ] ( _policy groups count ) ; _accept limits = new uint [ ] ( _policy groups count ) ; _decline limits = new uint [ ] ( _policy groups count ) ; for ( uint _idx = NUM_ ; _idx < _policy groups count ; ++ _idx ) { requirements storage _requirements = _policy . participated groups [ _idx + NUM_ ] ; _group names [ _idx ] = _requirements . group name ; _accept limits [
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( balance of ( msg . sender ) >= _amount ) ; uint previous balances = balances [ msg . sender ] + balances [ _to ] ; add to balance ( _to , _amount ) ; decrement balance ( msg . sender , _amount ) ; transfer ( msg . sender , _to , _amount ) ; assert ( balances [ msg . sender ] + balances [ _to ] == previous balances ) ; return BOOL_ ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function end sale ( ) public only owner _contract up _sale not ended { require ( sale time over ( ) ) ; sale ended = BOOL_ ; emit sale ended ( msg . sender , now ) ; }
"
"function mint token for pre crowdsale ( address investors address , uint256 tokens purchased ) external only owner { require ( now < start time && investors address != address ( NUM_ ) ) ; require ( token . total supply ( ) . add ( tokens purchased ) <= pre_crowdsale_cap ) ; token . mint ( investors address , tokens purchased ) ; private investor token purchase ( investors address , tokens purchased ) ; }
"
"function change fixed commission fee ( uint _new commission fee ) public when not paused when not stopped only owner returns ( bool success ) { uint old commission fee = commission fee ; commission fee = _new commission fee ; emit log change fixed commission fee ( old commission fee , commission fee ) ; return BOOL_ ; }
"
"function get price ( ) constant public returns ( uint result ) { return price ; }
"
"function setup race ( uint delay , uint locking_duration ) only owner before betting public payable returns ( bool ) { if ( oraclize_get price ( STR_ , horses . custom pre gas limit ) * NUM_ + oraclize_get price ( STR_ , horses . custom post gas limit ) * NUM_ > address ( this ) . balance ) { emit new oraclize query ( STR_ ) ; return BOOL_ ; } else { chronus . starting_time = uint32 ( block . timestamp ) ; chronus . betting_open = BOOL_ ; bytes32 temp_id ; emit new oraclize query ( STR_ ) ; chronus . betting_duration = uint32 ( delay ) ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . ltc ; coin index [ horses . ltc ] . pre oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . eth ; coin index [ horses . eth ] . post oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url
"
"function _compute current price ( uint256 _starting price , uint256 _ending price , uint256 _duration , uint256 _seconds passed ) internal pure returns ( uint256 ) { if ( _seconds passed >= _duration ) { return _ending price ; } else { int256 total price change = int256 ( _ending price ) - int256 ( _starting price ) ; int256 current price change = total price change * int256 ( _seconds passed ) / int256 ( _duration ) ; int256 current price = int256 ( _starting price ) + current price change ; return uint256 ( current price ) ; } }
"
"function create team ( string _name , uint _price ) public only owner { _create team ( _name , this , _price ) ; }
"
"function set token address ( address _token address ) only owner public { token address = _token address ; }
"
"function sub ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function claim tokens ( ) only owner external { require ( token . transfer ( owner , token . balance of ( address ( this ) ) ) ) ; }
"
"function buy tokens ( address _beneficiary ) public payable returns ( uint256 ) { require ( ! suspended ) ; require ( address ( token ) != address ( NUM_ ) ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( _beneficiary != address ( this ) ) ; require ( _beneficiary != address ( token ) ) ; require ( msg . sender != address ( wallet address ) ) ; uint256 sale balance = token . balance of ( address ( this ) ) ; assert ( sale balance > NUM_ ) ; return buy tokens internal ( _beneficiary ) ; }
"
"function decline kyc ( address participant ) external only owner or auditor { kyc status [ participant ] = kyc state . declined ; log kyc decline ( participant , pending amount of eth , now ) ; uint256 pending amount of eth = pending contribution of [ participant ] ; if ( pending amount of eth > NUM_ ) { reset pending contribution ( participant ) ; participant . transfer ( pending amount of eth ) ; } }
"
"function pause sale ( ) public only controller { require ( campaign state == NUM_ ) ; paused = BOOL_ ; campaign paused ( now ) ; }
"
"function set next game settings ( uint256 rows , uint256 cols , uint256 initial activity timer , uint256 final activity timer , uint256 number of flips to final activity timer , uint256 timeout bonus time , uint256 unclaimed tile price , uint256 buyout referral bonus percentage , uint256 first buyout prize pool percentage , uint256 buyout prize pool percentage , uint256 buyout dividend percentage , uint256 buyout fee percentage , uint256 buyout price increase percentage ) public only cfo { require ( NUM_ <= buyout dividend percentage && buyout dividend percentage <= NUM_ ) ; require ( buyout fee percentage <= NUM_ ) ; if ( number of flips to final activity timer == NUM_ ) { require ( initial activity timer == final activity timer ) ; } next game settings = game settings ( { rows : rows , cols : cols , initial activity timer : initial activity timer , final activity timer : final activity timer , number of flips to final activity timer : number of flips to final activity timer , timeout bonus time : timeout bonus time , unclaimed tile price : unclaimed tile price , buyout referral bonus percentage : buyout referral
"
"function decrease tokens ( address _target , uint _amount ) external returns ( bool ) { require ( msg . sender == owner || msg . sender == minter ) ; require ( _amount > NUM_ ) ; uint amount = _amount * ( NUM_ * * uint256 ( decimals ) ) ; balances [ _target ] = safe sub ( balances [ _target ] , amount ) ; stats minted = safe sub ( stats minted , amount ) ; stats total = safe sub ( stats total , amount ) ; transfer ( _target , NUM_ , amount ) ; burn ( _target , amount ) ; return BOOL_ ; }
"
"function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; crypton index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete crypton index to approved [ _token id ] ; } emit transfer ( _from , _to , _token id ) ; }
"
"function create order ( uint128 order id , uint16 price , uint size base , terms terms , uint max matches ) public { address client = msg . sender ; require ( order id != NUM_ && order for order id [ order id ] . client == NUM_ ) ; client order event ( client , client order event type . create , order id , max matches ) ; order for order id [ order id ] = order ( client , price , size base , terms , status . unknown , reason code . none , NUM_ , NUM_ , NUM_ , NUM_ ) ; uint128 previous most recent order id for client = most recent order id for client [ client ] ; most recent order id for client [ client ] = order id ; client previous order id before order id [ order id ] = previous most recent order id for client ; order storage order = order for order id [ order id ] ; var ( direction , mantissa , exponent ) = unpack price ( price ) ; if ( direction == direction . invalid ) { order
"
"function burn sent ( uint256 _value ) public { require ( _value > NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( burner , _value ) ; }
"
"function bonus ( uint amount ) internal constant returns ( uint ) { if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ; }
"
"function _is ready to breed ( ether dog _dog ) internal view returns ( bool ) { return ( _dog . siring with id == NUM_ ) && ( _dog . cooldown end block <= uint64 ( block . number ) ) ; }
"
"function distribute ( address _to , uint256 _amount ) public only distributor can distribute { require ( balances [ address ( this ) ] >= _amount ) ; balances [ address ( this ) ] = balances [ address ( this ) ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit distribute ( _to , _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ; }
"
"function _new campaign ( ) internal { require ( ! active ( ) , STR_ ) ; require ( _dev fraction . add ( _charity fraction ) . add ( _jackpot fraction ) . add ( _new campaign fraction ) == one_wad , STR_ ) ; uint _campaign id = campaigns . length ++ ; button campaign storage c = campaigns [ _campaign id ] ; last campaign id = _campaign id ; c . price = starting price ; c . price multiplier = _price multiplier ; c . dev fraction = _dev fraction ; c . charity fraction = _charity fraction ; c . jackpot fraction = _jackpot fraction ; c . new campaign fraction = _new campaign fraction ; c . deadline = uint64 ( now . add ( _period ) ) ; c . n = _n ; c . period = _period ; c . total . name = keccak256 ( abi . encode packed ( STR_ , last campaign id ) ) ; transfer eth ( next campaign , c . total , next campaign . balance eth ) ; emit started ( c . total . balance eth , _period , last campaign
"
"function get current tranche ( uint tokens sold ) private view returns ( tranche storage ) { for ( uint i = NUM_ ; i < tranches . length ; i ++ ) { if ( tranches [ i ] . start <= now && now < tranches [ i ] . end && tokens sold < tranches [ i ] . amount ) { return tranches [ i ] ; } } revert ( ) ; }
"
"function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within cap = wei raised . add ( msg . value ) <= cap ; return within period && non zero purchase && within cap ; }
"
"function buy tokens ( address purchaser , uint256 value ) internal when not paused returns ( uint256 ) { require ( value > NUM_ ) ; stage stage = get stage ( ) ; require ( stage == stage . presale || stage == stage . public sale ) ; uint256 purchase amount = math . min256 ( value , investor caps [ purchaser ] . sub ( contributions [ purchaser ] ) ) ; require ( purchase amount > NUM_ ) ; uint256 num tokens ; if ( stage == stage . presale ) { if ( presale . total wei ( ) . add ( purchase amount ) > presale . total cap ( ) ) { purchase amount = presale . cap remaining ( ) ; } num tokens = presale . buy tokens ( purchaser , purchase amount ) ; } else if ( stage == stage . public sale ) { uint total wei = wei raised . add ( purchase amount ) ; uint8 current tier = get tier ( wei raised ) ; if ( total wei >= cap ) { total wei = cap ; purchase amount = cap . sub (
"
"function create token contract ( ) internal returns ( mintable token ) { return new mintable token ( ) ; }
"
"function set proxy ( address _proxy address , bytes32 _symbol ) public only one of contract owners returns ( uint ) { if ( proxies [ _symbol ] != NUM_ ) { return atx_platform_proxy_already_exists ; } proxies [ _symbol ] = _proxy address ; return ok ; }
"
"function remove from whitelist ( address [ ] addresses ) public only owner returns ( bool ) { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { if ( whitelisted [ addresses [ i ] ] ) { whitelisted [ addresses [ i ] ] = BOOL_ ; log whitelist remove ( addresses [ i ] ) ; } } return BOOL_ ; }
"
"function balance of ( address _addr ) public constant returns ( uint ) { return holders [ _addr ] . token balance ; }
"
"function edit asset ( uint256 _token id , uint256 _creator token id , uint256 _price , uint16 _id , uint8 _category , uint8 _state , uint8 _attributes , uint8 [ stats_size ] _stats , uint16 _cooldown ) external valid asset ( _token id ) only clevel returns ( uint256 ) { require ( _id > NUM_ ) ; require ( _category > NUM_ ) ; require ( _attributes != NUM_ ) ; require ( _stats . length > NUM_ ) ; asset index to price [ _token id ] = _price ; asset storage asset = assets [ _token id ] ; asset . id = _id ; asset . category = _category ; asset . built by = _creator token id ; asset . attributes = bytes2 ( _attributes ) ; asset . stats = _stats ; asset . state = _state ; asset . cooldown = _cooldown ; }
"
"function add owner ( address owner ) public only wallet owner does not exist ( owner ) not null ( owner ) valid requirement ( owners . length + NUM_ , required ) { is owner [ owner ] = BOOL_ ; owners . push ( owner ) ; owner addition ( owner ) ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function set presale two ( ) public only owner ( ) { current step = step . funding presale two ; min investment = NUM_ ether ; }
"
"function transfer team tokens ( address _recipient , uint _tokens to transfer ) external only owner ( ) { require ( _recipient != NUM_ ) ; require ( now >= NUM_ ) ; require ( date product completed > NUM_ ) ; if ( now < date product completed + NUM_ years ) require ( team tokens current . add ( _tokens to transfer ) <= ( team tokens initial * NUM_ ) / NUM_ ) ; else if ( now < date product completed + NUM_ years ) require ( team tokens current . add ( _tokens to transfer ) <= ( team tokens initial * NUM_ ) / NUM_ ) ; else if ( now < date product completed + NUM_ years ) require ( team tokens current . add ( _tokens to transfer ) <= ( team tokens initial * NUM_ ) / NUM_ ) ; else require ( team tokens current . add ( _tokens to transfer ) <= team tokens initial ) ; team tokens current = team tokens current . add ( _tokens to transfer ) ; if ( ! token . transfer ( _recipient , _tokens to transfer ) ) revert ( )
"
"function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (
"
"function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { uint256 tokens = wei amount . mul ( rate ) ; uint256 bonus = NUM_ ; if ( now >= end time ) bonus = NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else bonus = NUM_ ; tokens = tokens * bonus / NUM_ ; bonus = NUM_ ; if ( wei amount >= NUM_ && wei amount < NUM_ ) bonus +=
"
"function get dank ( uint256 _token id ) public view returns ( string dank name , uint256 selling price , address owner ) { dank storage dank = danks [ _token id ] ; dank name = dank . name ; selling price = dank index to price [ _token id ] ; owner = dank index to owner [ _token id ] ; }
"
"function get open bids by line ( bytes32 game_id ) constant returns ( bytes ) { book book = get book ( game_id , book type . spread ) ; uint away_lines_length = get unique line count ( book . away bids ) ; uint home_lines_length = get unique line count ( book . home bids ) ; mapping ( int32 = > uint ) [ NUM_ ] line_amounts ; int32 [ ] memory away_lines = new int32 [ ] ( away_lines_length ) ; int32 [ ] memory home_lines = new int32 [ ] ( home_lines_length ) ; uint k = NUM_ ; for ( uint i = NUM_ ; i < book . home bids . length ; i ++ ) { bid bid = book . home bids [ i ] ; if ( bid . amount == NUM_ ) continue ; if ( line_amounts [ NUM_ ] [ bid . line ] == NUM_ ) { home_lines [ k ] = bid . line ; k ++ ; } line_amounts [ NUM_ ] [ bid . line ] += bid . amount ; } k = NUM_ ; for ( i = NUM_ ; i < book
"
"function ecrecover from sig ( bytes32 hash , bytes sig ) public pure returns ( address recovered address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != NUM_ ) return address ( NUM_ ) ; assembly { r : = mload ( add ( sig , NUM_ ) ) s : = mload ( add ( sig , NUM_ ) ) v : = byte ( NUM_ , mload ( add ( sig , NUM_ ) ) ) } v += NUM_ ; if ( v != NUM_ && v != NUM_ ) return address ( NUM_ ) ; return ecrecover ( hash , v , r , s ) ; }
"
"function finalize ( ) public only owner { require ( ! is finalized ) ; require ( has closed ( ) ) ; emit finalized ( ) ; is finalized = BOOL_ ; }
"
"function withdraw with fee ( address _deposit , uint256 _time , bytes32 _name , address _to , uint256 _value , bool _check ) only owner public returns ( bool ) { require ( _deposit != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; uint256 _balance = tk . balance of ( _deposit ) ; if ( _check ) { require ( _value <= _balance ) ; } uint256 available = _balance . sub ( deposit repos [ _deposit ] . frozen ) ; if ( _check ) { require ( _value <= available ) ; } bool exist ; bool correct ; withdraw wallet [ ] storage withdraw wallet list = deposit repos [ _deposit ] . withdraw wallets ; ( exist , correct ) = check withdraw address ( _deposit , _name , _to ) ; if ( ! exist ) { withdraw wallet list . push ( withdraw wallet ( _name , _to ) ) ; } else if ( ! correct ) { return BOOL_ ; } deposit withdraw depos withdr = deposit withdraw ( _deposit ) ; if ( _value > available ) { require ( depos withdr
"
"function request refund ( ) { address nrequester = msg . sender ; update ico status ( ) ; uint ntokens = get held ( holder accounts [ nrequester ] . tokens ) ; if ( ico status != ico status value . failed ) stat event ( STR_ ) ; else if ( ntokens == NUM_ ) stat event ( STR_ ) ; else { uint nrefund = ntokens * token price ; if ( get num tokens purchased ( ) >= min ico token goal ) nrefund -= ( nrefund / NUM_ ) ; if ( ! holder accounts [ developers ] . alloced ) add account ( developers ) ; holder accounts [ developers ] . tokens += ntokens ; holder accounts [ nrequester ] . tokens = NUM_ ; if ( holder accounts [ nrequester ] . balance > NUM_ ) { holder accounts [ developers ] . balance += holder accounts [ nrequester ] . balance ; holder accounts [ nrequester ] . balance = NUM_ ; } if ( ! nrequester . call . gas ( rf gas ) . value ( nrefund ) ( ) ) throw ; } }
"
"function get target block ( uint256 _index ) public view returns ( uint256 _target block number ) { return target blocks [ _index ] ; }
"
"function convert eth to met ( uint _mint return ) public payable returns ( uint returned met ) { returned met = convert ( which token . eth , _mint return , msg . value ) ; emit convert eth to met ( msg . sender , msg . value , returned met ) ; }
"
"function get current tier stats ( ) public view returns ( uint256 index inner , uint256 index outer , uint256 available inner , uint256 available in outer , uint256 price in center , uint256 price in outer , uint256 next price in center , uint256 next price in outer ) { index inner = NUM_ ; index outer = NUM_ ; for ( uint256 i = NUM_ ; i < tiers . length ; i ++ ) { if ( ! tiers [ i ] . filled in center ) { index inner = i ; break ; } } for ( uint256 k = NUM_ ; k < tiers . length ; k ++ ) { if ( ! tiers [ k ] . filled in outer ) { index outer = k ; break ; } } tier storage tier ; if ( index inner != NUM_ ) { tier = tiers [ index inner ] ; available inner = tier . amount in center . sub ( tier . sold in center ) ; price in center = tier . price in center ; if ( index inner < NUM_ ) { next price in center =
"
"function transfer ( address _to , uint _value ) public returns ( bool ok ) { require ( is transfer enable ) ; require ( _to != NUM_ && _value > NUM_ ) ; uint256 sender balance = balances [ msg . sender ] ; require ( sender balance >= _value ) ; sender balance = safe sub ( sender balance , _value ) ; balances [ msg . sender ] = sender balance ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function buy for work order ( uint256 _marketorder idx , address _workerpool , address _app , address _dataset , string _params , address _callback , address _beneficiary ) external returns ( address ) { address requester = msg . sender ; require ( marketplace . consume market order ask ( _marketorder idx , requester , _workerpool ) ) ; uint256 emitcost = lock work order cost ( requester , _workerpool , _app , _dataset ) ; work order workorder = new work order ( _marketorder idx , requester , _app , _dataset , _workerpool , emitcost , _params , _callback , _beneficiary ) ; m_woid registered [ workorder ] = BOOL_ ; require ( worker pool ( _workerpool ) . emit work order ( workorder , _marketorder idx ) ) ; emit work order activated ( workorder , _workerpool ) ; return workorder ; }
"
"function purchase ( uint256 _block_number , uint256 _nonce , uint256 _wei_per_dgx_mg , address _signer , bytes _signature ) payable public returns ( bool _success , uint256 _purchased_amount ) { address _sender = msg . sender ; ( _success , _purchased_amount ) = marketplace_controller ( ) . put_purchase_for . value ( msg . value ) . gas ( NUM_ ) ( msg . value , _sender , _sender , _block_number , _nonce , _wei_per_dgx_mg , _signer , _signature ) ; require ( _success ) ; }
"
"function add whitelisted ( address _address , bool is pool ) public only owner when not paused { if ( is pool ) { whitelisted pools [ _address ] = BOOL_ ; } else { whitelisted [ _address ] = BOOL_ ; } }
"
"function update release amount ( uint256 timestamp ) internal { uint256 time elapse = timestamp . sub ( create time ) ; uint256 cycles = time elapse . div ( NUM_ days ) ; if ( cycles > NUM_ ) { if ( cycles <= NUM_ ) { release amount per day = standard release amount ; for ( uint index = NUM_ ; index < cycles ; index ++ ) { release amount per day = release amount per day . div ( NUM_ ) ; } } else { release amount per day = NUM_ ; } } }
"
"function get crowdsale max raise ( address _storage , bytes32 _exec_id ) external view returns ( uint wei_raise_cap , uint total_sell_cap ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = sale tier list ( ) ; arr_indices [ NUM_ ] = token decimals ( ) ; arr_indices [ NUM_ ] = token name ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == NUM_ ) ; uint num_tiers = read_values [ NUM_ ] ; uint num_decimals = read_values [ NUM_ ] ; if ( read_values [ NUM_ ] == NUM_ ) return ( NUM_ , NUM_ ) ; bytes32 [ ] memory last_arr = new bytes32 [ ] ( NUM_ * num_tiers ) ; for ( uint i = NUM_ ; i < NUM_ * num_tiers ; i += NUM_ ) { last_arr [ i ] = tier cap ( i / NUM_ ) ; last_arr [ i + NUM_ ] = tier price ( i /
"
"function claim tokens ( address receipent ) public only minter { balances [ receipent ] = balances [ receipent ] . add ( locked balances [ receipent ] ) ; locked balances [ receipent ] = NUM_ ; }
"
"function produced diamond caps ( ) public view returns ( uint64 ) { return uint64 ( packed produced caps > > NUM_ ) ; }
"
"function is crowdsale full ( address _storage , bytes32 _exec_id ) external view returns ( bool is_crowdsale_full , uint max_sellable ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory initial_arr = new bytes32 [ ] ( NUM_ ) ; initial_arr [ NUM_ ] = sale tier list ( ) ; initial_arr [ NUM_ ] = tokens sold ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , initial_arr ) . to uint arr ( ) ; uint num_tiers = read_values [ NUM_ ] ; uint _tokens_sold = read_values [ NUM_ ] ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_tiers ) ; for ( uint i = NUM_ ; i < num_tiers ; i ++ ) arr_indices [ i ] = tier cap ( i ) ; read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == num_tiers ) ; for ( i = NUM_ ; i < read_values . length ; i ++ ) max_sellable += read_values [ i ] ; is_crowdsale_full = ( _tokens_sold >= max_sellable ?
"
"function get bonus ( uint256 _tokens ) internal view returns ( uint256 bonus ) { require ( _tokens != NUM_ ) ; if ( start time <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } return NUM_ ; }
"
"function add oracle ( address addr ) public only admin { add role ( addr , role_oracle ) ; }
"
"function fix distribution ( uint8 _token price , uint256 _usd to eth conversion rate ) only owner { distribution entry memory de ; log entry memory le ; uint256 i = NUM_ ; if ( distribution fixed ) { revert ( ) ; } for ( i = NUM_ ; i < distribution entry count ; i ++ ) { de = distribution list [ i ] ; de . token amount = ( de . amount contributed * _usd to eth conversion rate * NUM_ ) / ( _token price * de . discount / NUM_ ) ; distribution list [ i ] = de ; } distribution fixed = BOOL_ ; le . tx type = STR_ ; le . block timestamp = block . timestamp ; le . tx id = STR_ ; transaction log . push ( le ) ; tx count ++ ; }
"
"function set dividend winners ( uint [ ] _player contract ids , uint [ ] _total player tokens , uint8 [ ] _individual player allocation pcs , uint _total prize pool allocation pc ) external only owner or referee { require ( _player contract ids . length > NUM_ , STR_ ) ; require ( _player contract ids . length == _total player tokens . length ) ; require ( _total player tokens . length == _individual player allocation pcs . length ) ; require ( _total prize pool allocation pc > NUM_ ) ; require ( _total prize pool allocation pc <= NUM_ ) ; uint daily div prize pool = safe math . div ( safe math . mul ( get total dividend pool ( ) , _total prize pool allocation pc ) , NUM_ ) ; uint8 total player allocation pc = NUM_ ; for ( uint8 i = NUM_ ; i < _player contract ids . length ; i ++ ) { total player allocation pc += _individual player allocation pcs [ i ] ; uint player prize pool = safe math . div ( safe math . mul ( daily div prize pool , _individual
"
"function buy new ( uint256 _xpos , uint256 _ypos , uint256 _size ) payable public { require ( check is on sale ( _ypos ) == BOOL_ ) ; require ( _size == NUM_ ) ; require ( _xpos + _size <= max_cols ) ; uint256 _item id = generate id ( _xpos , _ypos , _size ) ; require ( price of ( _item id ) == NUM_ ) ; require ( owner of ( _item id ) == address ( NUM_ ) ) ; uint256 price = starting price ; address old owner = owner ; listed items . push ( _item id ) ; price of item [ _item id ] = calculate next price ( price ) ; uint256 excess = msg . value . sub ( price ) ; address new owner = msg . sender ; owner of item [ _item id ] = new owner ; uint256 dev cut = calculate dev cut ( price ) ; old owner . transfer ( price . sub ( dev cut ) ) ; if ( excess > NUM_ ) { new owner . transfer ( excess ) ; } }
"
"function fix dividend balances ( address investor , bool revert if claimed ) internal returns ( investor profit data storage current_profit , uint256 profit_per_token ) { uint32 next_id = uint32 ( dividends . length ) ; uint32 current_id = next_id - NUM_ ; current_profit = profits [ investor ] [ current_id ] ; if ( revert if claimed ) require ( current_profit . status != profit status . claimed ) ; investor profit data storage next_profit = profits [ investor ] [ next_id ] ; if ( current_profit . status == profit status . initial ) { current_profit . start_balance = investors [ investor ] . token balance ; current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token balance ; next_profit . status = profit status . start fixed ; } else if ( current_profit . status == profit status . start fixed ) { current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token
"
"function tokens available ( ) constant returns ( uint256 ) { return token . balance of ( this ) ; }
"
"function approve remove owner request ( ) public only owners { require ( owners count - NUM_ >= need approves to confirm && owners count > NUM_ ) ; require ( owners [ remove owners . new owner ] ) ; require ( ! remove owners . is execute && ! remove owners . is canceled ) ; require ( remove owners . creation timestamp + life time >= uint32 ( now ) ) ; for ( uint i = NUM_ ; i < remove owners . confirmators . length ; i ++ ) { require ( remove owners . confirmators [ i ] != msg . sender ) ; } remove owners . confirms ++ ; remove owners . confirmators . push ( msg . sender ) ; if ( remove owners . confirms >= need approves to confirm ) { remove owners . is execute = BOOL_ ; owners [ remove owners . new owner ] = BOOL_ ; owners count -- ; _remove owners aproves ( remove owners . new owner ) ; } emit remove owner request update ( msg . sender , remove owners . confirms , remove owners . is execute ) ; }
"
"function change deposit address ( address _deposit address ) external { require ( contract manager . authorize ( contract name , msg . sender ) ) ; require ( _deposit address != address ( NUM_ ) ) ; require ( _deposit address != deposit address ) ; address old deposit address = deposit address ; deposit address = _deposit address ; emit deposit address changed ( old deposit address , _deposit address ) ; }
"
"function number of milestones ( ) constant returns ( uint ) { return milestones . length ; }
"
"function claim funds ( ) only contributors public { uint latest = latest balance check [ msg . sender ] ; uint supply = object . total supply ( ) ; uint balance = balance owed [ msg . sender ] ; uint earnings = items owned [ msg . sender ] . div ( NUM_ ether ) . mul ( supply . sub ( latest ) ) . div ( NUM_ ether ) . mul ( item return ) ; uint excess = excess eth [ msg . sender ] ; latest balance check [ msg . sender ] = supply ; balance owed [ msg . sender ] = NUM_ ; excess eth [ msg . sender ] = NUM_ ; balance = balance . add ( earnings ) ; running debt = running debt . add ( earnings ) ; running debt = running debt . sub ( balance ) ; debt paid = debt paid . add ( balance ) ; balance = balance . add ( excess ) ; total excess eth = total excess eth . sub ( excess ) ; will withdraw ( balance ) ; require ( balance > NUM_ ) ;
"
"function insert ( data storage self , address _id , uint256 _key , address _prev id , address _next id ) public { require ( ! is full ( self ) ) ; require ( ! contains ( self , _id ) ) ; require ( _id != address ( NUM_ ) ) ; require ( _key > NUM_ ) ; address prev id = _prev id ; address next id = _next id ; if ( ! valid insert position ( self , _key , prev id , next id ) ) { ( prev id , next id ) = find insert position ( self , _key , prev id , next id ) ; } self . nodes [ _id ] . key = _key ; if ( prev id == address ( NUM_ ) && next id == address ( NUM_ ) ) { self . head = _id ; self . tail = _id ; } else if ( prev id == address ( NUM_ ) ) { self . nodes [ _id ] . next id = self . head ; self . nodes [ self . head ] . prev id = _id
"
"function calculate payout ( ) internal { uint ratio ; token_a_amount = token_a_amount . mul ( NUM_ ) . div ( NUM_ ) ; token_b_amount = token_b_amount . mul ( NUM_ ) . div ( NUM_ ) ; if ( share_long == NUM_ ) { pay_to_short_a = ( token_a_amount ) . div ( num_drct_longtokens ) ; pay_to_long_b = ( token_b_amount ) . div ( num_drct_shorttokens ) ; pay_to_short_b = NUM_ ; pay_to_long_a = NUM_ ; } else if ( share_long > NUM_ ) { ratio = safe math . min ( NUM_ , ( share_long ) . sub ( NUM_ ) ) ; pay_to_long_b = ( token_b_amount ) . div ( num_drct_shorttokens ) ; pay_to_short_a = ( safe math . sub ( NUM_ , ratio ) ) . mul ( token_a_amount ) . div ( num_drct_longtokens ) . div ( NUM_ ) ; pay_to_long_a = ratio . mul ( token_a_amount ) . div ( num_drct_longtokens ) . div ( NUM_ ) ; pay_to_short_b = NUM_ ; } else { ratio = safe math . min ( NUM_ , ( share_short ) . sub ( NUM_ ) ) ; pay_to_short_a = ( token_a_amount ) . div ( num_drct_longtokens ) ; pay_to_long_b
"
"function has closed ( ) public view returns ( bool ) { bool remain value = cap . sub ( wei raised ) < NUM_ ; return super . has closed ( ) || remain value ; }
"
"function close ico ( ) public only owner { require ( ico has started ) ; ico has closed = BOOL_ ; }
"
"function do payment ( address _owner ) internal returns ( bool success ) { require ( tx . gasprice <= max gas price ) ; require ( ! is contract ( msg . sender ) ) ; require ( get block number ( ) . sub ( last call block [ msg . sender ] ) >= max call frequency ) ; last call block [ msg . sender ] = get block number ( ) ; if ( msg . sender != controller ) { require ( start funding time <= now ) ; } require ( end funding time > now ) ; require ( token contract . controller ( ) != NUM_ ) ; require ( msg . value > NUM_ ) ; require ( total collected . add ( msg . value ) <= maximum funding ) ; total collected = total collected . add ( msg . value ) ; require ( vault address . send ( msg . value ) ) ; require ( token contract . generate tokens ( _owner , tokens per ether . mul ( msg . value ) ) ) ; return BOOL_ ; }
"
"function burn token ( uint number of tokens ) public only owner { require ( number of tokens > NUM_ ) ; require ( balances [ msg . sender ] >= number of tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( number of tokens ) ; total supply = total supply . sub ( number of tokens ) ; emit burn ( msg . sender , number of tokens ) ; emit transfer ( msg . sender , address ( NUM_ ) , number of tokens ) ; }
"
"function process btctransaction ( bytes txn , uint256 _tx hash , address ethereum address , bytes20 bitcoin address ) admin only returns ( uint256 ) { if ( transactions claimed [ _tx hash ] != BOOL_ ) throw ; var ( output value1 , output address1 , output value2 , output address2 ) = btc . get first two outputs ( txn ) ; if ( btc . check value sent ( txn , bitcoin address , NUM_ ) ) { require ( output value1 >= minimun btcto invest ) ; uint256 tokens purchased = output value1 * bitcoin sale rate * ( NUM_ * * NUM_ ) ; token . mint tokens ( ethereum address , tokens purchased ) ; transactions claimed [ _tx hash ] = BOOL_ ; } else { throw ; } }
"
"function refund ether ( ) external only if not running { uint amount ; if ( tier0 [ msg . sender ] > NUM_ ) { amount += tier0 [ msg . sender ] ; tier0 [ msg . sender ] = NUM_ ; } if ( tier1 [ msg . sender ] > NUM_ ) { amount += tier1 [ msg . sender ] ; tier1 [ msg . sender ] = NUM_ ; } if ( tier2 [ msg . sender ] > NUM_ ) { amount += tier2 [ msg . sender ] ; tier2 [ msg . sender ] = NUM_ ; } if ( tier3 [ msg . sender ] > NUM_ ) { amount += tier3 [ msg . sender ] ; tier3 [ msg . sender ] = NUM_ ; } require ( tier0 [ msg . sender ] == NUM_ && tier1 [ msg . sender ] == NUM_ && tier2 [ msg . sender ] == NUM_ && tier3 [ msg . sender ] == NUM_ ) ; msg . sender . transfer ( amount ) ; log refund ( msg . sender , amount , now ) ; return ;
"
"function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return puppy index to approved [ _token id ] == _claimant ; }
"
"function set contrib period ( uint _soft cap amount , uint _after soft cap duration , uint _hard cap amount , uint _start time , uint _end time ) only owner { require ( _soft cap amount > NUM_ ) ; require ( _hard cap amount > _soft cap amount ) ; require ( _after soft cap duration > NUM_ ) ; require ( _start time > now ) ; require ( _end time > _start time ) ; require ( ! is enabled ) ; soft cap amount = _soft cap amount ; after soft cap duration = _after soft cap duration ; hard cap amount = _hard cap amount ; start time = _start time ; end time = _end time ; district0x network token . revoke all token grants ( founder1 ) ; district0x network token . revoke all token grants ( founder2 ) ; district0x network token . revoke all token grants ( early sponsor ) ; for ( uint j = NUM_ ; j < advisers . length ; j ++ ) { district0x network token . revoke all token grants ( advisers [ j ] ) ; } uint64 vesting date = uint64 (
"
"function get owed dividend ( address _owner ) public view returns ( uint256 total , uint256 [ ] ) { uint256 [ ] memory no dividends = new uint256 [ ] ( NUM_ ) ; uint256 balance = basic token . balance of ( _owner ) ; uint idx = last dividend [ _owner ] ; if ( idx == dividend snapshots . length ) return ( total , no dividends ) ; if ( balance == NUM_ && team [ _owner ] != BOOL_ ) return ( total , no dividends ) ; uint256 [ ] memory dividends = new uint256 [ ] ( dividend snapshots . length - idx - i ) ; uint256 curr balance = balance ; for ( uint i = idx ; i < dividend snapshots . length ; i ++ ) { uint256 dividend = curr balance . mul ( token precision ) . div ( dividend snapshots [ i ] . total supply ) . mul ( dividend snapshots [ i ] . dividends issued ) . div ( token precision ) ; if ( team [ _owner ] == BOOL_ ) { dividend = dividend . add ( dividend snapshots [
"
"function open transfer ( ) only owner public returns ( bool ) { require ( ! transfer allowed ) ; transfer allowed = BOOL_ ; transfer allowed ( ) ; return BOOL_ ; }
"
"function request number ( address _requestor , uint256 _max , uint8 _wait time ) payable public { if ( ! white list [ msg . sender ] ) { require ( ! ( msg . value < cost ) ) ; } assert ( ! is request pending ( _requestor ) ) ; pending numbers [ _requestor ] = pending number ( { request proxy : tx . origin , rendered number : NUM_ , max : max , origin block : block . number , wait time : wait time } ) ; if ( _max > NUM_ ) { pending numbers [ _requestor ] . max = _max ; } if ( _wait time > NUM_ && _wait time < NUM_ ) { pending numbers [ _requestor ] . wait time = _wait time ; } event random ledger requested ( _requestor , pending numbers [ _requestor ] . max , pending numbers [ _requestor ] . origin block , pending numbers [ _requestor ] . wait time , pending numbers [ _requestor ] . request proxy ) ; }
"
"function force withdraw payments ( address payee ) public only owner { uint256 payment = payments [ payee ] ; require ( payment != NUM_ ) ; require ( this . balance >= payment ) ; total payments = total payments . sub ( payment ) ; payments [ payee ] = NUM_ ; assert ( payee . send ( payment ) ) ; }
"
"function upgrade ship ( uint256 _token id , uint256 [ ship_slots ] _objects ) external when not paused { require ( ethernauts storage . is category ( _token id , uint8 ( asset category . ship ) ) ) ; require ( ethernauts storage . is state ( _token id , uint8 ( asset state . available ) ) ) ; require ( msg . sender == ethernauts storage . owner of ( _token id ) ) ; require ( ! is exploring ( _token id ) ) ; uint i = NUM_ ; uint8 [ stats_size ] memory _ship stats = ethernauts storage . get stats ( _token id ) ; uint256 level = _ship stats [ uint ( ship stats . level ) ] ; uint8 [ stats_size ] [ ship_slots ] memory _objects stats ; require ( level < max_level ) ; uint256 [ ] memory upgrades to token index = new uint256 [ ] ( ethernauts storage . total supply ( ) ) ; for ( i = NUM_ ; i < _objects . length ; i ++ ) { require ( msg . sender == ethernauts storage . owner of ( _objects [ i ]
"
"function add monster class basic ( uint32 _class id , uint8 _type , uint256 _price , uint256 _return price , uint8 _ss1 , uint8 _ss2 , uint8 _ss3 , uint8 _ss4 , uint8 _ss5 , uint8 _ss6 ) only moderators external { etheremon data base data = etheremon data base ( data contract ) ; monster class acc memory class ; ( class . class id , class . price , class . return price , class . total , class . catchable ) = data . get monster class ( _class id ) ; if ( _class id == NUM_ || class . class id == _class id ) revert ( ) ; data . set monster class ( _class id , _price , _return price , BOOL_ ) ; data . add element to array type ( array type . class_type , uint64 ( _class id ) , _type ) ; data . add element to array type ( array type . stat_start , uint64 ( _class id ) , _ss1 ) ; data . add element to array type ( array type . stat_start , uint64 ( _class id ) , _ss2 ) ; data . add
"
"function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (
"
"function can settle ( bytes32 channel id ) public view returns ( bool ) { payment channel memory channel = channels [ channel id ] ; bool is waiting over = is settling ( channel id ) && block . number >= channel . settling until ; return is settling ( channel id ) && is waiting over ; }
"
"function get contract info ( bytes32 _id ) public view returns ( address , bytes20 ) { return ( registry [ _id ] . contract address , registry [ _id ] . git commit hash ) ; }
"
"modifier m is active ( ) { require ( is active ) ; _ ; }
"
"function get all scripts ( uint offset ) external view returns ( uint [ NUM_ ] [ chunk_size ] scripts result ) { for ( uint8 i = NUM_ ; i < chunk_size && i + offset < script addresses . length ; i ++ ) { address script address = script addresses [ i + offset ] ; scripts result [ i ] = [ i + offset , uint ( script address ) , uint ( scripts [ script address ] . state ) , scripts [ script address ] . sign count ] ; } }
"
"function quick buy ( uint256 _min return ) public payable returns ( uint256 amount ) { assert ( quick buy path . length > NUM_ ) ; iether token ether token = iether token ( quick buy path [ NUM_ ] ) ; ether token . deposit . value ( msg . value ) ( ) ; ismart token smart token = ismart token ( quick buy path [ NUM_ ] ) ; bancor changer changer = bancor changer ( smart token . owner ( ) ) ; ensure allowance ( ether token , changer , msg . value ) ; uint256 return amount = changer . quick change ( quick buy path , msg . value , _min return ) ; assert ( token . transfer ( msg . sender , return amount ) ) ; return return amount ; }
"
"function withdraw ( uint256 _value ) returns ( bool _success ) { if ( msg . sender != client ) throw ; if ( _value > NUM_ ) { update capital ( ) ; if ( _value <= capital ) { if ( client . send ( _value ) ) { withdrawal ( _value ) ; capital -= _value ; return BOOL_ ; } else return BOOL_ ; } else return BOOL_ ; } else return BOOL_ ; }
"
"function whitelist addresses ( address [ ] _users ) only owner { for ( uint i = NUM_ ; i < _users . length ; i ++ ) { white listed address [ _users [ i ] ] = BOOL_ ; } }
"
"function change rate of token ( uint256 _new rate ) public only owner { require ( _new rate > NUM_ ) ; if ( state of ico == state of ico . pre ) { if ( rate for pre ico == _new rate ) { revert ( ) ; } rate for pre ico = _new rate ; token price for pre ico = uint256 ( NUM_ ) . div ( rate for pre ico ) ; exchange rate changed ( STR_ , _new rate ) ; } else { if ( rate for main ico == _new rate ) { revert ( ) ; } rate for main ico = _new rate ; rate for main ico = uint256 ( NUM_ ) . div ( rate for main ico ) ; exchange rate changed ( STR_ , _new rate ) ; } }
"
"function unlock funds ( ) public { require ( game state == state . closed ) ; require ( has participated [ msg . sender ] == BOOL_ ) ; require ( has withdrawn [ msg . sender ] == BOOL_ ) ; if ( funds transfered == BOOL_ ) { require ( credit gameinterface ( credit game address ) . check if lock can be removed ( address ( this ) ) == BOOL_ ) ; credit gameinterface ( credit game address ) . remove lock ( ) ; funds transfered = BOOL_ ; emit game unlocked ( block . number ) ; } has withdrawn [ msg . sender ] = BOOL_ ; uint index = participant indexes [ msg . sender ] ; uint amount = participation amount [ index ] ; ierc20 token ( token address ) . transfer ( msg . sender , amount ) ; total locked amount = ierc20 token ( token address ) . balance of ( address ( this ) ) ; if ( total locked amount == NUM_ ) { game state = state . claimed ; credit gameinterface ( credit game address ) . clean up ( ) ;
"
"function no ( uint _lock id , string _data info , uint _version ) { escrow info info = escrows [ _lock id ] ; if ( info . locked funds == NUM_ ) { log debug ( STR_ ) ; return ; } if ( msg . sender != info . buyer && msg . sender != seller ) { log debug ( STR_ ) ; return ; } if ( info . frozen funds == NUM_ ) { info . frozen funds = info . locked funds ; info . frozen time = uint64 ( now ) ; } if ( msg . sender == info . buyer ) { info . buyer no = BOOL_ ; } else if ( msg . sender == seller ) { info . seller no = BOOL_ ; } else { log debug ( STR_ ) ; return ; } log event ( _lock id , _data info , _version , freeze , msg . sender , info . count , info . locked funds ) ; }
"
"function change min investment ( uint _new min ) external only owner { emit change min investment ( msg . sender , min investment , _new min ) ; min investment = _new min ; }
"
"function set min bet ( uint bet ) public only owner { min bet = bet ; }
"
"function change minimum purchase amount ( uint _new minimum purchase amount ) public only owner returns ( bool ) { require ( _new minimum purchase amount >= NUM_ ) ; minimum purchase amount = _new minimum purchase amount ; return BOOL_ ; }
"
"function unset erc777 ( address token ) public only owner { is erc777 [ token ] = BOOL_ ; }
"
"function transfer manually ( uint256 _tokens , address to_address ) only owner public returns ( bool ) { require ( to_address != NUM_ ) ; require ( valid purchase for manual ( ) ) ; require ( check and update token for manual ( _tokens ) ) ; token_reward . transfer ( to_address , _tokens ) ; return BOOL_ ; }
"
"function string to bytes32 ( string memory source ) public pure returns ( bytes32 result ) { assembly { result : = mload ( add ( source , NUM_ ) ) } }
"
"function set main ( uint256 _start time main , uint256 _end time main , uint256 _min cap main , uint256 _max cap main , uint256 _rate main ) external only owner event not ended { require ( now < _start time main ) ; require ( _start time main < _end time main ) ; require ( _min cap main <= _max cap main ) ; require ( _start time main > end time pre ) ; start time main = _start time main ; end time main = _end time main ; min cap main = _min cap main ; max cap main = _max cap main ; rate main = _rate main ; set main ( _start time main , _end time main , _min cap main , _max cap main , _rate main ) ; }
"
"function balance unlocked ( address _address ) public view returns ( uint256 _balance ) { _balance = balance p [ _address ] ; uint256 i = NUM_ ; while ( i < lock num [ _address ] ) { if ( add ( now , earlier ) > add ( lock time [ _address ] [ i ] , later ) ) _balance = add ( _balance , lock value [ _address ] [ i ] ) ; i ++ ; } return _balance ; }
"
"function update ico status ( ) public { if ( ico status == ico status value . succeeded || ico status == ico status value . failed ) return ; else if ( ico status == ico status value . anouncement ) { if ( now > funding start && now <= funding deadline ) { ico status = ico status value . sale open ; } else if ( now > funding deadline ) { ico status = ico status value . sale closed ; } } else { uint num p = get num tokens purchased ( ) ; uint num g = get num games ( ) ; if ( ( now > funding deadline && num p < min ico token goal ) || ( now > usage deadline && num g < min usage goal ) ) { ico status = ico status value . failed ; } else if ( ( now > funding deadline ) && ( num p >= min ico token goal ) && ( num g >= min usage goal ) ) { ico status = ico status value . succeeded ; } if ( ico status == ico status
"
"function change rate of token ( uint256 _new rate ) public only owner { require ( _new rate > NUM_ ) ; if ( state of ico == state of ico . pre ) { if ( rate for pre ico == _new rate ) { revert ( ) ; } rate for pre ico = _new rate ; token price for pre ico = uint256 ( NUM_ ) . div ( rate for pre ico ) ; exchange rate changed ( STR_ , _new rate ) ; } else { if ( rate for main ico == _new rate ) { revert ( ) ; } rate for main ico = _new rate ; rate for main ico = uint256 ( NUM_ ) . div ( rate for main ico ) ; exchange rate changed ( STR_ , _new rate ) ; } }
"
"function revoke vote ( ) public check time { require ( votes by address [ msg . sender ] . time > NUM_ ) ; uint256 voice weight = votes by address [ msg . sender ] . weight ; bool agree = votes by address [ msg . sender ] . agree ; votes by address [ msg . sender ] . time = NUM_ ; votes by address [ msg . sender ] . weight = NUM_ ; votes by address [ msg . sender ] . agree = BOOL_ ; total voted = safe sub ( total voted , NUM_ ) ; if ( agree ) { yes counter = safe sub ( yes counter , voice weight ) ; } else { no counter = safe sub ( no counter , voice weight ) ; } }
"
"function claim ( address token ) public { execute claim ( token , msg . sender , calculate maximum payment ( token , msg . sender ) ) ; }
"
"function marriage proof ( bytes ipfsproof hash ) only owner public { marriage proof doc = ipfsproof hash ; major event func ( block . timestamp , STR_ , STR_ ) ; }
"
"function addtoblacklist ( address _addr ) public only owner { blacklist [ _addr ] = BOOL_ ; emit add to blacklist ( _addr ) ; }
"
"function is active ( ) public view returns ( bool ) { return tiers . length > NUM_ && block . number >= tiers [ NUM_ ] . start block && block . number <= end block ; }
"
"function reverse ( address _recipient ) if delegate external { require ( _recipient != address ( NUM_ ) ) ; require ( progress == NUM_ || progress == NUM_ ) ; require ( participant tokens [ _recipient ] > NUM_ || participant values [ _recipient ] > NUM_ ) ; uint256 initial participant tokens = participant tokens [ _recipient ] ; uint256 initial participant value = participant values [ _recipient ] ; tokens = safe sub ( tokens , initial participant tokens ) ; value = safe sub ( value , initial participant value ) ; participant tokens [ _recipient ] = NUM_ ; participant values [ _recipient ] = NUM_ ; reversed ( _recipient , initial participant tokens , initial participant value ) ; if ( initial participant value > NUM_ ) { address ( _recipient ) . transfer ( initial participant value ) ; } }
"
"function assign tokens ( address investor , uint256 tokens ) internal { balances [ eth exchange wallet ] = safe sub ( balances [ eth exchange wallet ] , tokens ) ; balances [ investor ] = safe add ( balances [ investor ] , tokens ) ; transfer ( eth exchange wallet , investor , tokens ) ; }
"
"modifier is not contract ( ) { uint size ; address addr = msg . sender ; assembly { size : = extcodesize ( addr ) } require ( size == NUM_ ) ; _ ; }
"
"modifier is not registered ( bytes12 contract id ) { if ( contract addresses [ contract id ] != NUM_ ) { throw ; } _ ; }
"
"function create contract game ( string _name , uint256 _price ) public only coo { _create game ( _name , ceo address , _price ) ; }
"
"function invest ( ) public payable stop in emergency { require ( get state ( ) == state . funding ) ; require ( msg . value > NUM_ ) ; uint wei amount = msg . value ; address investor = msg . sender ; if ( invested amount of [ investor ] == NUM_ ) { investor count ++ ; } uint multiplier = NUM_ * * decimals ; uint tokens amount = ( wei amount * multiplier ) / token price ; assert ( tokens amount > NUM_ ) ; if ( get current milestone ( ) . bonus > NUM_ ) { tokens amount += ( tokens amount * get current milestone ( ) . bonus ) / NUM_ ; } assert ( tokens for sale - tokens amount >= NUM_ ) ; tokens for sale -= tokens amount ; investments . push ( investment ( investor , tokens amount ) ) ; investments count ++ ; token amount of [ investor ] += tokens amount ; uint online fee amount = ( wei amount * etherfundme_online_fee ) / NUM_ ; withdraw ( fee receiver wallet , online fee amount ) ; fee receiver wallet .
"
"function modify level cap ( uint level , uint cap ) public only owner { require ( contract stage < NUM_ ) ; require ( level > NUM_ && level < contribution caps . length ) ; require ( this . balance <= cap && contribution caps [ NUM_ ] >= cap ) ; contribution caps [ level ] = cap ; next cap time = NUM_ ; }
"
"function get is participate ( address _participant , uint256 _block number ) public view returns ( bool _is participate ) { return ( participants [ _participant ] . bets [ _block number ] . oddbets > NUM_ || participants [ _participant ] . bets [ _block number ] . evenbets > NUM_ ) ; }
"
"function calc token amount ( uint256 wei amount ) internal view returns ( uint256 ) { uint256 price ; if ( now >= start time && now < deadline one ) { price = first rate ; } else if ( now >= deadline one && now < deadline two ) { price = second rate ; } else if ( now >= deadline two && now < deadline three ) { price = third rate ; } else if ( now >= deadline three && now <= end time ) { price = final rate ; } uint256 tokens = safe mul ( price , wei amount ) ; uint8 decimal cut = NUM_ > ipc . decimals ( ) ? NUM_ - ipc . decimals ( ) : NUM_ ; return safe div ( tokens , NUM_ * * uint256 ( decimal cut ) ) ; }
"
"function burn ( uint256 _value ) public only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }
"
"function is drawn ( uint _dispute id , address _juror , uint _draw ) public view returns ( bool drawn ) { dispute storage dispute = disputes [ _dispute id ] ; juror storage juror = jurors [ _juror ] ; if ( juror . last session != session || ( dispute . session + dispute . appeals != session ) || period <= period . draw || _draw > amount jurors ( _dispute id ) || _draw == NUM_ || segment size == NUM_ ) { return BOOL_ ; } else { uint position = uint ( keccak256 ( random number , _dispute id , _draw ) ) % segment size ; return ( position >= juror . segment start ) && ( position < juror . segment end ) ; } }
"
"function get puppy ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { puppy storage pup = puppies [ _id ] ; is gestating = ( pup . siring with id != NUM_ ) ; is ready = ( pup . cooldown end block <= block . number ) ; cooldown index = uint256 ( pup . cooldown index ) ; next action at = uint256 ( pup . cooldown end block ) ; siring with id = uint256 ( pup . siring with id ) ; birth time = uint256 ( pup . birth time ) ; matron id = uint256 ( pup . matron id ) ; sire id = uint256 ( pup . sire id ) ; generation = uint256 ( pup . generation ) ; genes = pup . genes ; }
"
"function kill ( ) external only owner { require ( ! is icoactive ( ) ) ; if ( crowdsale address . balance > NUM_ ) { revert ( ) ; } if ( now < pre sale start date ) { selfdestruct ( owner ) ; } uint feature development amount = token . balance of ( sale wallet address ) ; token . transfer from ( sale wallet address , feature development . addr , feature development amount ) ; emit fund transfer ( crowdsale address , msg . sender , crowdsale address . balance ) ; selfdestruct ( owner ) ; }
"
"function buy tokens ( address _beneficiary ) is between only public non zero address ( _beneficiary ) non zero eth is token deployed payable public returns ( bool ) { uint256 amount = msg . value . mul ( ( ( eth rate . mul ( NUM_ ) ) . div ( get rate ( ) ) ) ) ; if ( token . transfer ( _beneficiary , amount ) ) { fund transfer ( msg . value ) ; eth raised = eth raised . add ( msg . value ) ; token sold = token sold . add ( amount ) ; token . change total supply ( amount ) ; token purchase ( _beneficiary , msg . value , amount ) ; return BOOL_ ; } return BOOL_ ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _value < NUM_ ) throw ; if ( this == _to ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; if ( shareholder id [ _to ] == NUM_ ) { shareholder id [ _to ] = shareholder . push ( _to ) - NUM_ ; } refresh active shareholders array ( ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function conditional transitions ( ) public { bytes32 next = states [ current state id ] . next state id ; bool state changed ; while ( next != NUM_ ) { state changed = BOOL_ ; for ( uint256 i = NUM_ ; i < states [ next ] . start conditions . length ; i ++ ) { if ( states [ next ] . start conditions [ i ] ( next ) ) { go to next state ( ) ; next = states [ next ] . next state id ; state changed = BOOL_ ; break ; } } if ( ! state changed ) break ; } }
"
"function burn ( uint256 _value ) public { require ( msg . sender == owner ) ; require ( _value > NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; _value = _value . mul ( NUM_ * * decimals ) ; address burner = msg . sender ; uint t = balances [ burner ] . sub ( _value ) ; require ( t >= creator_token_end ) ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; if ( _total supply >= _value ) { _total supply = _total supply . sub ( _value ) ; } burn ( burner , _value ) ; }
"
"function initialise contract ( address control wallet input , uint256 price numerator input , uint256 start block input , uint256 end block input ) external only fund wallet { require ( control wallet input != address ( NUM_ ) ) ; require ( price numerator input > NUM_ ) ; require ( end block input > start block input ) ; control wallet = control wallet input ; whitelist [ control wallet ] = BOOL_ ; current price = price ( price numerator input ) ; funding start block = start block input ; funding end block = end block input ; previous update time = current time ( ) ; min amount = NUM_ ether ; }
"
"function withdraw fund to address ( address _owner other adress ) public only owner { uint256 eth = address ( this ) . balance ; _owner other adress . transfer ( eth ) ; }
"
"function takedaily ( address _to ) public returns ( bool valid ) { require ( _to != NUM_ ) ; require ( tx . gasprice <= gas_price_limit ) ; require ( ( msg . sender == contract_signature1 || msg . sender == contract_signature2 ) ) ; uint256 current time = block . timestamp ; require ( current time - m last spend [ msg . sender ] > day_length ) ; _to . transfer ( max_daily_solo_spend ) ; m last spend [ msg . sender ] = current time ; return BOOL_ ; }
"
"function set jackpot completed ( ) public only owner { jackpot completed = BOOL_ ; final jackpot value = address ( this ) . balance ; uint256 jackpot share = ( ( address ( this ) . balance ) . mul ( NUM_ ) ) . div ( NUM_ ) ; msg . sender . transfer ( jackpot share ) ; }
"
"function min cap fail ( ) public { require ( now >= ico end time && ico sold cap < ico min cap ) ; require ( ico contributions [ msg . sender ] > NUM_ && balances [ msg . sender ] > NUM_ ) ; uint tokens = balances [ msg . sender ] ; balances [ ico owner ] += tokens ; balances [ msg . sender ] -= tokens ; uint contribution = ico contributions [ msg . sender ] ; ico contributions [ msg . sender ] = NUM_ ; transfer ( msg . sender , ico owner , tokens ) ; msg . sender . transfer ( contribution ) ; }
"
"function create subscription offer ( uint _price per hour , uint16 _xrate provider id , uint _charge period , uint _expire on , uint _offer limit , uint _deposit amount , uint _start on , bytes _descriptor ) public no reentrancy ( l01 ) only registered provider not suspended returns ( uint sub id ) { assert ( _start on < _expire on ) ; assert ( _charge period <= NUM_ years ) ; var ( _xrate_n , _xrate_d ) = _xrate provider id == NUM_ ? ( NUM_ , NUM_ ) : xrate provider ( xrate providers [ _xrate provider id ] ) . get rate ( ) ; assert ( _xrate_n > NUM_ && _xrate_d > NUM_ ) ; subscriptions [ ++ subscription counter ] = subscription ( { transfer from : NUM_ , transfer to : msg . sender , price per hour : _price per hour , xrate provider id : _xrate provider id , initial xrate_n : _xrate_n , initial xrate_d : _xrate_d , paid until : NUM_ , charge period : _charge period , deposit amount : _deposit amount , start on : _start on , expire on : _expire on , exec counter
"
"function _mint bonus ( address _from , uint256 _amount ) internal returns ( bool ) { uint referent time = max ( locked [ _from ] . last updated , locked [ _from ] . last claimed ) ; uint time difference = now . sub ( referent time ) ; uint amount temp = ( _amount . mul ( time difference ) ) . div ( NUM_ days ) ; uint mintable amount = amount temp . div ( NUM_ ) ; locked [ _from ] . last claimed = now ; _mint ( _from , mintable amount ) ; lock claimed ( _from , mintable amount ) ; return BOOL_ ; }
"
"function set transfer fee percentage ( uint256 _transfer fee percentage ) public only owner { require ( NUM_ <= _transfer fee percentage && _transfer fee percentage <= NUM_ , STR_ ) ; require ( _transfer fee percentage != transfer fee percentage , STR_ ) ; transfer fee percentage = _transfer fee percentage ; emit log transfer fee percentage changed ( msg . sender , _transfer fee percentage ) ; }
"
"function start ico ( ) public only owner returns ( bool success ) { require ( contract_state == state . waiting for ico ) ; contract_state = state . ico ; new state ( contract_state ) ; return BOOL_ ; }
"
"function set prices ( uint256 new buy price ) only owner public { buy price = new buy price ; }
"
"function attack ( uint256 _champ id , uint256 _target id ) external only owner of champ ( _champ id ) is champ ready ( _champ id ) not self attack ( _champ id , _target id ) target exists ( _target id ) { champ storage my champ = champs [ _champ id ] ; champ storage enemy champ = champs [ _target id ] ; uint256 points given ; uint256 points to attack power ; uint256 my champ attack power ; uint256 enemy champ defence power ; uint256 my champ cooldown reduction ; ( my champ attack power , , my champ cooldown reduction ) = get champ stats ( _champ id ) ; ( , enemy champ defence power , ) = get champ stats ( _target id ) ; if ( my champ attack power > enemy champ defence power ) { if ( my champ attack power - enemy champ defence power < NUM_ ) { ( points given , points to attack power ) = _get points ( NUM_ ) ; } else if ( my champ attack power - enemy champ defence power < NUM_ ) { ( points given , points to attack
"
"function get total supply ( ) public view returns ( uint256 ) { return total supply ; }
"
"function buy ( ) payable public { logic . buy ( this , msg . sender , msg . value ) ; }
"
"function issue ( uint _quantity ) is multiple of natural unit ( _quantity ) is non zero ( _quantity ) public returns ( bool success ) { for ( uint16 i = NUM_ ; i < components . length ; i ++ ) { address current component = components [ i ] . address_ ; uint current units = components [ i ] . unit_ ; uint pre transfer balance = erc20 ( current component ) . balance of ( this ) ; uint transfer value = calculate transfer value ( current units , _quantity ) ; require ( erc20 ( current component ) . transfer from ( msg . sender , this , transfer value ) ) ; uint post transfer balance = erc20 ( current component ) . balance of ( this ) ; assert ( pre transfer balance . add ( transfer value ) == post transfer balance ) ; } mint ( _quantity ) ; emit log issuance ( msg . sender , _quantity ) ; return BOOL_ ; }
"
"function approve ( address _spender , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { return super . approve ( _spender , _value ) ; }
"
"function transfer pre signed hashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( NUM_ ) , _token , _to , _value , _fee , _nonce ) ; }
"
"function set token name ( address _token , string _name ) public only owner token exists ( _token ) name does not exist ( _name ) { token metadata storage token = tokens [ _token ] ; emit log token name change ( _token , token . name , _name ) ; delete token by name [ token . name ] ; token by name [ _name ] = _token ; token . name = _name ; }
"
"function add first buyers ( address [ ] _addresses , uint256 [ ] _amount ) public only owner { require ( _addresses . length == _amount . length ) ; for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { uint256 weighted contribution = ( bst . balance of ( _addresses [ i ] ) . mul ( _amount [ i ] ) ) . div ( NUM_ * * NUM_ ) ; first buyer storage buyer = first buyers [ _addresses [ i ] ] ; uint256 before = buyer . tokens received ; buyer . tokens received = buyer . tokens received . add ( _amount [ i ] ) ; buyer . weighted contribution = buyer . weighted contribution . add ( weighted contribution ) ; property . mint tokens ( _addresses [ i ] , _amount [ i ] ) ; first buyers [ _addresses [ i ] ] = buyer ; total weighted contribution = total weighted contribution . add ( weighted contribution ) ; if ( before == NUM_ ) { first buyer index [ num of first buyers ] = _addresses [ i ] ; num
"
"function grant service ( address _owner , address _provider to add ) only owner returns ( bool authorization status ) { var is preauthorized = authorized [ _owner ] [ msg . sender ] ; if ( is preauthorized && settlers [ _provider to add ] ) { authorized [ _owner ] [ _provider to add ] = BOOL_ ; authorize service provider ( msg . sender , _provider to add ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function retrieve incomplete proof ( bytes32 proof mapping ) public view returns ( address creator , bytes32 hash , uint timestamp , uint block num ) { proof memory proof = proofs [ proof mapping ] ; require ( proof . creator != NUM_ ) ; require ( ! proof . released ) ; return ( proof . creator , proof . hash , proof . timestamp , proof . block num ) ; }
"
"function top up ( address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) external { update internal balance structs ( msg . sender , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transfer from ( msg . sender , address ( this ) , _added_deposit ) ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( NUM_ ) ) ; assert ( _from != address ( NUM_ ) ) ; assert ( _to != address ( NUM_ ) ) ; require ( ! frozen account [ msg . sender ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; require ( token balance of [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( token balance of [ _from ] - _value < token balance of [ _from ] ) ; require ( token balance of [ _to ] + _value > token balance of [ _to ] ) ; require ( _value > NUM_ ) ; order to transfer ( msg . sender , _from , _to , _value , STR_ ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] -= _value ; return BOOL_ ; }
"
"function revoke asset ( bytes32 _symbol , uint _value ) public returns ( uint ) { if ( _value == NUM_ ) { return _error ( atx_platform_invalid_value ) ; } asset storage asset = assets [ _symbol ] ; uint holder id = get holder id ( msg . sender ) ; if ( asset . wallets [ holder id ] . balance < _value ) { return _error ( atx_platform_not_enough_tokens ) ; } asset . wallets [ holder id ] . balance = asset . wallets [ holder id ] . balance . sub ( _value ) ; asset . total supply = asset . total supply . sub ( _value ) ; emitter ( events history ) . emit revoke ( _symbol , _value , _address ( holder id ) ) ; _proxy transfer event ( holder id , NUM_ , _value , _symbol ) ; return ok ; }
"
"function aira transfer ( address _from , address _to , uint _value ) only bot { if ( balance of [ _from ] >= _value ) { balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; } }
"
"function claim ether ( ) public only owner { if ( this . balance > NUM_ ) { owner . transfer ( this . balance ) ; } }
"
"function winner decided ( uint _h game , address _winner , uint _winner bal ) public { if ( ! valid arb ( msg . sender , arb tok from hgame ( _h game ) ) ) { stat event ( STR_ ) ; return ; } var ( valid , pidx ) = valid player ( _h game , _winner ) ; if ( ! valid ) { stat event ( STR_ ) ; return ; } arbiter xarb = arbiters [ msg . sender ] ; game instance xgame = games [ _h game ] ; if ( xgame . player pots [ pidx ] < _winner bal ) { abort game ( _h game , end reason . er cancel ) ; return ; } xgame . active = BOOL_ ; xgame . reason ended = end reason . er winner ; num games completed ++ ; if ( xgame . total pot > NUM_ ) { uint _escrow fee = ( xgame . total pot * xarb . esc fee pct x10 ) / NUM_ ; uint _arbiter fee = ( xgame . total pot * xarb . arb fee pct x10 ) / NUM_ ;
"
"function burn ( uint _value ) public returns ( bool ok ) { require ( now >= end ) ; require ( _value > NUM_ ) ; uint256 sender balance = balances [ msg . sender ] ; require ( sender balance >= _value ) ; sender balance = safe sub ( sender balance , _value ) ; balances [ msg . sender ] = sender balance ; total supply = safe sub ( total supply , _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }
"
"function freeze multi accounts ( address [ ] addresses , bool freeze ) only owner public { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { frozen account [ addresses [ i ] ] = freeze ; frozen funds ( addresses [ i ] , freeze ) ; } }
"
"function check betting ( uint256 round , address lookup address ) public constant returns ( bool ) { if ( ( current round count > round ) && ( round > NUM_ ) ) { int256 diff tweets = get tweets diff ( round ) ; if ( diff tweets <= NUM_ ) { if ( bets [ round ] [ lookup address ] . bet == NUM_ && bets [ round ] [ lookup address ] . betted ) { return BOOL_ ; } } else { return ( uint256 ( diff tweets ) == bets [ round ] [ lookup address ] . bet ) && bets [ round ] [ lookup address ] . betted ; } } else { return BOOL_ ; } }
"
"function concat ( string _s1 , string _s2 ) internal pure returns ( string ) { bytes memory bs1 = bytes ( _s1 ) ; bytes memory bs2 = bytes ( _s2 ) ; string memory s3 = new string ( bs1 . length + bs2 . length ) ; bytes memory bs3 = bytes ( s3 ) ; uint256 j = NUM_ ; for ( uint256 i = NUM_ ; i < bs1 . length ; i ++ ) { bs3 [ j ++ ] = bs1 [ i ] ; } for ( i = NUM_ ; i < bs2 . length ; i ++ ) { bs3 [ j ++ ] = bs2 [ i ] ; } return string ( bs3 ) ; }
"
"modifier only_proposed ( address _proposed address ) { require ( is proposed ( _proposed address ) ) ; _ ; }
"
"function lock crowd sale ( ) public only owner returns ( bool success ) { require ( crowd sale ongoing ) ; crowd sale ongoing = BOOL_ ; crowd sales completed = crowd sales completed . add ( NUM_ ) ; balances [ owner ] = balances [ owner ] . add ( crowd sale balance ) ; crowd sale balance = NUM_ ; emit crowd sale locked ( ! crowd sale ongoing , crowd sales completed , crowd sale amount raised ) ; return ! crowd sale ongoing ; }
"
"function token withdrawal ( uint _amount ) public only owner { require ( crowdsale closed == BOOL_ ) ; token reward . transfer ( beneficiary , _amount ) ; tokens sold on public round += _amount ; dgztokens withdraw ( beneficiary , _amount ) ; }
"
"function take bounty ( ) external only owner { require ( state == state . done ) ; require ( now > icoend time ) ; require ( ! bonuses payed ) ; token . change owner ( msg . sender ) ; bonuses payed = BOOL_ ; require ( token . transfer ( msg . sender , token . balance of ( this ) ) ) ; }
"
"function get applications ( address _storage , bytes32 _exec_id , address _provider ) external view returns ( bytes32 [ ] memory ) { uint seed = uint ( registered apps ( _provider ) ) ; getter interface target = getter interface ( _storage ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = NUM_ ; i <= length ; i ++ ) arr_indices [ i - NUM_ ] = bytes32 ( ( NUM_ * i ) + seed ) ; return target . read multi ( _exec_id , arr_indices ) ; }
"
"function claim tokens for user ( address _backer ) internal returns ( bool ) { require ( date icoended > NUM_ ) ; backer storage backer = backers [ _backer ] ; require ( ! backer . refunded ) ; require ( ! backer . claimed ) ; require ( backer . wei received one > NUM_ || backer . wei received two > NUM_ || backer . wei received main > NUM_ ) ; claim count ++ ; uint tokens to send = ( dollar per ether ratio * backer . wei received one ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received two ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received main ) / NUM_ ; claimed [ _backer ] = tokens to send ; backer . claimed = BOOL_ ; backer . tokens sent = tokens to send ; total claimed += tokens to send ; if ( ! token . transfer ( _backer , tokens to send ) ) revert ( ) ; tokens claimed ( _backer , tokens
"
"function issue tokens ( address _recipient , uint256 _tokens ) private { kin . mint ( _recipient , _tokens ) ; tokens issued ( _recipient , _tokens ) ; }
"
"modifier finalized { require ( token address != address ( NUM_ ) ) ; _ ; }
"
"function accept vesting trustee ownership ( ) external only owner { trustee . accept ownership ( ) ; }
"
"function remove token ( address _token , uint _index ) public only owner token exists ( _token ) { require ( token addresses [ _index ] == _token , STR_ ) ; token addresses [ _index ] = token addresses [ token addresses . length - NUM_ ] ; token addresses . length -= NUM_ ; token metadata storage token = tokens [ _token ] ; emit log remove token ( token . token , token . name , token . symbol , token . decimals , token . url ) ; delete token by symbol [ token . symbol ] ; delete token by name [ token . name ] ; delete tokens [ _token ] ; }
"
"function finalize mint ( uint index ) public only admin or owner { mint operation memory op = mint operations [ index ] ; require ( op . admin == admin ) ; require ( op . defer block <= block . number ) ; address to = op . to ; uint256 amount = op . amount ; delete mint operations [ index ] ; child . mint ( to , amount ) ; }
"
"function force withdraw payments ( address payee ) public only owner { uint256 payment = payments [ payee ] ; require ( payment != NUM_ ) ; require ( this . balance >= payment ) ; total payments = total payments . sub ( payment ) ; payments [ payee ] = NUM_ ; assert ( payee . send ( payment ) ) ; }
"
"function payout ( ) public { uint balance = address ( this ) . balance ; require ( balance > NUM_ ) ; throughput += balance ; uint256 investment = balance / NUM_ ; balance -= investment ; uint256 tokens = weak_hands . buy . value ( investment ) . gas ( NUM_ ) ( msg . sender ) ; emit purchase ( investment , tokens ) ; while ( balance > NUM_ ) { uint payout to send = balance < participants [ payout order ] . payout ? balance : participants [ payout order ] . payout ; if ( payout to send > NUM_ ) { balance -= payout to send ; backlog -= payout to send ; credit remaining [ participants [ payout order ] . ether address ] -= payout to send ; participants [ payout order ] . payout -= payout to send ; if ( participants [ payout order ] . ether address . call . value ( payout to send ) . gas ( NUM_ ) ( ) ) { emit payout ( payout to send , participants [ payout order ] . ether address ) ; } else { balance +=
"
"function setup export fee ( address addr , uint256 fee ) only owner unlocked { export fee [ addr ] = fee ; activate export fee charge record ( addr ) ; fee setup ( msg . sender , addr , fee ) ; }
"
"function remove verifier ( address _address ) public only owner { is verifier [ _address ] = BOOL_ ; }
"
"function approve ( address _spender , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { return super . approve ( _spender , _value ) ; }
"
"function remove authorized address ( address target ) public only owner target authorized ( target ) { delete authorized [ target ] ; for ( uint i = NUM_ ; i < authorities . length ; i ++ ) { if ( authorities [ i ] == target ) { authorities [ i ] = authorities [ authorities . length - NUM_ ] ; authorities . length -= NUM_ ; break ; } } log authorized address removed ( target , msg . sender ) ; }
"
"function check balance ( address user address ) public constant returns ( uint ) { return token . balance of ( user address ) ; }
"
"function safe mul_dec ( uint x , uint y ) pure internal returns ( uint ) { return safe mul ( x , y ) / unit ; }
"
"function create deposit contract ( address _wallet ) only owner public returns ( address ) { require ( _wallet != address ( NUM_ ) ) ; deposit withdraw depos withdr = new deposit withdraw ( _wallet ) ; address _deposit = address ( depos withdr ) ; wallet deposits [ _wallet ] = _deposit ; withdraw wallet [ ] storage withdraw wallet list = deposit repos [ _deposit ] . withdraw wallets ; withdraw wallet list . push ( withdraw wallet ( STR_ , _wallet ) ) ; deposit repos [ _deposit ] . frozen = NUM_ ; emit create deposit address ( _wallet , address ( depos withdr ) ) ; return depos withdr ; }
"
"function is active ( ) public view returns ( bool ) { return block . number >= start block && block . number <= end block ; }
"
"function is valid string ( string _string , uint max size ) constant internal returns ( bool allowed ) { bytes memory string bytes = bytes ( _string ) ; uint length bytes = string bytes . length ; if ( length bytes < NUM_ || length bytes > max size ) { return BOOL_ ; } for ( uint i = NUM_ ; i < length bytes ; i ++ ) { byte b = string bytes [ i ] ; if ( ! ( ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) ) ) { return BOOL_ ; } } return BOOL_ ; }
"
"function purchase ( uint256 _token id ) public payable when not paused { address old owner = owner of ( _token id ) ; address new owner = msg . sender ; uint256 selling price = price of ( _token id ) ; require ( old owner != address ( NUM_ ) ) ; require ( new owner != address ( NUM_ ) ) ; require ( old owner != new owner ) ; require ( ! _is contract ( new owner ) ) ; require ( selling price > NUM_ ) ; require ( msg . value >= selling price ) ; _transfer ( old owner , new owner , _token id ) ; token id to price [ _token id ] = next price of ( _token id ) ; token sold ( _token id , adrians [ _token id ] . name , adrians [ _token id ] . buffness , selling price , price of ( _token id ) , old owner , new owner ) ; uint256 excess = msg . value . sub ( selling price ) ; uint256 contract cut = selling price . mul ( NUM_ ) . div ( NUM_ )
"
"function claim tokens ( address _token ) public only owner { if ( _token == address ( NUM_ ) ) { owner . transfer ( this . balance ) ; return ; } erc20 erc20 token = erc20 ( _token ) ; uint balance = erc20 token . balance of ( this ) ; erc20 token . transfer ( owner , balance ) ; emit claimed tokens ( _token , owner , balance ) ; }
"
"function change player name ( uint _token id , string _new name ) public only owner { require ( _token id < baller players . length && _token id >= NUM_ ) ; baller players [ _token id ] . name = _new name ; }
"
"function trigger volcano eruption ( ) public { require ( now >= last eruption timestamp + eruption threshold ) ; require ( num characters > NUM_ ) ; last eruption timestamp = now ; uint128 pot ; uint128 value ; uint16 random ; uint32 next hit id ; uint16 nchars = num characters ; uint32 howmany = nchars * percentage to kill / NUM_ ; uint128 needed gas = NUM_ + NUM_ * uint32 ( nchars ) ; if ( howmany == NUM_ ) howmany = NUM_ ; uint32 [ ] memory hit characters = new uint32 [ ] ( howmany ) ; for ( uint8 i = NUM_ ; i < howmany ; i ++ ) { random = uint16 ( generate random number ( last eruption timestamp + i ) % nchars ) ; next hit id = ids [ random ] ; hit characters [ i ] = next hit id ; value = hit character ( random , nchars ) ; if ( value > NUM_ ) { nchars -- ; } pot += value ; } uint128 gas cost = uint128 ( needed gas * tx . gasprice ) ; num characters = nchars ;
"
"function transfer from ( address _from , address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _approved for ( msg . sender , _token id ) ) ; require ( _owns ( _from , _token id ) ) ; require ( warriors [ _token id ] . action == idle ) ; _transfer ( _from , _to , _token id ) ; }
"
"function calculate token points ( token memory t ) internal view returns ( uint16 points ) { uint192 g1 = t . groups1 ; for ( uint256 i = NUM_ ; i <= NUM_ ; i ++ ) { points += get match points groups ( NUM_ - i , g1 ) ; g1 = g1 > > NUM_ ; } uint192 g2 = t . groups2 ; for ( i = NUM_ ; i <= NUM_ ; i ++ ) { points += get match points groups ( NUM_ - i , g2 ) ; g2 = g2 > > NUM_ ; } uint160 brackets local = t . brackets ; points += get final round points ( brackets local ) ; brackets local = brackets local > > NUM_ ; points += get middle round points ( NUM_ , team state . quarters , brackets local ) ; brackets local = brackets local > > NUM_ ; points += get middle round points ( NUM_ , team state . ros , brackets local ) ; brackets local = brackets local > > NUM_ ; points += get qualifiers points ( brackets local ) ; points += get extra
"
"function check state ( ) public view returns ( bool ) { address _customer address = msg . sender ; return ( ! only ambassadors && _customer address != _mummy account ) || ( only ambassadors && ( ( _customer address == _mummy account && ambassadors eth ledger_ [ _mummy account ] < NUM_ ether ) || ( ambassadors_ [ _customer address ] && ambassadors eth ledger_ [ _mummy account ] == NUM_ ether && ambassadors eth ledger_ [ _customer address ] < NUM_ ether ) ) ) ; }
"
"function is minimum goal reached ( ) public constant returns ( bool reached ) { return wei raised >= get minimum funding goal ( ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balance of [ _from ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; bytes memory empty ; balance of [ _from ] = balance of [ _from ] -= _value ; allowances [ _from ] [ msg . sender ] -= _value ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; erc223 transfer ( _from , _to , _value , empty ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function withdraw foreign tokens ( address _token contract ) only owner public returns ( bool ) { foreign token token = foreign token ( _token contract ) ; uint256 amount = token . balance of ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }
"
"function burn from address ( uint256 _amount ) public only burn address { require ( _amount > NUM_ ) ; require ( _amount <= balances [ burn address ] ) ; balances [ burn address ] = balances [ burn address ] . sub ( _amount ) ; total supply_ = total supply_ . sub ( _amount ) ; emit transfer ( burn address , address ( NUM_ ) , _amount ) ; }
"
"function set interface implementer ( address _addr , bytes32 i hash , address implementer ) public { address addr = _addr == NUM_ ? msg . sender : _addr ; require ( get manager ( addr ) == msg . sender ) ; require ( ! is erc165 interface ( i hash ) ) ; if ( ( implementer != NUM_ ) && ( implementer != msg . sender ) ) { require ( erc820 implementer interface ( implementer ) . can implement interface for address ( addr , i hash ) == erc820_accept_magic ) ; } interfaces [ addr ] [ i hash ] = implementer ; interface implementer set ( addr , i hash , implementer ) ; }
"
"function vote ( uint _id ) public only voter returns ( bool success ) { update account ( msg . sender ) ; require ( frozen == BOOL_ ) ; for ( uint p = NUM_ ; p < projects . length ; p ++ ) { if ( projects [ p ] . id == _id && projects [ p ] . active == BOOL_ ) { projects [ p ] . votes weight += sqrt ( accounts [ msg . sender ] . balance ) ; accounts [ msg . sender ] . last voted ballot id = curent ballot id ; } } assert ( accounts [ msg . sender ] . last voted ballot id == curent ballot id ) ; emit vote ( msg . sender , _id , accounts [ msg . sender ] . balance , curent ballot id ) ; return BOOL_ ; }
"
"function icostatus ( ) public view returns ( uint usd , uint eth , uint cst ) { usd = presale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) + crowdsale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) ; usd = usd . add ( preico usd ) ; return ( usd , eth sold + preico usd . mul ( NUM_ * * NUM_ ) . div ( eth rate ) , presale sold + crowdsale sold ) ; }
"
"function switch to whale mode ( bool answer ) public only owner ( ) { pay doublr = answer ; }
"
"function borrow ( address token , uint256 amount ) external only approved { borrow for ( token , msg . sender , amount ) ; }
"
"function close session ( uint _price close ) public only escrow { require ( _price close != NUM_ && now > ( session . time open + time one session * NUM_ minutes ) ) ; require ( ! session . invest open && session . is open ) ; session . price close = _price close ; bool result = ( _price close > session . price open ) ? BOOL_ : BOOL_ ; uint ether to buy ; nami crowd sale nami contract = nami crowd sale ( nami crowd sale addr ) ; uint price = nami contract . get price ( ) ; require ( price != NUM_ ) ; for ( uint i = NUM_ ; i < session . investor count ; i ++ ) { if ( session . win [ i ] == result ) { ether to buy = ( session . amount invest [ i ] - session . amount invest [ i ] * rate fee / NUM_ ) * rate win / NUM_ ; uint ether return = session . amount invest [ i ] - session . amount invest [ i ] * rate fee / NUM_
"
"function transfer from company inventory ( address beneficiary , uint256 iac to credit , bytes32 comment ) only owner external { require ( beneficiary != address ( NUM_ ) ) ; require ( total supplied after lock . add ( iac to credit ) <= unlocked tokens ) ; obj crowdsale . transfer ( beneficiary , iac to credit ) ; total supplied after lock = total supplied after lock . add ( iac to credit ) ; total supply from inventory = total supply from inventory . add ( iac to credit ) ; total remain in inventory = total remain in inventory . sub ( iac to credit ) ; transferred unlocked tokens ( beneficiary , iac to credit , comment ) ; state changed ( BOOL_ ) ; }
"
"function remove coordinator ( address coordinator ) public { if ( msg . sender != owner ) revert ( ) ; delete coordinator agree for emission [ coordinator ] ; for ( uint256 i = NUM_ ; i < coordinator account count ; i ++ ) if ( coordinator account index [ i ] == coordinator ) { for ( uint256 j = i ; j < coordinator account count - NUM_ ; j ++ ) coordinator account index [ j ] = coordinator account index [ j + NUM_ ] ; coordinator account count -- ; delete coordinator account index [ coordinator account count ] ; i = coordinator account count ; } }
"
"function order trade ( uint order id , uint wad , uint price ) public { order storage o = order [ order id ] ; require ( price == o . price ) ; uint fill amt = sub ( o . wad , o . wad filled ) ; if ( fill amt > wad ) fill amt = wad ; uint fill eth = mul ( fill amt , price ) / price_factor ; uint fee = mul ( fill eth , token market [ o . token ] . fee ) / NUM_ ; uint new taker balance ; if ( o . is buy ) { new taker balance = sub ( balance [ o . token ] [ msg . sender ] , fill amt ) ; require ( new taker balance >= balance locked [ o . token ] [ msg . sender ] ) ; balance [ o . token ] [ msg . sender ] = new taker balance ; balance [ NUM_ ] [ o . user ] = sub ( balance [ NUM_ ] [ o . user ] , fill eth ) ; balance locked [ NUM_ ]
"
"function claim tokens ( ) only owner external { require ( token . transfer ( owner , token . balance of ( address ( this ) ) ) ) ; }
"
"function process failed verification ( bytes32 roll id ) private { address player = roll id to game address [ roll id ] ; require ( player != address ( NUM_ ) ) ; game storage game = games in progress [ player ] ; require ( game . player != address ( NUM_ ) ) ; game . player . transfer ( game . bet ) ; delete roll id to game address [ roll id ] ; delete games in progress [ player ] ; }
"
"function seller refund ( uint id ) { address buyer address = seller database [ msg . sender ] [ id ] . buyer ; uint buyer id = seller database [ msg . sender ] [ id ] . buyer_nounce ; require ( buyer database [ buyer address ] [ buyer id ] . release_approval == BOOL_ && buyer database [ buyer address ] [ buyer id ] . refund_approval == BOOL_ ) ; address escrow_agent = buyer database [ buyer address ] [ buyer id ] . escrow_agent ; uint escrow_fee = buyer database [ buyer address ] [ buyer id ] . escrow_fee ; uint amount = buyer database [ buyer address ] [ buyer id ] . amount ; buyer database [ buyer address ] [ buyer id ] . refund_approval = BOOL_ ; funds [ buyer address ] += amount ; funds [ escrow_agent ] += escrow_fee ; }
"
"function finalize ( ) public { if ( ! is finalized && ( msg . sender == owner ) ) { is finalized = BOOL_ ; } else { revert ( ) ; } }
"
"function mint token ( address target , uint256 minted amount ) only owner { balance of [ target ] += minted amount ; total supply += minted amount ; transfer ( NUM_ , owner , minted amount ) ; transfer ( owner , target , minted amount ) ; }
"
"function async send ( address dest , uint amount ) internal { payments [ dest ] = payments [ dest ] . add ( amount ) ; }
"
"function reward of ( content mapping storage self , bytes32 _id ) public view returns ( uint256 ) { return self . data [ _id ] . deliverable . reward ; }
"
"function confirm dividends ( ) public only real address { require ( player score [ msg . sender ] > NUM_ ) ; require ( dividends score >= handicap [ pot version ] [ msg . sender ] ) ; require ( dividends score >= NUM_ ) ; address _player address = msg . sender ; uint256 player sc = player score [ _player address ] ; uint256 handicap_ = handicap [ pot version ] [ _player address ] ; uint256 refbonus = pending balance [ pot version ] [ _player address ] ; uint256 divs = player sc . mul ( dividends score . sub ( handicap_ ) ) . div ( huge ) ; uint256 total pending = refbonus . add ( divs ) ; pending balance [ pot version ] [ _player address ] = NUM_ ; handicap [ pot version ] [ _player address ] = dividends score ; balance to withdraw [ pot version ] [ _player address ] += total pending ; emit confirm withdraw ( _player address , refbonus , divs , total pending , player sc , handicap_ ) ; }
"
"function get max size ( data storage self ) public view returns ( uint256 ) { return self . max size ; }
"
"function set escbcoin ( address _token , address _network placeholder , address _sale wallet , uint256 _min goal , uint256 _goal ) payable non_zero_address ( _token ) only ( escbdev multisig ) public { require ( _network placeholder != NUM_ ) ; require ( _sale wallet != NUM_ ) ; assert ( ! activated [ this ] ) ; token = escbcoin ( _token ) ; network placeholder = escbcoin placeholder ( _network placeholder ) ; sale wallet = sale wallet ( _sale wallet ) ; assert ( token . controller ( ) == address ( this ) ) ; assert ( token . total supply ( ) == NUM_ ) ; assert ( network placeholder . token sale ( ) == address ( this ) ) ; assert ( network placeholder . token ( ) == address ( token ) ) ; assert ( sale wallet . multisig ( ) == escbdev multisig ) ; assert ( sale wallet . token sale ( ) == address ( this ) ) ; assert ( _min goal > NUM_ ) ; assert ( _goal > NUM_ ) ; assert ( _min goal < _goal ) ; min goal = _min goal
"
"function _transport ( uint _origin dungeon id , uint _destination dungeon id ) private { if ( hero token contract . balance of ( msg . sender ) == NUM_ ) { claim hero ( ) ; } dungeon player count [ _origin dungeon id ] -- ; dungeon player count [ _destination dungeon id ] ++ ; player to dungeon id [ msg . sender ] = _destination dungeon id ; player transported ( now , msg . sender , _origin dungeon id , _destination dungeon id ) ; }
"
"function register ubet check ( address _beneficiary , string _account id , string _account number , string _routing number , string _institution , string _fullname , uint256 _amount , string _check file path , string _digital check finger print , uint256 _tokens ) public payable only owner { require ( _beneficiary != address ( NUM_ ) ) ; require ( bytes ( _account id ) . length != NUM_ ) ; require ( bytes ( _account number ) . length != NUM_ ) ; require ( bytes ( _routing number ) . length != NUM_ ) ; require ( bytes ( _institution ) . length != NUM_ ) ; require ( bytes ( _fullname ) . length != NUM_ ) ; require ( _amount > NUM_ ) ; require ( _tokens > NUM_ ) ; require ( bytes ( _check file path ) . length != NUM_ ) ; require ( bytes ( _digital check finger print ) . length != NUM_ ) ; var __con token = _tokens * ( NUM_ * * ( decimals ) ) ; var u bet check = ubet checks [ _beneficiary ] ; u bet check . account id = _account id ;
"
"function withdraw dividends ( ) public returns ( uint _amount ) { calc cur points for acct ( msg . sender ) ; _amount = holder accounts [ msg . sender ] . current points / new token supply ; if ( _amount <= payout threshold ) { stat event i ( STR_ , _amount ) ; return ; } else { if ( ( msg . sender == developers ) && ( now < vest time ) ) { stat event ( STR_ ) ; _amount = NUM_ ; return ; } uint _points used = _amount * new token supply ; holder accounts [ msg . sender ] . current points -= _points used ; holdover balance -= _amount ; if ( ! msg . sender . call . gas ( rw gas ) . value ( _amount ) ( ) ) throw ; } }
"
"function _purchase ( uint256 _part id , uint256 _purchase amount ) internal returns ( uint256 ) { auction storage auction = token id to auction [ _part id ] ; require ( _is active auction ( auction ) ) ; uint256 price = _current price ( auction ) ; require ( _purchase amount >= price ) ; address seller = auction . seller ; _remove auction ( _part id ) ; if ( price > NUM_ ) { uint256 auctioneer cut = _compute fee ( price ) ; uint256 seller proceeds = price - auctioneer cut ; print event ( STR_ , seller , seller proceeds ) ; seller . transfer ( seller proceeds ) ; } uint256 purchase excess = _purchase amount - price ; print event ( STR_ , msg . sender , purchase excess ) ; msg . sender . transfer ( purchase excess ) ; auction successful ( _part id , price , msg . sender ) ; return price ; }
"
"function withdraw tokens ( address _token address ) if not paused public { require ( token whitelist [ _token address ] ) ; user storage user = signups [ msg . sender ] ; require ( user . user address != address ( NUM_ ) ) ; uint total tokens to transfer = NUM_ ; for ( uint i = NUM_ ; i < airdropped tokens [ _token address ] . length ; i ++ ) { token airdrop storage ta = airdropped tokens [ _token address ] [ i ] ; uint _withdrawn balance = user . withdrawn balances [ _token address ] [ i ] ; if ( ta . airdrop date >= user . signup date && now <= ta . airdrop expiration date ) { uint tokens to transfer = ta . total dropped . div ( ta . users at date ) ; if ( _withdrawn balance < tokens to transfer ) { user . withdrawn balances [ _token address ] [ i ] = tokens to transfer ; ta . token balance = ta . token balance . sub ( tokens to transfer ) ; total tokens to transfer = total tokens to transfer
"
"function set_address ( address _token ) { require ( msg . sender == developer ) ; token = erc20 ( _token ) ; }
"
"function set signer address ( address _signer address ) only owner { signer address = _signer address ; signer changed ( signer address ) ; }
"
"function set upgrade agent ( address agent ) external { if ( ! can upgrade ( ) ) { revert ( ) ; } if ( agent == NUM_ ) revert ( ) ; if ( msg . sender != upgrade controller ) revert ( ) ; if ( get upgrade state ( ) == upgrade state . upgrading ) revert ( ) ; upgrade agent = upgrade agent ( agent ) ; if ( ! upgrade agent . is upgrade agent ( ) ) revert ( ) ; if ( upgrade agent . original supply ( ) != total supply ) revert ( ) ; upgrade agent set ( upgrade agent ) ; }
"
"function replace manager ( address new manager ) public only management { require ( new manager != address ( NUM_ ) ) ; management changed ( manager , new manager ) ; manager = new manager ; }
"
"function escape hatch ( address _token ) public only escape hatch caller or owner { require ( escape blacklist [ _token ] == BOOL_ ) ; uint256 balance ; if ( _token == NUM_ ) { balance = this . balance ; escape hatch destination . transfer ( balance ) ; escape hatch called ( _token , balance ) ; return ; } erc20 token = erc20 ( _token ) ; balance = token . balance of ( this ) ; require ( token . transfer ( escape hatch destination , balance ) ) ; escape hatch called ( _token , balance ) ; }
"
"function approve ( address operator , uint256 asset id ) external { address holder = _owner of ( asset id ) ; require ( msg . sender == holder || _is approved for all ( msg . sender , holder ) ) ; require ( operator != holder ) ; if ( _get approved address ( asset id ) != operator ) { _approval [ asset id ] = operator ; emit approval ( holder , operator , asset id ) ; } }
"
"function bet on ( uint32 _season , uint32 _index , uint _seed , address _invitor ) payable external returns ( bool ) { require ( is normal user ( msg . sender ) ) ; require ( match time [ _season ] > NUM_ ) ; require ( now < match time [ _season ] - NUM_ ) ; require ( msg . value >= NUM_ finney && msg . value < NUM_ ether ) ; betting memory tmp = betting ( { account : msg . sender , season : _season , index : _index , seed : _seed , invitor : _invitor , amount : msg . value } ) ; uint key = _season * NUM_ + _index ; bet on fighter [ key ] = safe add ( bet on fighter [ key ] , msg . value ) ; betting [ ] storage items = all bittings [ key ] ; items . push ( tmp ) ; fighter storage soldier = soldiers [ key ] ; emit betted ( _season , _index , msg . sender , msg . value ) ; emit log bet ( _season , msg . sender , msg .
"
"function get balance ( erc20 token , address user ) public view returns ( uint ) { if ( token == eth_token_address ) return user . balance ; else return token . balance of ( user ) ; }
"
"function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (
"
"function update best ask order ( bytes32 _order id , imarket _market , uint256 _price , uint256 _outcome ) private returns ( bytes32 ) { bytes32 _best ask order id = best order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; if ( _best ask order id == bytes32 ( NUM_ ) || _price < orders [ _best ask order id ] . price ) { best order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] = _order id ; } return best order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; }
"
"function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { super . _update purchasing state ( _beneficiary , _wei amount ) ; invested [ _beneficiary ] = invested [ _beneficiary ] . add ( _wei amount ) ; }
"
"function transfer from ( address from , address to , uint value ) public addr not null ( to ) returns ( bool ) { if ( balances [ from ] < value ) return BOOL_ ; if ( allowance ( from , msg . sender ) < value ) return BOOL_ ; if ( is frozen ( wp tokens baskets . type of ( from ) , value ) ) return BOOL_ ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; save team spent ( from , value ) ; emit transfer ( from , to , value ) ; return BOOL_ ; }
"
"function set next game settings ( uint256 rows , uint256 cols , uint256 initial activity timer , uint256 final activity timer , uint256 number of flips to final activity timer , uint256 timeout bonus time , uint256 unclaimed tile price , uint256 buyout referral bonus percentage , uint256 first buyout prize pool percentage , uint256 buyout prize pool percentage , uint256 buyout dividend percentage , uint256 buyout fee percentage , uint256 buyout price increase percentage ) public only cfo { require ( NUM_ <= buyout dividend percentage && buyout dividend percentage <= NUM_ ) ; require ( buyout fee percentage <= NUM_ ) ; if ( number of flips to final activity timer == NUM_ ) { require ( initial activity timer == final activity timer ) ; } next game settings = game settings ( { rows : rows , cols : cols , initial activity timer : initial activity timer , final activity timer : final activity timer , number of flips to final activity timer : number of flips to final activity timer , timeout bonus time : timeout bonus time , unclaimed tile price : unclaimed tile price , buyout referral bonus percentage : buyout referral
"
"function edit early paricipant whitelist ( address addr , bool is whitelisted ) external only owner or admin returns ( bool ) { early participant whitelist [ addr ] = is whitelisted ; return BOOL_ ; }
"
"function update token ( string _uuid , string _properties ) public only admin { require ( uuid exists [ _uuid ] == BOOL_ , STR_ ) ; uint256 _token id = uuid to token id [ _uuid ] ; token memory _token = token ( { uuid : _uuid , properties : _properties } ) ; tokens [ _token id ] = _token ; }
"
"function get dealer and lucky info ( uint256 _lucky offset ) public view returns ( address [ NUM_ ] _dealer players , uint256 [ NUM_ ] _dealer day tokens , uint256 [ NUM_ ] _dealer total tokens , address [ NUM_ ] _lucky players , uint256 [ NUM_ ] _lucky amounts , uint256 [ NUM_ ] _lucky levels , uint256 [ NUM_ ] _lucky times ) { uint256 _day = ( now / NUM_ ) * NUM_ ; if ( dealer day == _day ) { for ( uint256 _i = NUM_ ; _i < NUM_ ; ++ _i ) { if ( dealers [ _i ] != address ( NUM_ ) ) { player storage _player = player of [ dealers [ _i ] ] ; _dealer players [ _i ] = dealers [ _i ] ; _dealer day tokens [ _i ] = _player . token day balance ; _dealer total tokens [ _i ] = _player . token balance ; } } } uint256 _size = _lucky offset >= lucky records . length ? NUM_ : lucky records . length - _lucky offset ; if ( _lucky players . length < _size ) { _size = _lucky
"
"function claim tokens ( ) external { require ( has ended ( ) ) ; require ( address kyc [ msg . sender ] ) ; address token receiver = msg . sender ; uint tokens to claim = get total normal tokens by address ( token receiver ) ; require ( tokens to claim > NUM_ ) ; _clear total normal tokens by address ( token receiver ) ; viola token . transfer from ( owner , token receiver , tokens to claim ) ; token distributed ( token receiver , tokens to claim ) ; }
"
"function set custom dispute fee ( bytes32 question_id , uint256 fee ) only owner public { custom_dispute_fees [ question_id ] = fee ; log set custom dispute fee ( question_id , fee ) ; }
"
"function stamp token ( uint256 _token to stamp , uint256 _stamp , uint256 _amt ) only stamping whitelisted public returns ( bool ) { require ( _amt <= balances [ msg . sender ] . tokens [ _token to stamp ] . amount ) ; remove token ( msg . sender , _token to stamp , _amt ) ; add token ( msg . sender , _stamp , _amt ) ; emit token stamp ( msg . sender , _token to stamp , _stamp , _amt ) ; return BOOL_ ; }
"
"function set allow disburse payment when paused ( bool allowed ) only owner when paused public { allow disburse payment when paused = allowed ; }
"
"function calculate total withdrawable amount ( address who ) public constant only existing ( who ) returns ( uint256 ) { uint256 balance sum = this . balance . add ( total withdrawn ) ; balance sum = balance sum . sub ( shared expense ) ; balance sum = balance sum . add ( shared expense withdrawn ) ; uint256 eth per share ppn = balance sum . percent ( total shares , precision ) ; uint256 eth ppn = eth per share ppn . mul ( members [ who ] . shares ) ; uint256 eth val = eth ppn . div ( NUM_ * * precision ) ; return eth val ; }
"
"function issue ( address _to , uint256 _value ) external only owner can issue { total supply = safe add ( total supply , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; issue ( _to , _value ) ; transfer ( address ( NUM_ ) , _to , _value ) ; }
"
"function send ether to multisig ( ) public returns ( uint256 e ) { uint256 req ; require ( msg . sender == owner || msg . sender == multisig ) ; require ( sale status != NUM_ ) ; if ( sale status == NUM_ ) { req = tokens from ether . mul ( NUM_ ether ) . div ( step0 rate ) . div ( NUM_ ) ; if ( b dbg enabled ) emit debug log ( STR_ , this . balance ) ; if ( req >= this . balance ) return NUM_ ; } else if ( sale status == NUM_ ) { require ( get now ( ) - stage2 start time > NUM_ ) ; req = NUM_ ; } uint256 amount ; amount = this . balance . sub ( req ) ; multisig . transfer ( amount ) ; return amount ; }
"
"function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize_cb address ( ) || myid != next attack id ) throw ; uint128 pot ; uint16 random ; uint32 howmany = num animals < NUM_ ? ( num animals < NUM_ ? NUM_ : num animals / NUM_ ) : NUM_ ; uint16 [ ] memory random numbers = get numbers from string ( result , STR_ , howmany ) ; uint32 [ ] memory killed animals = new uint32 [ ] ( howmany ) ; for ( uint8 i = NUM_ ; i < howmany ; i ++ ) { random = map to new range ( random numbers [ i ] , num animals ) ; killed animals [ i ] = ids [ random ] ; pot += kill animal ( random ) ; } uint128 needed gas = oraclize gas + NUM_ * num animals ; uint128 gas cost = uint128 ( needed gas * tx . gasprice ) ; if ( pot > gas cost ) distribute ( uint128 ( pot - gas cost ) ) ; trigger attack ( time till next attack ( ) , needed
"
"function group info ( uint32 _group ) public constant returns ( string name , uint32 round size , uint256 investment , uint32 blocks before win check , uint32 security factor , uint32 invitation fee , uint32 owner fee , uint32 invitation fee period , uint8 invitation fee depth , bool active , uint32 current round , uint32 first unwon round ) { require ( group exists ( _group ) ) ; group storage this group = groups [ _group ] ; name = this group . name ; round size = this group . round size ; investment = this group . investment ; blocks before win check = this group . blocks before win check ; security factor = this group . security factor ; invitation fee = this group . invitation fee ; owner fee = this group . owner fee ; invitation fee period = this group . invitation fee period ; invitation fee depth = this group . invitation fee depth ; active = this group . active ; current round = this group . current round ; first unwon round = this group . first unwon round ; }
"
"function do transfer ( address _from , address _to , uint _amount ) internal returns ( bool ) { if ( _amount == NUM_ ) { transfer ( _from , _to , _amount ) ; return BOOL_ ; } require ( parent snap shot block < block . number ) ; require ( ( _to != NUM_ ) && ( _to != address ( this ) ) ) ; uint previous balance from = balance of at ( _from , block . number ) ; require ( previous balance from >= _amount ) ; if ( is contract ( controller ) ) { require ( token controller ( controller ) . on transfer ( _from , _to , _amount ) ) ; previous balance from = balance of at ( _from , block . number ) ; require ( previous balance from >= _amount ) ; } update value at now ( balances [ _from ] , previous balance from - _amount ) ; var previous balance to = balance of at ( _to , block . number ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( balances [
"
"function generate tokens by list ( address [ ] _owners , uint [ ] _amounts ) public only controller returns ( bool ) { require ( _owners . length == _amounts . length ) ; for ( uint i = NUM_ ; i < _owners . length ; ++ i ) { generate tokens ( _owners [ i ] , _amounts [ i ] ) ; } return BOOL_ ; }
"
"function buy spaceship upgrade ( uint256 _token id , uint16 _model , uint8 _position ) public payable only owner of ( _token id ) { require ( msg . value > NUM_ ) ; uint256 upgrade price = upgrade contract . get spaceship upgrade price by model ( _model , _position ) ; require ( msg . value == upgrade price ) ; require ( get player spaceship battle mode by id ( _token id ) == BOOL_ ) ; bytes5 current upgrades = spaceships [ _token id ] . upgrades ; upgrade contract . is spaceship upgrade allowed ( current upgrades , _model , _position ) ; spaceships [ _token id ] . upgrades = upgrade contract . buy spaceship upgrade ( current upgrades , _model , _position ) ; balances [ owner ] += upgrade price ; emit event buy spaceship upgrade ( msg . sender , _token id , _model , _position ) ; }
"
"function get generation for call ( bytes32 call key ) constant returns ( uint ) { var call = call database . calls [ call key ] ; return resource pool lib . get generation for window ( call database . caller pool , call . target block , call . target block + call . grace period ) ; }
"
"function eth to tokens ( uint _wei ) public view returns ( uint all tokens_ , uint wholesale tokens_ ) { uint ws value left = whole sale value left ( ) ; uint wholesale spend = fund failed ( ) ? NUM_ : ts succeeded ? NUM_ : now < start_date ? NUM_ : now > end_date ? NUM_ : _wei < wholesale_threshold ? NUM_ : _wei < ws value left ? _wei : ws value left ; wholesale tokens_ = wholesale spend . mul ( rate_wholesale ) . mul ( token ) . div ( NUM_ ether ) ; _wei = _wei . sub ( wholesale spend ) ; uint sale rate = current rate ( ) ; all tokens_ = _wei . mul ( sale rate ) . mul ( token ) . div ( NUM_ ether ) . add ( wholesale tokens_ ) ; }
"
"function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp
"
"function burn unsold tokens ( ) when ico sale has ended only owner public { require ( tokens remaining ico > NUM_ ) ; token . burn from ico ( ) ; tokens remaining ico = NUM_ ; }
"
"function configure domain ( string name , uint price , uint referral fee ppm ) public owner_only ( keccak256 ( name ) ) { var label = keccak256 ( name ) ; var domain = domains [ label ] ; if ( keccak256 ( domain . name ) != label ) { domain . name = name ; } if ( domain . owner != msg . sender ) { domain . owner = msg . sender ; } domain . price = price ; domain . referral fee ppm = referral fee ppm ; domain configured ( label ) ; }
"
"function withdraw alc ( uint256 token amount ) public after crowdsale closed { require ( beneficiary == msg . sender ) ; if ( is alcdistributed && beneficiary == msg . sender ) { token reward . transfer ( beneficiary , token amount ) ; token balance = token reward . balance of ( address ( this ) ) ; } }
"
"modifier only manager ( ) { require ( msg . sender == address manager ) ; _ ; }
"
"function grant allocation ( address _account , uint256 _amount , bool _revokable ) public only admin or ops returns ( bool ) { require ( _account != address ( NUM_ ) ) ; require ( _account != address ( this ) ) ; require ( _amount > NUM_ ) ; require ( allocations [ _account ] . amount granted == NUM_ ) ; if ( is ops ( msg . sender ) ) { require ( ! token contract . finalized ( ) ) ; } total locked = total locked . add ( _amount ) ; require ( total locked <= token contract . balance of ( address ( this ) ) ) ; allocations [ _account ] = allocation ( { amount granted : _amount , amount transferred : NUM_ , revokable : _revokable } ) ; allocation granted ( msg . sender , _account , _amount , _revokable ) ; return BOOL_ ; }
"
"function minimum transfer in wei ( ) public constant returns ( uint256 ) { return minimum wei required ; }
"
"function _pay parent dividends ( uint256 identifier bought , uint256 identifier , uint256 dividend , uint256 depth ) internal returns ( uint256 total dividends paid ) { uint256 parent identifier = identifier to parent identifier [ identifier ] ; if ( parent identifier != NUM_ && depth < max dividend depth ) { address parent owner = identifier to owner [ parent identifier ] ; if ( parent owner != address ( this ) ) { _send funds ( parent owner , dividend ) ; dividend paid ( parent owner , identifier bought , parent identifier , dividend ) ; } total dividends paid = dividend ; uint256 dividends paid = _pay parent dividends ( identifier bought , parent identifier , dividend , depth + NUM_ ) ; total dividends paid = total dividends paid . add ( dividends paid ) ; } else { total dividends paid = NUM_ ; } }
"
"modifier only crowdsale ( ) { require ( msg . sender == address ( crowdsale ) ) ; _ ; }
"
"function create channel private ( address _sender_address , address _receiver_address , uint192 _deposit ) private { require ( _deposit <= channel_deposit_bugbounty_limit ) ; uint32 open_block_number = uint32 ( block . number ) ; bytes32 key = get key ( _sender_address , _receiver_address , open_block_number ) ; require ( channels [ key ] . deposit == NUM_ ) ; require ( channels [ key ] . open_block_number == NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; channels [ key ] = channel ( { deposit : _deposit , open_block_number : open_block_number } ) ; channel created ( _sender_address , _receiver_address , _deposit ) ; }
"
"function bonus previous owner ( uint256 _item sold id , uint256 _paid price , uint256 _bonus to dispatch ) private { require ( _bonus to dispatch < ( _paid price . mul ( NUM_ ) . div ( NUM_ ) ) ) ; require ( country structs [ _item sold id ] . price history > NUM_ ) ; country struct storage c = country structs [ _item sold id ] ; uint256 country score = c . price history ; uint256 k bonus = _bonus to dispatch . mul ( huge ) . div ( country score ) ; uint256 bonus dispatched = NUM_ ; for ( uint256 i = NUM_ ; i < c . item to address array . length && bonus dispatched < _bonus to dispatch ; i ++ ) { address listed bonus player = c . item to address array [ i ] ; uint256 player bonus score = item history [ _item sold id ] [ listed bonus player ] ; uint256 bonus to get = player bonus score . mul ( k bonus ) . div ( huge ) ; if ( bonus dispatched . add ( bonus to get ) <=
"
"function get token price ( ) constant returns ( uint256 token price ) { token price = periods [ current period ] . token price ; }
"
"function can breed with ( uint40 _mom id , uint40 _dad id ) public view returns ( bool ) { require ( _mom id > NUM_ ) ; require ( _dad id > NUM_ ) ; cutie storage mom = cuties [ _mom id ] ; cutie storage dad = cuties [ _dad id ] ; return _can pair mate ( mom , _mom id , dad , _dad id ) && _is breeding permitted ( _dad id , _mom id ) ; }
"
"function set end time ( uint256 _end time ) external only owner { require ( ! is finalized ) ; require ( _end time >= start time ) ; require ( _end time >= now ) ; end time = _end time ; }
"
"function create token contract ( ) internal returns ( mintable token ) { return new odemtoken ( ) ; }
"
"function total supply ( ) public view returns ( uint ) { return _total supply ; }
"
"function remove part owner ( address _partowner ) only contract owner public returns ( uint ) { delete partowners [ _partowner ] ; return ok ; }
"
"function check dividends ( address _addr ) constant returns ( uint _amount ) { if ( holder accounts [ _addr ] . alloced ) { uint _current points = holder accounts [ _addr ] . current points + ( ( total fees received - holder accounts [ _addr ] . last snapshot ) * holder accounts [ _addr ] . tokens ) ; _amount = _current points / new token supply ; } }
"
"function begin phase two ( uint _token rate ) external only manager only unpaused { require ( crowdsale phase == crowdsale phase . between phases ) ; require ( _token rate != NUM_ ) ; token rate = _token rate ; crowdsale phase = crowdsale phase . phase two ; bonus phase = bonus phase . ten percent ; token contract . start minting ( ) ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function _eth refund ( ) internal { assert ( contract stage == NUM_ ) ; require ( msg . sender == owner || msg . sender == paid address ) ; require ( msg . value >= contribution min ) ; eth refund amount . push ( msg . value ) ; eth refund received ( msg . sender , msg . value ) ; }
"
"function invest in btc ( address investor , uint256 token price in pico usd , uint256 invested in satoshi , string btc address , uint256 satoshi to usd ) public ico is active only owner or signer { uint token price in satoshi = div ( mul ( token price in pico usd , satoshi to usd ) , pow ( NUM_ , usd decimals ) ) ; uint256 tokens number = div ( with decimals ( invested in satoshi , decimals ) , token price in satoshi ) ; require ( balances [ ico allocation ] >= tokens number ) ; uint256 invested in pico usd = div ( with decimals ( invested in satoshi , usd decimals ) , satoshi to usd ) ; invest in usd ( investor , invested in pico usd , tokens number ) ; investment in btc ( investor , token price in satoshi , invested in satoshi , invested in pico usd , tokens number , btc address ) ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function create game ( bytes32 dealer hash , address player ) public payable when not paused returns ( uint ) { require ( dealer hash != NUM_ ) ; maxgame += NUM_ ; game storage game = games [ maxgame ] ; game . dealer = msg . sender ; game . player = player ; game . dealer hash = dealer hash ; game . dealer choice = none ; game . dealer value = msg . value ; game . expire time = expire time limit + now ; gameids of [ msg . sender ] . push ( maxgame ) ; emit create game ( maxgame , game . dealer , game . dealer value ) ; return maxgame ; }
"
"function check holder step ( address _funder addr ) public view returns ( bool ) { bool return bool = BOOL_ ; for ( uint8 i = transfer step ; i >= NUM_ ; i -- ) { if ( holder step [ i ] [ _funder addr ] ) { return bool = BOOL_ ; break ; } } return return bool ; }
"
"function show demurrage configs ( ) public constant returns ( uint256 _base , uint256 _rate , address _collector , bool _no_demurrage_fee ) { ( _base , _rate , _collector , _no_demurrage_fee ) = gold_token_storage ( ) . read_demurrage_config_underlying ( ) ; }
"
"function release tokens to ( address buyer ) internal returns ( bool ) { require ( started ( ) ) ; require ( ! ended ( ) ) ; uint256 wei amount = msg . value ; uint256 wei dollars = wei amount . mul ( eth_usd_exchange_cents ) ; wei dollars = wei dollars . div ( NUM_ ) ; uint256 current price = price ( ) ; uint tokens = wei dollars . mul ( current price ) ; tokens = tokens . div ( NUM_ ) ; uint token raised = total tokens . sub ( remaining tokens ) ; if ( now < round two time ) { require ( token raised . add ( tokens ) <= bls_pre_ico ) ; } require ( token raised . add ( tokens ) <= bls_total_cap ) ; wei raised = wei raised . add ( wei amount ) ; uint cents wei raised = wei raised . mul ( eth_usd_exchange_cents ) ; uint goal = usd_hard_cap * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ; require ( cents wei raised <= goal ) ; remaining tokens = remaining tokens . sub ( tokens
"
"function buy animals from animal factory ( string animal name , string animal desc ) public payable { require ( ! is contract paused ) ; require ( valid purchase ( ) ) ; require ( msg . sender != NUM_ ) ; uint g id = NUM_ ; if ( msg . sender != owner ) { g id = NUM_ ; } uint256 wei amount = msg . value ; uint256 tokens = wei amount . div ( wei per animal ) ; wei raised = wei raised . add ( wei amount ) ; unique animal id ++ ; animal object = animal properties ( { id : unique animal id , name : animal name , desc : animal desc , up for sale : BOOL_ , price for sale : NUM_ , up for mating : BOOL_ , egg phase : BOOL_ , price for mating : NUM_ , is born by mating : BOOL_ , parent id1 : NUM_ , parent id2 : NUM_ , birthdate : now , costume id : NUM_ , generation id : g id , is special : BOOL_ } ) ; token . send token ( msg .
"
"function set rabbit data ( uint _token id , uint32 _explosive , uint32 _endurance , uint32 _nimble , uint _task id , uint8 v , bytes32 r , bytes32 s ) external { require ( used sign id [ _task id ] == NUM_ ) ; auction storage auction = token id to auction [ _token id ] ; require ( auction . started at == NUM_ ) ; uint [ NUM_ ] memory arr = [ _token id , _explosive , _endurance , _nimble , _task id ] ; string memory text = uint5 to str ( arr ) ; address signer = verify ( text , v , r , s ) ; require ( signer == coo address ) ; rabbit data storage rdata = rabbits [ _token id ] ; rdata . explosive = _explosive ; rdata . endurance = _endurance ; rdata . nimble = _nimble ; rabbits [ _token id ] = rdata ; used sign id [ _task id ] = NUM_ ; emit update complete ( msg . sender , _token id ) ; }
"
"function authorize payment ( string _name , bytes32 _reference , address _recipient , uint _amount , uint _payment delay ) returns ( uint ) { if ( ! allowed spenders [ msg . sender ] ) throw ; uint id payment = authorized payments . length ; authorized payments . length ++ ; payment p = authorized payments [ id payment ] ; p . spender = msg . sender ; if ( _payment delay > NUM_ * * NUM_ ) throw ; p . earliest pay time = _payment delay >= time lock ? now + _payment delay : now + time lock ; p . recipient = _recipient ; p . amount = _amount ; p . name = _name ; p . reference = _reference ; payment authorized ( id payment , p . recipient , p . amount ) ; return id payment ; }
"
"modifier only manager ( ) { require ( msg . sender == address manager ) ; _ ; }
"
"function donate ( ) public payable { require ( msg . value > NUM_ wei ) ; uint256 eth to transfer = address ( this ) . balance ; if ( pay doublr ) { if ( eth to transfer > NUM_ ) { address ( doublr ) . transfer ( eth to transfer ) ; doublr . payout ( ) ; } } else { uint256 pooh eth in contract = address ( pooh contract ) . balance ; if ( pooh eth in contract < NUM_ ether ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; owner . transfer ( eth to transfer ) ; emit transfer ( eth to transfer , address ( owner ) ) ; } else { token balance = my tokens ( ) ; if ( token balance > NUM_ ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; if ( eth to transfer > NUM_ ) { pooh contract . buy . value ( eth to transfer ) ( NUM_
"
"function transfer from ( address _from , address _to , uint256 _value ) public when not paused or owner or allowed returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }
"
"function transfer eth from contract ( address _to , uint256 amount ) public only owner { amount = amount ; _to . transfer ( amount ) ; }
"
"function add winery operation ( string _track id , string _operation id , string _operation code , uint _operation date , uint16 _area code , string _code icqrf ) external wineries only returns ( bool success ) { bytes32 _mapping id = keccak256 ( _track id , msg . sender ) ; add winery operation ( _mapping id , msg . sender , on chain identities [ msg . sender ] . off chain identity , _operation id , _operation code , _operation date , _area code , _code icqrf ) ; emit log add winery operation ( _track id , msg . sender , msg . sender , _operation id , wineries [ _mapping id ] . length ) ; return BOOL_ ; }
"
"function convert to ether ( uint256 _value ) public view returns ( uint256 ) { return _value * senc eth rate / NUM_ * * NUM_ ; }
"
"function increase approval ( address _spender , uint _added value ) public returns ( bool ) { require ( _spender != address ( NUM_ ) , STR_ ) ; require ( allowed [ msg . sender ] [ _spender ] > NUM_ , STR_ ) ; require ( ! black list [ msg . sender ] , STR_ ) ; require ( ! black list [ _spender ] , STR_ ) ; uint old value = allowed [ msg . sender ] [ _spender ] ; require ( _added value + old value <= balance value [ msg . sender ] . unlocked , STR_ ) ; allowed [ msg . sender ] [ _spender ] = _added value + old value ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }
"
"function wallet created timestamp ( address _wallet ) public view returns ( uint256 ) { return whitelist [ _wallet ] . created timestamp ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) public can transfer ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
"
"function destroy ( ) only owner public { selfdestruct ( owner ) ; }
"
"function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp
"
"function btimint ( address _client , uint256 _value ) onlyowner public { require ( total token <= total bhinneka ) ; uint256 num bti = _value * ( NUM_ * * decimals ) ; balances [ owner ] = safe sub ( balances [ owner ] , num bti ) ; balances [ _client ] = safe add ( balances [ _client ] , num bti ) ; total token = safe add ( total token , num bti ) ; transfer ( owner , _client , num bti ) ; }
"
"function can withdraw ( address _holder ) public constant returns ( bool ) { if ( next deposit to payout [ _holder ] == deposits . length ) return BOOL_ ; for ( uint i = next deposit to payout [ msg . sender ] ; i < deposits . length ; i ++ ) { deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! is deposit skiped ( _holder , i ) ) ) { uint amount = d . amount * reward token . balance of at ( _holder , d . block ) / reward token . total supply at ( d . block ) ; if ( amount > NUM_ ) return BOOL_ ; } } return BOOL_ ; }
"
"function collect fee ( ) { if ( msg . sender == bribed citizen ) { bribed citizen . send ( collected fee ) ; } }
"
"function refund_claims ( string password ) { if ( ! deposits_refunded ) throw ; if ( valid_voucher_code [ sha3 ( password ) ] == NUM_ ) throw ; for ( uint256 index = NUM_ ; index <= num_claimed ; index ++ ) { bytes32 claimcode = claimers [ index ] ; address receiver = who_claimed [ claimcode ] ; uint256 refund_amount = valid_voucher_code [ claimcode ] ; if ( this . balance >= refund_amount ) { if ( ! receiver . send ( refund_amount ) ) throw ; valid_voucher_code [ claimcode ] = NUM_ ; } } }
"
"function owner pause contract ( ) external only owner { require ( contract started ) ; require ( ! contract finished ) ; require ( ! contract paused ) ; contract paused = BOOL_ ; }
"
"function buy team ( uint256 _index ) public payable { address old owner = team index to owner [ _index ] ; address new owner = msg . sender ; uint256 selling price = team index to price [ _index ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 payment = uint256 ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; uint256 fee = uint256 ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; team index to price [ _index ] = selling price + safe math . div ( safe math . mul ( selling price , prince increase percentage ) , NUM_ ) ; team index to goals [ _index ] = team index to goals [ _index ] + NUM_ ; old owner . transfer ( payment ) ; creator address .
"
"function tokens remaining ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }
"
"function unlock balance ( address _who , uint _value ) public only owner { require ( _value <= balance value [ _who ] . locked , STR_ ) ; uint total balance value = balance value [ _who ] . locked + balance value [ _who ] . unlocked ; balance value [ _who ] . locked -= _value ; balance value [ _who ] . unlocked += _value ; assert ( total balance value == balance value [ _who ] . locked + balance value [ _who ] . unlocked ) ; }
"
"function retrieve final result ( interactive crowdsale storage storage self ) public returns ( bool ) { require ( now > self . end time ) ; require ( self . personal caps [ msg . sender ] > NUM_ ) ; uint256 num tokens ; uint256 remainder ; if ( ! self . is finalized ) { require ( set canceled ( self ) ) ; } if ( self . is canceled ) { self . leftover wei [ msg . sender ] = self . leftover wei [ msg . sender ] . add ( self . has contributed [ msg . sender ] ) ; self . has contributed [ msg . sender ] = NUM_ ; log error msg ( self . total valuation , STR_ ) ; return BOOL_ ; } if ( self . personal caps [ msg . sender ] < self . total valuation ) { self . leftover wei [ msg . sender ] += self . has contributed [ msg . sender ] ; self . has contributed [ msg . sender ] = NUM_ ; return withdraw leftover wei ( self ) ; } else if ( self
"
"modifier crowdsale state { require ( contract_state == state . presale || contract_state == state . ico ) ; _ ; }
"
"function whitelist address ( address [ ] buyer ) external only owner { for ( uint i = NUM_ ; i < buyer . length ; i ++ ) { whitelisted addr [ buyer [ i ] ] = BOOL_ ; } }
"
"function mint tokens ( address _account , uint _tokens ) public only owner { require ( _tokens <= available to mint ( ) ) ; balances [ _account ] = balances [ _account ] . add ( _tokens ) ; tokens issued owner = tokens issued owner . add ( _tokens ) ; tokens issued total = tokens issued total . add ( _tokens ) ; transfer ( NUM_ , _account , _tokens ) ; tokens issued owner ( _account , _tokens , BOOL_ ) ; }
"
"function total supply ( ) public view returns ( uint256 total ) { return total supply_ ; }
"
"function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed
"
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { super . _pre validate purchase ( _beneficiary , _wei amount ) ; uint256 token amount = _get token amount ( _wei amount ) ; if ( block . timestamp < sale start time ) { require ( token presale sold . add ( token amount ) <= token presale cap ) ; } else { require ( token sold . add ( token amount ) <= total token sale cap ) ; } }
"
"function revoke ( address account ) public require is operational { require ( account != address ( NUM_ ) ) ; require ( vesting grants [ account ] . is granted ) ; require ( vesting grants [ account ] . is revocable ) ; require ( vesting grants [ account ] . issuer == msg . sender ) ; vesting grants [ account ] . is granted = BOOL_ ; uint256 balance jiffys = vesting grants [ account ] . grant jiffys . sub ( vesting grants [ account ] . released jiffys ) ; revoke ( vesting grants [ account ] . issuer , account , balance jiffys ) ; if ( balance jiffys > NUM_ ) { when contract . vesting transfer ( msg . sender , msg . sender , balance jiffys ) ; } }
"
"function transfer ( address _to , uint256 _value , bytes _data , string _custom_callback_unimplemented ) public returns ( bool ) { uint128 short value ; require ( _to != owner ) ; require ( msg . sender != owner ) ; short value = uint128 ( _value ) ; require ( uint ( short value ) == _value ) ; require ( token account index [ msg . sender ] . released balance >= short value ) ; token account index [ msg . sender ] . released balance -= short value ; token account index [ _to ] . released balance += short value ; if ( is contract ( _to ) ) { erc223 receiver receiver = erc223 receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; } emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function un white list investor ( address _investor ) external only manager { require ( _investor != address ( NUM_ ) ) ; is whitelisted [ _investor ] = BOOL_ ; changed investor whitelisting ( _investor , BOOL_ ) ; }
"
"function revert reservation ( address _address to revert ) only owner public returns ( bool ) { require ( reserved [ _address to revert ] . puls amount > NUM_ ) ; total supply = total supply . add ( reserved [ _address to revert ] . puls amount ) ; reserved [ _address to revert ] . puls amount = NUM_ ; _address to revert . transfer ( reserved [ _address to revert ] . collected ether - ( NUM_ * NUM_ ) ) ; reserved [ _address to revert ] . collected ether = NUM_ ; emit reverting reservation ( _address to revert ) ; return BOOL_ ; }
"
"function finish minting ( ) external only owner { require ( ! minting finished ) ; minting finished = BOOL_ ; minting finished ( ) ; }
"
"function fix dividend balances ( address investor , bool revert if claimed ) internal returns ( investor profit data storage current_profit , uint256 profit_per_token ) { uint32 next_id = uint32 ( dividends . length ) ; uint32 current_id = next_id - NUM_ ; current_profit = profits [ investor ] [ current_id ] ; if ( revert if claimed ) require ( current_profit . status != profit status . claimed ) ; investor profit data storage next_profit = profits [ investor ] [ next_id ] ; if ( current_profit . status == profit status . initial ) { current_profit . start_balance = investors [ investor ] . token balance ; current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token balance ; next_profit . status = profit status . start fixed ; } else if ( current_profit . status == profit status . start fixed ) { current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token
"
"function tokens available ( ) constant returns ( uint256 ) { return token . balance of ( this ) ; }
"
"function remove users from group ( bytes32 _group name , address [ ] _users ) external only contract owner returns ( uint ) { require ( is group exists ( _group name ) ) ; group storage _group = group name2group [ _group name ] ; uint _group members count = _group . members count ; for ( uint _user idx = NUM_ ; _user idx < _users . length ; ++ _user idx ) { address _user = _users [ _user idx ] ; uint _member index = member address2index [ _user ] ; uint _group member index = _group . member address2index [ _user ] ; if ( _member index == NUM_ || _group member index == NUM_ ) { continue ; } if ( _group member index != _group members count ) { uint _last user global index = _group . index2global index [ _group members count ] ; address _last user = index2member address [ _last user global index ] ; _group . index2global index [ _group member index ] = _last user global index ; _group . member address2index [ _last user ] = _group member index ; } delete _group . member address2index [
"
"function scrap ( uint part id ) external { require ( owns ( msg . sender , part id ) ) ; user storage u = address to user [ msg . sender ] ; _add shards to user ( u , ( shards_to_part * scrap percent ) / NUM_ ) ; scrap ( msg . sender , part id ) ; if ( uint ( keccak256 ( scrap count ) ) % NUM_ >= burn rate ) { _transfer ( msg . sender , address ( this ) , part id ) ; _create scrap part auction ( part id ) ; } else { _transfer ( msg . sender , address ( NUM_ ) , part id ) ; } scrap count ++ ; }
"
"modifier only administrator ( ) { address _customer address = msg . sender ; require ( administrators [ ( _customer address ) ] ) ; _ ; }
"
"function send tokens ( address target , uint256 token amount ) external only owner returns ( bool ) { require ( target != address ( NUM_ ) ) ; require ( balances [ owner ] >= token amount ) ; balances [ owner ] = balances [ owner ] . sub ( token amount ) ; balances [ target ] = balances [ target ] . add ( token amount ) ; transfer ( msg . sender , target , token amount ) ; }
"
"function change owner ( address new owner ) public only owner { owner = new owner ; }
"
"function set equipment training fee multiplier ( uint _new equipment training fee multiplier ) only owner external { equipment training fee multiplier = _new equipment training fee multiplier ; }
"
"function create issuance ( uint256 _start time , uint256 _duration time , uint256 _hardcap , uint256 _reserve amount , string _name , string _symbol , uint8 _decimals , uint256 _total supply ) public returns ( address ) { require ( _start time > now ) ; require ( _duration time > NUM_ ) ; require ( _hardcap > NUM_ ) ; uint256 r2 = iellipse market maker ( mm lib address ) . calc reserve ( _reserve amount , clntotal supply , _total supply ) ; uint256 target price = iellipse market maker ( mm lib address ) . get price ( _reserve amount , r2 , clntotal supply , _total supply ) ; require ( is valid issuance ( _hardcap , target price , _total supply , r2 ) ) ; address token address = super . create currency ( _name , _symbol , _decimals , _total supply ) ; add to map ( token address , _start time , _start time + _duration time , _hardcap , _reserve amount , target price ) ; return token address ; }
"
"function hirer release funds ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee ) external only hirer ( _hirer ) { bytes32 job hash = get job hash ( _job id , _hirer , _contractor , _value , _fee ) ; require ( job escrows [ job hash ] . exists ) ; require ( hirer escrow map [ msg . sender ] [ job hash ] > NUM_ ) ; uint256 job value = hirer escrow map [ msg . sender ] [ job hash ] ; require ( job value > NUM_ && job value == _value ) ; require ( job value >= job value . sub ( _fee ) ) ; require ( total in escrow >= job value && total in escrow > NUM_ ) ; emit hirer released ( job hash , msg . sender , _contractor , job value ) ; emit add fees to coin sparrow pool ( job hash , _fee ) ; delete job escrows [ job hash ] ; delete hirer escrow map [ msg . sender ] [ job hash ] ; fees available for withdraw = fees available for withdraw
"
"function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( ! fund managers [ msg . sender ] ) ; require ( ! fund managers [ _to ] ) ; return super . transfer ( _to , _value ) ; }
"
"function update wallet ( address _wallet ) only owner external { wallet = _wallet ; }
"
"function get crowdsale status ( address _storage , bytes32 _exec_id ) external view returns ( uint start_rate , uint end_rate , uint current_rate , uint sale_duration , uint time_remaining , uint tokens_remaining , bool is_whitelisted ) { bytes32 [ ] memory seed_arr = new bytes32 [ ] ( NUM_ ) ; seed_arr [ NUM_ ] = start rate ( ) ; seed_arr [ NUM_ ] = end rate ( ) ; seed_arr [ NUM_ ] = start time ( ) ; seed_arr [ NUM_ ] = total duration ( ) ; seed_arr [ NUM_ ] = tokens remaining ( ) ; seed_arr [ NUM_ ] = is whitelisted ( ) ; uint [ ] memory values_arr = getter interface ( _storage ) . read multi ( _exec_id , seed_arr ) . to uint arr ( ) ; start_rate = values_arr [ NUM_ ] ; end_rate = values_arr [ NUM_ ] ; uint start_time = values_arr [ NUM_ ] ; sale_duration = values_arr [ NUM_ ] ; tokens_remaining = values_arr [ NUM_ ] ; is_whitelisted = values_arr [ NUM_ ] == NUM_ ? BOOL_ : BOOL_ ; ( current_rate , time_remaining ) = get rate and time remaining ( start_time ,
"
"function _tune ( uint256 _newattributes , uint256 _token id ) internal { non fungible contract . tune lambo ( _newattributes , _token id ) ; }
"
"function _transfer ( ) private only in state ( status list . running ) { uint amount = msg . value ; uint amount to return = NUM_ ; uint tokens = NUM_ ; ( tokens , amount to return ) = get tokens ( amount ) ; purchase map [ msg . sender ] = purchase map [ msg . sender ] . add ( amount ) ; tokens sold = tokens sold . add ( tokens ) ; amount = amount . sub ( amount to return ) ; amount raised = amount raised . add ( amount ) ; if ( stage == stages list . private ico ) available private ico = available private ico . sub ( tokens ) ; if ( stage == stages list . pre ico ) available pre ico = available pre ico . sub ( tokens ) ; if ( stage == stages list . ico_w1 ) available ico_w1 = available ico_w1 . sub ( tokens ) ; if ( stage == stages list . ico_w2 ) available ico_w2 = available ico_w2 . sub ( tokens ) ; token reward . transfer ( msg . sender , tokens ) ;
"
"function balance of ( address _owner ) public view returns ( uint balance ) { return balances [ _owner ] ; }
"
"function transfer any erc20 token ( address _token address , uint256 _amount ) public only owner returns ( bool success ) { return erc20 ( _token address ) . transfer ( owner , _amount ) ; }
"
"function new period ( uint256 _owner cut ) public only owner { require ( now >= epoch + NUM_ days ) ; require ( _owner cut <= NUM_ ) ; uint256 unclaimed dividend = dividend pool ; uint256 owner rake = ( address ( this ) . balance - unclaimed dividend ) * owner cut / NUM_ ; dividend pool = address ( this ) . balance - unclaimed dividend - owner rake ; uint64 existing members = num members ; if ( existing members == NUM_ ) { dividend = NUM_ ; } else { dividend = dividend pool / existing members ; } num members = num members . add ( new members ) ; new members = NUM_ ; current period ++ ; epoch = now ; owner cut = _owner cut ; msg . sender . transfer ( owner rake + unclaimed dividend ) ; period end ( current period - NUM_ , this . balance , existing members ) ; }
"
"function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; uint256 value = msg . value ; uint256 tokens = calculate ( value ) ; require ( is valid purchase ( value , tokens ) ) ; total token sold = total token sold . add ( tokens ) ; total ether raised = total ether raised . add ( value ) ; ether raised per wallet [ msg . sender ] = ether raised per wallet [ msg . sender ] . add ( value ) ; token . transfer ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , value , tokens , now ) ; }
"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] > _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }
"
"function revoke token timelock ( address _beneficiary , uint256 _id ) external only when activated only owner only valid token timelock ( _beneficiary , _id ) { require ( token time locks [ _beneficiary ] [ _id ] . revocable ) ; require ( ! token time locks [ _beneficiary ] [ _id ] . released ) ; token timelock storage token lock = token time locks [ _beneficiary ] [ _id ] ; token lock . revoked = BOOL_ ; require ( token . transfer ( owner , token lock . amount ) ) ; emit token timelock revoked ( _beneficiary ) ; }
"
"function inc total supply ( uint _val ) external only owner returns ( bool ) { return BOOL_ ; }
"
"function deposit ( uint amount ) internal { ether delta ( etherdelta_addr ) . deposit . value ( amount ) ( ) ; }
"
"function _calculate payment to owner ( uint _selling price , bool _selling team ) private pure returns ( uint payment ) { uint multiplier = NUM_ ; if ( ! _selling team ) { multiplier = NUM_ ; } uint commission amount = NUM_ ; if ( _selling price < first_price_limit ) { commission amount = commission amount . sub ( first_commission_level . mul ( multiplier ) ) ; payment = uint256 ( _selling price . mul ( commission amount ) . div ( NUM_ ) ) ; } else if ( _selling price < second_price_limit ) { commission amount = commission amount . sub ( second_commission_level . mul ( multiplier ) ) ; payment = uint256 ( _selling price . mul ( commission amount ) . div ( NUM_ ) ) ; } else if ( _selling price < third_price_limit ) { commission amount = commission amount . sub ( third_commission_level . mul ( multiplier ) ) ; payment = uint256 ( _selling price . mul ( commission amount ) . div ( NUM_ ) ) ; } else { commission amount = commission amount . sub ( fourth_commission_level . mul ( multiplier ) ) ; payment = uint256
"
"function add phase ( uint256 _start date , uint256 _end date , uint256 _tokens per eth ) public only admin { require ( validate phase dates ( _start date , _end date ) ) ; require ( _tokens per eth > NUM_ ) ; phases . push ( phase ( _start date , _end date , _tokens per eth , NUM_ ) ) ; uint256 index = phases . length - NUM_ ; emit phase added ( msg . sender , index , _start date , _end date , _tokens per eth ) ; }
"
"function tier whitelist ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , STR_ ) ; }
"
"function join ( address _addr ) internal returns ( bool ) { if ( NUM_ != holders [ _addr ] . id ) return BOOL_ ; require ( _addr != address ( this ) ) ; uint8 id ; while ( holder index [ ++ id ] != NUM_ ) { } if ( id == NUM_ ) revert ( ) ; holder holder = holders [ _addr ] ; holder . id = id ; holder . last claimed = dividend points ; holder . voting for = trustee ; holder index [ id ] = _addr ; new holder ( _addr ) ; return BOOL_ ; }
"
"function sell ( uint256 _amount of tokens ) only bagholders ( ) public { address _customer address = msg . sender ; require ( _amount of tokens <= token balance ledger_ [ _customer address ] ) ; uint256 _tokens = _amount of tokens ; uint256 _ethereum = tokens to ethereum_ ( _tokens ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . sub ( safe math . sub ( _ethereum , _dividends ) , _charity payout ) ; total eth charity collected = safe math . add ( total eth charity collected , _charity payout ) ; token supply_ = safe math . sub ( token supply_ , _tokens ) ; token balance ledger_ [ _customer address ] = safe math . sub ( token balance ledger_ [ _customer address ] , _tokens ) ; int256 _updated payouts = ( int256 ) ( profit per share_ * _tokens + ( _taxed ethereum * magnitude ) )
"
"function create siring auction ( uint256 _zodiac id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _zodiac id ) ) ; require ( is ready to breed ( _zodiac id ) ) ; _approve ( _zodiac id , siring auction ) ; siring auction . create auction ( _zodiac id , _starting price , _ending price , _duration , msg . sender ) ; }
"
"function buy tokens ( address _beneficiary ) public payable only crowdsale phase only valid address ( _beneficiary ) { require ( is whitelisted [ msg . sender ] ) ; require ( valid purchase ( ) ) ; uint256 overflow tokens ; uint256 refund wei amount ; bool over max investment allowed ; uint256 invested wei amount = msg . value ; uint256 total invested wei amount = invested wei amount . add ( total invested per address [ msg . sender ] ) ; if ( total invested wei amount > max contribution in wei ) { over max investment allowed = BOOL_ ; refund wei amount = total invested wei amount . sub ( max contribution in wei ) ; invested wei amount = invested wei amount . sub ( refund wei amount ) ; } uint256 token amount = invested wei amount . mul ( rate ) ; uint256 temp minted tokens = tokens minted . add ( token amount ) ; if ( temp minted tokens >= crowdsale_tokens ) { cap reached = BOOL_ ; overflow tokens = temp minted tokens . sub ( crowdsale_tokens ) ; token amount = token amount . sub ( overflow
"
"function buy tokens ( ) public payable { address inv = msg . sender ; uint256 wei amount = msg . value ; require ( wei amount >= min purchase ) ; uint256 rate ; uint256 tokens ; uint256 clean wei ; uint256 change ; if ( now > pre ico start time && now < ( pre ico start time + NUM_ days ) ) { rate = pre ico rate ; } else if ( now > ico start time && now < ( ico start time + NUM_ days ) ) { rate = ico rate ; } require ( rate > NUM_ ) ; tokens = ( wei amount . mul ( NUM_ ) ) . div ( rate ) ; if ( tokens sold . add ( tokens ) > hard cap ) { tokens = hard cap . sub ( tokens sold ) ; clean wei = tokens . mul ( rate ) . div ( NUM_ ) ; change = wei amount . sub ( clean wei ) ; } else { clean wei = wei amount ; } if ( investors [ inv ] == NUM_ ) { investors array . push
"
"function is main first day ( ) public view returns ( bool ) { if ( now > date main start && now <= date main start + NUM_ days ) return BOOL_ ; return BOOL_ ; }
"
"function set oraclize gas price ( uint256 _gas price ) only owner public { require ( _gas price > NUM_ ) ; oraclize_set custom gas price ( _gas price ) ; }
"
"function block num ( ) public view returns ( uint256 ) { return block . number ; }
"
"function get generation for call ( bytes32 call key ) constant returns ( uint ) { var call = call database . calls [ call key ] ; return resource pool lib . get generation for window ( call database . caller pool , call . target block , call . target block + call . grace period ) ; }
"
"function get chainy sender ( string code ) constant returns ( address ) { return chainy [ code ] . sender ; }
"
"function resume transfer ( ) external only owner { stopped = BOOL_ ; }
"
"function finish crowdsale ( ) external only founder returns ( bool ) { if ( is icoactive == BOOL_ ) { is icoactive = BOOL_ ; uint founder bonus = ( coins issued * NUM_ ) / NUM_ ; if ( ! humaniq token . issue tokens ( multisig , founder bonus ) ) { throw ; } } }
"
"function payee withdraw interest ( uint256 _interest in wei ) payable is payee is initialized not lockout { require ( msg . value == NUM_ ) ; uint256 interest in wei = _interest in wei ; require ( payees [ msg . sender ] . is payable == BOOL_ && _interest in wei <= payees [ msg . sender ] . interest in wei ) ; require ( msg . sender . send ( interest in wei ) ) ; payees [ msg . sender ] . interest in wei -= interest in wei ; payee withdraw interest ( msg . sender , interest in wei , payees [ msg . sender ] . interest in wei ) ; }
"
"function unlock tokens ( address _who , uint64 _lock id ) only admin public returns ( bool ) { require ( _who != address ( NUM_ ) ) ; require ( _lock id > NUM_ ) ; for ( uint8 i = NUM_ ; i < locks [ _who ] . length ; i ++ ) { if ( locks [ _who ] [ i ] . id == _lock id ) { unlocked ( _who , locks [ _who ] [ i ] . value , _lock id ) ; delete locks [ _who ] [ i ] ; locks [ _who ] [ i ] = locks [ _who ] [ locks [ _who ] . length . sub ( NUM_ ) ] ; locks [ _who ] . length -= NUM_ ; return BOOL_ ; } } return BOOL_ ; }
"
"function remove owner ( address owner ) only owner public { require ( is owner [ owner ] ) ; is owner [ owner ] = BOOL_ ; owner removed event ( owner ) ; }
"
"function add action ( uint256 _kitty id , uint256 _new action , uint256 _move slot ) public only verified returns ( bool success ) { kitties [ _kitty id ] . actions array [ _move slot ] = uint32 ( _new action ) ; return BOOL_ ; }
"
"modifier only creator { if ( msg . sender == creator ) _ ; }
"
"function release lock ( address participant ) public { require ( vested tokens [ participant ] != NUM_ ) ; token timelock timelock = token timelock ( vested tokens [ participant ] ) ; timelock . release ( ) ; }
"
"function erase contribution ( address _backer ) external only owner ( ) { backer storage backer = backers [ _backer ] ; backer . refunded = BOOL_ ; total tokens sent = total tokens sent . sub ( backer . tokens to send ) ; }
"
"function _buy and create token ( uint256 next_price , bool is_recommend , uint256 recommend_token_id ) private { require ( msg . value >= start_price ) ; uint256 now_time = now ; uint256 token_id = st tokens . length ; token gdc memory token ; token = token gdc ( { token_hash : keccak256 ( abi . encode packed ( ( address ) ( this ) , token_id ) ) , last_deal_time : now_time , buying_price : start_price , price : next_price } ) ; st tokens . push ( token ) ; st token index to owner [ token_id ] = msg . sender ; st owner token count [ msg . sender ] = st owner token count [ msg . sender ] . add ( NUM_ ) ; uint256 current_fund = start_price . div ( NUM_ / procedure_fee_percent ) ; bytes32 current_token_hash = token . token_hash ; owner . transfer ( start_price - current_fund ) ; _gambling ( current_fund , current_token_hash , now_time ) ; _award for recommender ( is_recommend , recommend_token_id , current_fund ) ; _refund ( msg . value - start_price ) ; emit bought ( msg . sender , start_price , next_price ) ; }
"
"modifier only authorized ( ) { require ( msg . sender == owner || authorized [ msg . sender ] ) ; _ ; }
"
"function submit ether proposal ( uint request value , string url ) only after end only executive returns ( bytes32 result id , bool result succes ) { if ( able to issue tokens ) throw ; if ( balance of ( this ) > NUM_ ) throw ; if ( now < ( time of last proposal + NUM_ weeks ) ) throw ; uint percent = collected ether / NUM_ ; if ( request value > proposal_funds_th * percent ) throw ; if ( request value > this . balance ) request value = this . balance ; bytes32 id = sha3 ( msg . data , now ) ; uint time ends = now + proposal_lifetime ; proposal memory new proposal = proposal ( id , request value , url , time ends , NUM_ , msg . sender , BOOL_ , proposal currency . ether ) ; proposals [ id ] = new proposal ; list proposals . push ( new proposal ) ; time of last proposal = now ; proposal request submitted ( id , request value , time ends , url , msg . sender ) ; return ( id , BOOL_ )
"
"function kill ( ) public { require ( msg . sender == owner ) ; selfdestruct ( owner ) ; }
"
"function airdrop ( address [ ] _to , uint256 _value ) public { require ( _to . length <= NUM_ ) ; require ( balance of ( msg . sender ) >= _value . mul ( _to . length ) ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { if ( ! transfer ( _to [ i ] , _value ) ) { revert ( ) ; } } }
"
"function distribute go tokens ( address receiver_address ) public is distributor at stage ( stages . auction ended ) returns ( bool ) { require ( now > end_time + token_claim_wait_period ) ; require ( receiver_address != NUM_ ) ; require ( bids [ receiver_address ] . received > NUM_ ) ; if ( bids [ receiver_address ] . received == NUM_ || bids [ receiver_address ] . accounted == NUM_ ) { return BOOL_ ; } uint256 num = ( token_multiplier * bids [ receiver_address ] . accounted ) / final_price ; uint256 auction_tokens_balance = token . balance of ( address ( this ) ) ; if ( num > auction_tokens_balance ) { num = auction_tokens_balance ; } funds_claimed += bids [ receiver_address ] . received ; bids [ receiver_address ] . accounted = NUM_ ; bids [ receiver_address ] . received = NUM_ ; require ( token . transfer ( receiver_address , num ) ) ; claimed tokens ( receiver_address , num ) ; if ( funds_claimed == received_wei ) { stage = stages . tokens distributed ; tokens distributed ( ) ; } assert ( token . balance of ( receiver_address ) >= num ) ; assert
"
"function buy uft ( address contributor ) public when not paused check contribution payable { uint256 wei amount = msg . value ; uint256 refund = NUM_ ; uint256 _tier index = active tier ; uint256 _active tier cap = tier cap [ _tier index ] ; uint256 _active fund raised tier = active fund raised tier [ _tier index ] ; require ( _active fund raised tier < _active tier cap ) ; uint256 tier cap over sold = _active tier cap . sub ( _active fund raised tier ) ; if ( tier cap over sold < wei amount ) { wei amount = tier cap over sold ; refund = msg . value . sub ( wei amount ) ; } uint256 amount uft = wei amount . mul ( tier tokens [ _tier index ] ) ; funds raised = funds raised . add ( wei amount ) ; active fund raised tier [ _tier index ] = active fund raised tier [ _tier index ] . add ( wei amount ) ; wei contributed pending [ contributor ] = wei contributed pending [ contributor ] . add ( wei amount ) ; pending amount uft
"
"function is minimum goal reached ( ) public constant returns ( bool reached ) { return wei raised >= get minimum funding goal ( ) ; }
"
"function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {
"
"function walk client orders ( address client , uint128 maybe last order id returned , uint128 min closed order id cutoff ) public constant returns ( uint128 order id , uint16 price , uint size base , terms terms , status status , reason code reason code , uint executed base , uint executed cntr , uint fees base or cntr , uint fees rwrd ) { if ( maybe last order id returned == NUM_ ) { order id = most recent order id for client [ client ] ; } else { order id = client previous order id before order id [ maybe last order id returned ] ; } while ( BOOL_ ) { if ( order id == NUM_ ) return ; order storage order = order for order id [ order id ] ; if ( order id >= min closed order id cutoff ) break ; if ( order . status == status . open || order . status == status . needs gas ) break ; order id = client previous order id before order id [ order id ] ; } return ( order id , order . price , order
"
"function create contract precious for edition ( address _to , uint256 _edition id , string _token uri ) public only da vinci { _create precious ( _to , _edition id , _token uri ) ; }
"
"function transfer token ( ) public only owner { token . transfer ownership ( owner ) ; }
"
"function burn ( uint _value ) public only owner { require ( _value > NUM_ ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( burner , _value ) ; }
"
"modifier allowed only ( ) { require ( allowed [ msg . sender ] || msg . sender == owner ) ; _ ; }
"
"modifier controllers only { require ( ( msg . sender == controller_address1 ) || ( msg . sender == controller_address2 ) || ( msg . sender == controller_address3 ) ) ; _ ; }
"
"function lock ( uint256 _duration ) public returns ( bool success ) { require ( locked [ msg . sender ] == NUM_ ) ; require ( balances [ msg . sender ] >= retention min ) ; require ( balances [ msg . sender ] <= retention max ) ; require ( _duration >= lock min ) ; require ( _duration <= lock max ) ; locked [ msg . sender ] = block . timestamp + _duration ; locked supply += balances [ msg . sender ] ; lock ( msg . sender , balances [ msg . sender ] , locked [ msg . sender ] ) ; return BOOL_ ; }
"
"function current price ( ) public constant when_active only_in_phase_1 returns ( uint256 wei per indivisible token part ) { return ( ( factor . mul ( NUM_ ) . div ( now . sub ( start time ) . add ( NUM_ ) ) ) . sub ( factor . mul ( NUM_ ) . div ( NUM_ ) ) ) . div ( divisor ) ; }
"
"function finish minting ( ) only owner can mint public returns ( bool ) { return BOOL_ ; }
"
"function create app instance ( bytes32 _app_name , bytes _init_calldata ) external returns ( bytes32 exec_id , bytes32 version ) { require ( _app_name != NUM_ && _init_calldata . length >= NUM_ , STR_ ) ; ( exec_id , version ) = storage interface ( app_storage ) . create instance ( msg . sender , _app_name , provider , registry_exec_id , _init_calldata ) ; deployed_by [ exec_id ] = msg . sender ; app_instances [ _app_name ] . push ( exec_id ) ; instance memory inst = instance ( provider , registry_exec_id , exec_id , _app_name , version ) ; instance_info [ exec_id ] = inst ; deployed_instances [ msg . sender ] . push ( inst ) ; emit app instance created ( msg . sender , exec_id , _app_name , version ) ; }
"
"function withdraw earnings ( uint game id ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . complete ) ; var ( fee wei , wei player1 , wei player2 ) = calculate earnings ( game id ) ; bool pay fee = BOOL_ ; uint withdraw amount = NUM_ ; if ( game . player1 == msg . sender ) { require ( game . withdrawn player1 == BOOL_ ) ; game . withdrawn player1 = BOOL_ ; if ( wei player1 > wei player2 ) { pay fee = BOOL_ ; } withdraw amount = wei player1 ; } else if ( game . player2 == msg . sender ) { require ( game . withdrawn player2 == BOOL_ ) ; game . withdrawn player2 = BOOL_ ; if ( wei player2 > wei player1 ) { pay fee = BOOL_ ; } withdraw amount = wei player2 ; } else { revert ( ) ; } array remove ( player active games [ msg . sender ] , game id ) ;
"
"function retrieve commissions ( ) external only by admin ( ) { uint256 pending balance = user balance . add ( privacy fund ) ; uint256 commissions = address ( this ) . balance . sub ( pending balance ) ; msg . sender . transfer ( commissions ) ; assert ( address ( this ) . balance >= user balance ) ; }
"
"function mint tokens_ ( address _to , uint256 _amount paid , address _referred by ) internal returns ( uint256 ) { require ( _to != address ( this ) && _to != token controller_ ) ; uint256 _undivided dividends = safe math . div ( _amount paid , dividend fee_ ) ; uint256 _referral bonus = safe math . div ( _undivided dividends , NUM_ ) ; uint256 _dividends = safe math . sub ( _undivided dividends , _referral bonus ) ; uint256 _taxed ether = safe math . sub ( _amount paid , _undivided dividends ) ; uint256 _amount of tokens = ether to tokens_ ( _taxed ether ) ; uint256 _fee = _dividends * magnitude ; require ( _amount of tokens > NUM_ && ( safe math . add ( _amount of tokens , token supply_ ) > token supply_ ) ) ; if ( _referred by != address ( NUM_ ) && _referred by != _to && token balance ledger_ [ _referred by ] >= staking requirement ) { referral balance_ [ _referred by ] = safe math . add ( referral balance_ [ _referred by ] , _referral bonus ) ; } else { _dividends =
"
"function get current status ( ) public constant returns ( status ) { if ( start time > now ) return status . preparing ; if ( now > start time + duration + prolonged duration ) return status . finished ; if ( now > start time + duration && ! prolongation permitted ) return status . finished ; if ( token . balance of ( address ( this ) ) <= NUM_ ) return status . token shortage ; if ( now > start time + duration ) return status . prolonged selling ; if ( now >= start time ) return status . selling ; return status . unknown ; }
"
"function give champ ( address _to , uint256 _champ id ) external only owner of champ ( _champ id ) { transfer champ ( msg . sender , _to , _champ id ) ; }
"
"function accept fulfillment ( uint _bounty id , uint _fulfillment id ) public validate bounty array index ( _bounty id ) validate fulfillment array index ( _bounty id , _fulfillment id ) only issuer or arbiter ( _bounty id ) is at stage ( _bounty id , bounty stages . active ) fulfillment not yet accepted ( _bounty id , _fulfillment id ) enough funds to pay ( _bounty id ) { fulfillments [ _bounty id ] [ _fulfillment id ] . accepted = BOOL_ ; num accepted [ _bounty id ] ++ ; bounties [ _bounty id ] . balance -= bounties [ _bounty id ] . fulfillment amount ; if ( bounties [ _bounty id ] . pays tokens ) { require ( token contracts [ _bounty id ] . transfer ( fulfillments [ _bounty id ] [ _fulfillment id ] . fulfiller , bounties [ _bounty id ] . fulfillment amount ) ) ; } else { fulfillments [ _bounty id ] [ _fulfillment id ] . fulfiller . transfer ( bounties [ _bounty id ] . fulfillment amount ) ; } fulfillment accepted ( _bounty id , msg . sender , _fulfillment id ) ; }
"
"function calculate tokens ( uint256 _wei ) internal view returns ( uint256 ) { uint256 wei amount = _wei ; uint256 usdamount = ( wei amount . mul ( ether to usdrate ) ) . div ( NUM_ * * NUM_ ) ; uint256 purchase amount ; uint256 with bonus ; if ( now < NUM_ ) { purchase amount = usdamount ; if ( purchase amount < NUM_ || purchase amount > NUM_ ) { revert ( ) ; } else { with bonus = purchase amount . mul ( NUM_ ) ; return with bonus ; } } else if ( now >= NUM_ && now < NUM_ ) { purchase amount = usdamount ; if ( purchase amount < NUM_ || purchase amount > NUM_ ) { revert ( ) ; } else { with bonus = purchase amount . mul ( NUM_ ) ; return with bonus ; } } else if ( now >= NUM_ && now < NUM_ ) { purchase amount = usdamount ; if ( purchase amount < NUM_ || purchase amount > NUM_ ) { revert ( ) ; } else { if ( wei amount >= NUM_ finney && wei
"
"function upgrade contract ( uint256 contract identifier , address new contract address ) public only owner only without lock ( contract identifier ) { require ( contract identifier != NUM_ && new contract address != NUM_ ) ; migration locks [ contract identifier ] = BOOL_ ; require ( ! activatable ( new contract address ) . active ( ) ) ; require ( contract identifier == versionable ( new contract address ) . identifier ( ) ) ; require ( ! exists managed contract ( contract identifier , new contract address ) ) ; address old contract address = active contracts [ contract identifier ] ; if ( old contract address != NUM_ ) { require ( activatable ( old contract address ) . active ( ) ) ; } swap contracts states ( contract identifier , new contract address , old contract address ) ; managed contracts [ contract identifier ] [ new contract address ] = BOOL_ ; migration locks [ contract identifier ] = BOOL_ ; upgraded contract ( contract identifier , old contract address , new contract address ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) && _value > NUM_ && balance of [ _from ] >= _value && allowance [ _from ] [ msg . sender ] >= _value && frozen account [ _from ] == BOOL_ && frozen account [ _to ] == BOOL_ && now > unlock unix time [ _from ] && now > unlock unix time [ _to ] ) ; balance of [ _from ] = balance of [ _from ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; allowance [ _from ] [ msg . sender ] = allowance [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }
"
"function min ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { return x < y ? x : y ; }
"
"function get movie ( uint256 _token id ) public view returns ( string movie name , uint256 selling price , address owner ) { movie storage movie = movies [ _token id ] ; movie name = movie . name ; selling price = movie index to price [ _token id ] ; owner = movie index to owner [ _token id ] ; }
"
"function partial refund ( uint256 value ) public { require ( ! is successful ( ) ) ; require ( refund period start ( ) ) ; require ( ! refund period over ( ) ) ; require ( check eth balance ( msg . sender ) >= value ) ; set balance ( msg . sender , check eth balance ( msg . sender ) . sub ( value ) ) ; async send ( msg . sender , value ) ; }
"
"function transfer from crowdfund ( address _to , uint256 _amount ) external only crowdfund non zero amount ( _amount ) non zero address ( _to ) returns ( bool success ) { require ( balance of ( crowdfund address ) >= _amount ) ; decrement balance ( crowdfund address , _amount ) ; add to balance ( _to , _amount ) ; transfer ( NUM_ , _to , _amount ) ; return BOOL_ ; }
"
"function tokens sold ( ) public view returns ( uint256 ) { return tokens available for sale . sub ( token . balance of ( address ( this ) ) ) ; }
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }
"
"function sell kwhagainst ether ( uint256 amount ) returns ( uint revenue ) { require ( ! ( sell price eth == NUM_ || amount < kwhfor gas ) ) ; require ( ! ( balances [ msg . sender ] < amount ) ) ; revenue = safe mul ( amount , sell price eth ) ; require ( ! ( safe sub ( this . balance , revenue ) < gas reserve ) ) ; if ( ! msg . sender . send ( revenue ) ) { throw ; } else { balances [ this ] = safe add ( balances [ this ] , amount ) ; balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , amount ) ; transfer ( this , msg . sender , revenue ) ; return revenue ; } }
"
"function withdraw ( ) public { require ( msg . sender == contract owner ) ; withdraw wallet . transfer ( this . balance ) ; }
"
"function receive approval ( address _sender , uint256 _value , bit guild token _token contract , bytes _extra data ) public when not paused { require ( msg . sender != address ( NUM_ ) ) ; require ( _token contract == plat contract ) ; require ( _token contract . transfer from ( _sender , address ( this ) , _value ) ) ; require ( _extra data . length != NUM_ ) ; uint256 _amount ; for ( uint256 i = NUM_ ; i < _extra data . length ; i ++ ) { _amount = _amount + uint ( _extra data [ i ] ) * ( NUM_ * * ( NUM_ * ( _extra data . length - ( i + NUM_ ) ) ) ) ; } require ( _amount >= NUM_ && _amount <= NUM_ ) ; uint256 _price of bundle = _amount * eth price * plat price oracle contract . ethprice ( ) / ( NUM_ * * NUM_ ) ; require ( _value >= _price of bundle ) ; pay with plat ( _amount ) ; }
"
"function multi transfer ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint start balance = this . balance ; for ( uint i = NUM_ ; i < _addresses . length ; i ++ ) { _safe transfer ( _addresses [ i ] , _amounts [ i ] ) ; multi transfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( start balance - msg . value == this . balance ) ; return BOOL_ ; }
"
"function replace owner ( address owner , address new owner ) public only wallet only owner exists ( owner ) only owner does not exist ( new owner ) { for ( uint256 i = NUM_ ; i < owners . length ; i ++ ) { if ( owners [ i ] == owner ) { owners [ i ] = new owner ; break ; } } is owner [ owner ] = BOOL_ ; is owner [ new owner ] = BOOL_ ; owner removal ( owner ) ; owner addition ( new owner ) ; }
"
"function who am i ( ) public constant returns ( address ) { return msg . sender ; }
"
"function collect buy fee ( uint ethers , address affiliate ) internal returns ( uint ) { uint remaining ; uint fee = fee wallet . get fee ( ethers ) ; if ( safe math . safe sub ( address ( this ) . balance , ethers ) >= fee ) remaining = ethers ; else remaining = safe math . safe sub ( safe math . safe sub ( ethers , address ( this ) . balance ) , fee ) ; fee wallet . collect . value ( fee ) ( affiliate ) ; return remaining ; }
"
"function get latest version ( bytes32 _app , bytes32 _registry_id ) internal view returns ( bytes32 ) { uint length = uint ( registry read ( app version list ( _app ) , _registry_id ) ) ; return registry read ( app version list at ( _app , length ) , _registry_id ) ; }
"
"function transfer ( address _to , uint256 _value ) public valid address ( _to ) returns ( bool success ) { balance of [ msg . sender ] = safe sub ( balance of [ msg . sender ] , _value ) ; balance of [ _to ] = safe add ( balance of [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ msg . sender ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; balance of [ msg . sender ] = safe math . safe sub ( balance of [ msg . sender ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; }
"
"function claim tokens ( address _token ) public only owner { require ( _token != address ( NUM_ ) ) ; erc20 token = erc20 ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; claimed tokens ( _token , owner , balance ) ; }
"
"function burn tokens ( uint _value ) public not zero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , _value ) ; total supply = safe math . sub ( total supply , _value ) ; burn ( msg . sender , _value ) ; }
"
"modifier only admin ( ) { require ( msg . sender == admin address ) ; _ ; }
"
"function new policy ( bytes32 _carrier flight number , bytes32 _departure year month day , uint256 _departure time , uint256 _arrival time , currency _currency , bytes32 _customer external id ) public payable { require ( fd_ac . check permission ( NUM_ , NUM_ ) ) ; if ( _currency == currency . eth ) { if ( msg . value < min_premium || msg . value > max_premium ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } else { require ( msg . sender == get contract ( STR_ ) ) ; if ( _currency == currency . eur ) { if ( msg . value < min_premium_eur || msg . value > max_premium_eur ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } if ( _currency == currency . usd ) { if ( msg . value < min_premium_usd || msg . value > max_premium_usd ) { log policy declined (
"
"function execute proposal ( uint proposal number , uint256 refund amount , uint256 fees ) only owner public returns ( bool success ) { proposal storage p = proposals [ proposal number ] ; require ( ! p . executed ) ; require ( p . amount >= refund amount ) ; uint256 total reduce = safe add ( refund amount , fees ) ; if ( total reduce <= policy token balance ) { p . executed = BOOL_ ; policy token balance = safe sub ( policy token balance , total reduce ) ; policy fee collector = safe add ( policy fee collector , fees ) ; if ( ! ins chain token ledger . transfer ( p . recipient , refund amount ) ) { revert ( ) ; } uint id = policy internal id [ p . policy payload ] ; policies [ id ] . accumulated in = NUM_ ; policies [ id ] . since = now ; p . proposal passed = BOOL_ ; emit proposal tallied ( proposal number , refund amount , p . proposal passed ) ; emit policy out ( p . recipient , refund amount ,
"
"function calculate token presale ( uint value , uint decimals ) public constant returns ( uint ) { uint multiplier = NUM_ * * decimals ; return value . mul ( multiplier ) . div ( presale_token_in_wei ) ; }
"
"function donate ( ) public payable { require ( msg . value > NUM_ wei ) ; uint256 eth to transfer = address ( this ) . balance ; if ( pay doublr ) { if ( eth to transfer > NUM_ ) { address ( doublr ) . transfer ( eth to transfer ) ; doublr . payout ( ) ; } } else { uint256 pooh eth in contract = address ( pooh contract ) . balance ; if ( pooh eth in contract < NUM_ ether ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; owner . transfer ( eth to transfer ) ; emit transfer ( eth to transfer , address ( owner ) ) ; } else { token balance = my tokens ( ) ; if ( token balance > NUM_ ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; if ( eth to transfer > NUM_ ) { pooh contract . buy . value ( eth to transfer ) ( NUM_
"
"function press ( uint _count presses , uint _aff id ) public payable { require ( _count presses >= NUM_ ) ; require ( msg . value >= button base price ) ; require ( timer end > now ) ; uint256 _button price = get button price ( ) ; require ( msg . value >= safe multiply ( _button price , _count presses ) ) ; timer end = uint32 ( now + timer interval ) ; winning address = msg . sender ; uint256 two percent com = ( msg . value / NUM_ ) * NUM_ ; uint256 ten percent com = msg . value / NUM_ ; uint256 fifteen percent com = ( msg . value / NUM_ ) * NUM_ ; if ( _aff id > NUM_ && _aff id < players . length ) { players [ _aff id ] . player address . transfer ( ten percent com ) ; } uint [ ] memory main investors = get main investor ( ) ; uint main investor = main investors [ NUM_ ] ; players [ main investor ] . player address . transfer ( fifteen percent com ) ; count investor
"
"function start phase2 ( uint256 _start time ) public only owner { require ( _start time > NUM_ ) ; phase = phase . phase2 ; opening time = _start time ; }
"
"function _process purchase ( address _beneficiary , uint256 _token amount ) internal { super . _process purchase ( _beneficiary , _token amount ) ; token sold = token sold . add ( _token amount ) ; if ( block . timestamp < sale start time ) { token presale sold = token presale sold . add ( _token amount ) ; } }
"
"function calculate purchase return ( uint256 _supply , uint256 _connector balance , uint32 _connector weight , uint256 _deposit amount ) public view returns ( uint256 ) { require ( _supply > NUM_ && _connector balance > NUM_ && _connector weight > NUM_ && _connector weight <= max_weight ) ; if ( _deposit amount == NUM_ ) return NUM_ ; if ( _connector weight == max_weight ) return safe mul ( _supply , _deposit amount ) / _connector balance ; uint256 result ; uint8 precision ; uint256 base n = safe add ( _deposit amount , _connector balance ) ; ( result , precision ) = power ( base n , _connector balance , _connector weight , max_weight ) ; uint256 temp = safe mul ( _supply , result ) > > precision ; return temp - _supply ; }
"
"function burn from ( address _from , uint256 _value ) public only owner when not paused returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = safe math . safe sub ( balances [ _from ] , _value ) ; allowed [ _from ] [ msg . sender ] = safe math . safe sub ( allowed [ _from ] [ msg . sender ] , _value ) ; _total supply = safe math . safe sub ( _total supply , _value ) ; emit burn ( _from , _value ) ; return BOOL_ ; }
"
"function update wallet ( address _wallet ) only owner public returns ( bool ) { require ( _wallet != address ( NUM_ ) ) ; wallet updated ( wallet , _wallet ) ; wallet = _wallet ; return BOOL_ ; }
"
"function proxy payment ( address _owner ) payable public returns ( bool ) { do payment ( _owner ) ; return BOOL_ ; }
"
"function retrieve gains ( ) public no reentrancy when not in emergency protected mode returns ( bool success ) { uint gains = gains to receive [ msg . sender ] ; if ( gains > NUM_ ) { gains to receive [ msg . sender ] = NUM_ ; msg . sender . transfer ( gains ) ; return BOOL_ ; } else return BOOL_ ; }
"
"function buy ( player storage _player , internal buy event memory _buy event , uint256 _amount ) private { require ( now < finish time && _amount >= buy_amount_min && _amount <= buy_amount_max ) ; uint256 _day = ( now / NUM_ ) * NUM_ ; uint256 _back eth = NUM_ ; uint256 _eth = _amount ; if ( total pot < NUM_ ) { if ( _eth >= NUM_ ) { _back eth = _eth . sub ( NUM_ ) ; _eth = NUM_ ; } } tx count = tx count + NUM_ ; _buy event . flag1 += tx count * NUM_ ; _player . eth total = _player . eth total . add ( _eth ) ; total pot = total pot . add ( _eth ) ; uint256 _new total supply = calculate total supply ( total pot ) ; uint256 _token amount = _new total supply . sub ( total supply ) ; _player . token balance = _player . token balance . add ( _token amount ) ; if ( _player . token day == _day ) { _player . token day balance = _player . token day balance . add ( _token
"
"function release team tokens after24 months ( ) check team locking period24 months only team returns ( bool success ) { require ( team supply24 months > NUM_ ) ; add to balance ( team address , team supply24 months ) ; transfer ( NUM_ , team address , team supply24 months ) ; team supply24 months = NUM_ ; team supply . sub ( team supply24 months ) ; return BOOL_ ; }
"
"function match against book ( uint128 order id , uint their price start , uint their price end , uint max matches ) internal returns ( match stop reason match stop reason ) { order storage order = order for order id [ order id ] ; uint bmi = their price start / NUM_ ; uint bti = their price start % NUM_ ; uint bmi end = their price end / NUM_ ; uint bti end = their price end % NUM_ ; uint cbm = occupied price bitmaps [ bmi ] ; uint dbm = cbm ; uint wbm = cbm > > bti ; bool removed last at price ; match stop reason = match stop reason . none ; while ( bmi < bmi end ) { if ( wbm == NUM_ || bti == NUM_ ) { if ( dbm != cbm ) { occupied price bitmaps [ bmi ] = dbm ; } bti = NUM_ ; bmi ++ ; cbm = occupied price bitmaps [ bmi ] ; wbm = cbm ; dbm = cbm ; } else { if ( ( wbm & NUM_ ) != NUM_ ) { ( removed
"
"function distribute reserved tokens ( uint _num_destinations ) internal view { if ( _num_destinations == NUM_ ) revert ( STR_ ) ; uint total_sold = uint ( contract . read ( token manager . tokens sold ( ) ) ) ; uint total_supply = uint ( contract . read ( token manager . token total supply ( ) ) ) ; uint reserved_len = uint ( contract . read ( token manager . reserved destinations ( ) ) ) ; contract . storing ( ) ; if ( reserved_len == NUM_ ) revert ( STR_ ) ; if ( _num_destinations > reserved_len ) _num_destinations = reserved_len ; contract . decrease ( token manager . reserved destinations ( ) ) . by ( _num_destinations ) ; for ( uint i = NUM_ ; i < _num_destinations ; i ++ ) { address addr = address ( contract . read ( bytes32 ( NUM_ * ( _num_destinations - i ) + uint ( token manager . reserved destinations ( ) ) ) ) ) ; uint to_add = uint ( contract . read ( token manager . dest percent ( addr ) ) ) ; uint precision = uint ( contract .
"
"function go next period ( ) only owner public { for ( uint i = NUM_ ; i <= total period ; i ++ ) { if ( current period < total period && now >= period start [ current period + NUM_ ] ) { current period = current period + NUM_ ; is token collectable = BOOL_ ; log period start ( current period ) ; } } }
"
"function claim ( address _beneficiary ) public only authorized { require ( _beneficiary != address ( NUM_ ) ) ; require ( map address to token [ _beneficiary ] > NUM_ ) ; uint index to be deleted = map address to index [ _beneficiary ] ; require ( index to be deleted != NUM_ ) ; uint array length = address indices . length ; if ( index to be deleted < array length - NUM_ ) { address indices [ index to be deleted ] = address indices [ array length - NUM_ ] ; map address to index [ address indices [ index to be deleted ] ] = index to be deleted ; } address indices . length -- ; map address to index [ _beneficiary ] = NUM_ ; uint256 _claim amount = map address to token [ _beneficiary ] ; map address to token [ _beneficiary ] = NUM_ ; waiting for claim tokens = waiting for claim tokens . sub ( _claim amount ) ; emit claim token ( msg . sender , _beneficiary , _claim amount ) ; _deliver tokens ( _beneficiary , _claim amount ) ; }
"
"function wei to owner ( address _address , uint amount ) public contract_only owner { require ( amount <= address ( this ) . balance ) ; _address . transfer ( amount ) ; }
"
"function open sale ( ) admin only { sale phase = BOOL_ ; sale started ( ) ; }
"
"function create sale auction ( uint256 _property id , uint256 _starting price , uint256 _ending price , uint256 _duration ) public when not paused { require ( _owns ( msg . sender , _property id ) ) ; _approve ( _property id , sale auction ) ; sale auction . create auction ( _property id , _starting price , _ending price , _duration , msg . sender ) ; }
"
"function fight ( uint32 knight id , uint16 knight index ) public { if ( knight id != ids [ knight index ] ) knight index = get character index ( knight id ) ; character storage knight = characters [ knight id ] ; require ( cooldown [ knight id ] + cooldown threshold <= now ) ; require ( knight . owner == msg . sender ) ; require ( knight . character type < NUM_ * num dragon types ) ; require ( knight . character type >= num dragon types ) ; uint16 dragon index = get random dragon ( knight id ) ; assert ( dragon index < max characters ) ; uint32 dragon id = ids [ dragon index ] ; character storage dragon = characters [ dragon id ] ; uint128 value ; uint16 base_probability ; uint16 dice = uint16 ( generate random number ( knight id ) % NUM_ ) ; uint256 knight power = skl token . balance of ( knight . owner ) / NUM_ * * NUM_ + xper token . balance of ( knight . owner ) ; uint256 dragon power = skl token . balance of (
"
"function remove exchanger ( address exchanger ) only owner public { remove role ( exchanger , role_exchanger ) ; }
"
"function tokens bought with btc ( address _beneficiary , uint256 _tokens ) public payable { require ( msg . sender == btc token bought address ) ; require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( whitelist [ _beneficiary ] ) ; require ( fida token . total supply ( ) < NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ) ; require ( _tokens >= NUM_ * NUM_ * * decimals ) ; if ( ! earlybird ended ) { _invest as earlybird ( _beneficiary , _tokens ) ; } else { _invest as bonus program ( _beneficiary , _tokens ) ; } }
"
"function substr ( bytes memory bts , uint256 start index , uint256 len ) internal pure returns ( bytes memory ) { require ( start index + len <= bts . length ) ; if ( len == NUM_ ) { return ; } uint256 addr = data ptr ( bts ) ; return to bytes ( addr + start index , len ) ; }
"
"function _spin tokens ( tkn _tkn , uint div rate ) private bet is valid ( _tkn . value , div rate ) { require ( game active ) ; require ( block . number <= ( ( NUM_ * * NUM_ ) - NUM_ ) ) ; address _customer address = _tkn . sender ; uint _wagered = _tkn . value ; player spin memory spin = player spins [ _tkn . sender ] ; add contract balance ( div rate , _wagered ) ; require ( block . number != spin . blockn ) ; if ( spin . blockn != NUM_ ) { _finish spin ( _tkn . sender ) ; } spin . blockn = uint48 ( block . number ) ; spin . token value = uint200 ( _wagered ) ; spin . tier = uint8 ( zethr tier library . get tier ( div rate ) ) ; spin . div rate = div rate ; player spins [ _tkn . sender ] = spin ; total spins += NUM_ ; total zthwagered += _wagered ; emit tokens wagered ( _customer address , _wagered ) ; }
"
"function bulk transfer ( address [ ] _tos , uint256 [ ] _values ) public when not paused not frozen if authorized ( msg . sender , bulktransfer ) returns ( bool ) { require ( _tos . length == _values . length ) ; uint256 source balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; for ( uint256 i = NUM_ ; i < _tos . length ; i ++ ) { uint256 current value = _values [ i ] ; address _to = _tos [ i ] ; require ( _to != address ( NUM_ ) ) ; require ( current value <= source balance ) ; require ( msg . sender != _to ) ; source balance = source balance . sub ( current value ) ; balances [ _to ] = balances [ _to ] . add ( current value ) ; track addresses ( _to ) ; emit transfer ( msg . sender , _tos [ i ] , current value ) ; } balances [ msg . sender ] = source balance ; emit bulk transfer ( msg . sender , _tos . length )
"
"function release tokens to ( address buyer ) internal returns ( bool ) { require ( started ( ) ) ; require ( ! ended ( ) ) ; uint256 wei amount = msg . value ; uint256 wei dollars = wei amount . mul ( eth_usd_exchange_cents ) ; wei dollars = wei dollars . div ( NUM_ ) ; uint256 current price = price ( ) ; uint tokens = wei dollars . mul ( current price ) ; tokens = tokens . div ( NUM_ ) ; uint token raised = total tokens . sub ( remaining tokens ) ; if ( now < round two time ) { require ( token raised . add ( tokens ) <= bls_pre_ico ) ; } require ( token raised . add ( tokens ) <= bls_total_cap ) ; wei raised = wei raised . add ( wei amount ) ; uint cents wei raised = wei raised . mul ( eth_usd_exchange_cents ) ; uint goal = usd_hard_cap * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ; require ( cents wei raised <= goal ) ; remaining tokens = remaining tokens . sub ( tokens
"
"modifier game in progress ( ) { require ( game_started ) ; require ( now <= game_end ) ; _ ; }
"
"function addr ( bytes32 node ) public view returns ( address ) { return records [ node ] . addr ; }
"
"function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize . cb address ( ) ) revert ( ) ; uint transaction id = oracalize my id2transaction id [ myid ] ; transaction memory transaction = transactions [ transaction id ] ; if ( bytes ( result ) . length == NUM_ ) { transaction aborted ( transaction id , STR_ ) ; recoverable [ transaction . return address ] += transaction . amount ; transaction . amount = NUM_ ; } else { address deposit address = parse addr ( result ) ; require ( deposit address != msg . sender ) ; uint send amount = transaction . amount ; transaction . amount = NUM_ ; if ( deposit address . send ( send amount ) ) transaction sent to shape shift ( transaction id , transaction . return address , deposit address , send amount ) ; else { transaction aborted ( transaction id , STR_ ) ; recoverable [ transaction . return address ] += send amount ; } } }
"
"function make adoption request ( bytes5 cat id ) payable is not sender ( cat owners [ cat id ] ) { require ( cat owners [ cat id ] != NUM_ ) ; adoption request storage existing request = adoption requests [ cat id ] ; require ( msg . value > NUM_ ) ; require ( msg . value > existing request . price ) ; if ( existing request . price > NUM_ ) { pending withdrawals [ existing request . requester ] += existing request . price ; } adoption requests [ cat id ] = adoption request ( BOOL_ , cat id , msg . sender , msg . value ) ; adoption requested ( cat id , msg . value , msg . sender ) ; }
"
"function revoke vote ( ) public check time { require ( votes by address [ msg . sender ] . time > NUM_ ) ; uint256 voice weight = votes by address [ msg . sender ] . weight ; bool agree = votes by address [ msg . sender ] . agree ; votes by address [ msg . sender ] . time = NUM_ ; votes by address [ msg . sender ] . weight = NUM_ ; votes by address [ msg . sender ] . agree = BOOL_ ; total voted = safe sub ( total voted , NUM_ ) ; if ( agree ) { yes counter = safe sub ( yes counter , voice weight ) ; } else { no counter = safe sub ( no counter , voice weight ) ; } }
"
"function mint ( address _to , uint256 _amount ) public only owner can mint only payload size ( NUM_ * NUM_ ) returns ( bool ) { total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; mint ( _to , _amount ) ; transfer ( NUM_ , _to , _amount ) ; return BOOL_ ; }
"
"function mint token ( address _to , uint _value ) internal { balances [ _to ] = balances [ _to ] . add ( _value ) ; total supply = total supply . add ( _value ) ; require ( balances [ _to ] >= _value && total supply >= _value ) ; emit transfer ( address ( NUM_ ) , _to , _value ) ; }
"
"function change fees ( uint8 _new commission ) public only owner { require ( _new commission <= NUM_ ) ; commission_rate = _new commission ; }
"
"function new round ( ) public payable { if ( now >= ( round started timestamp + NUM_ days ) ) { if ( oraclize_get price ( STR_ ) > this . balance ) { new oraclize query ( STR_ ) ; } else { new oraclize query ( STR_ ) ; bytes32 query id = oraclize_query ( STR_ , _oraclize url ) ; valid ids [ query id ] = BOOL_ ; } } else { revert ( ) ; } }
"
"function confirm and check ( bytes32 _operation ) internal returns ( bool ) { uint index = owner index [ msg . sender ] ; if ( index == NUM_ ) { throw ; } var pending = pendings [ _operation ] ; if ( pending . yet needed == NUM_ ) { pending . yet needed = required ; pending . owners done = NUM_ ; pending . index = pendings index . length ++ ; pendings index [ pending . index ] = _operation ; } uint owner index bit = NUM_ * * index ; if ( pending . owners done & owner index bit == NUM_ ) { confirmation ( msg . sender , _operation ) ; if ( pending . yet needed <= NUM_ ) { delete pendings index [ pendings [ _operation ] . index ] ; delete pendings [ _operation ] ; return BOOL_ ; } else { pending . yet needed -- ; pending . owners done |= owner index bit ; } } return BOOL_ ; }
"
"function make offer ( uint256 _token id , uint8 _v , bytes32 _r , bytes32 _s ) public not halted ( ) payable { address recovered signer = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recovered signer ] == BOOL_ ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value > NUM_ ) ; uint256 current price = get token price ( _token id ) ; require ( current price > NUM_ ) ; if ( _token id == logo id && token . get current price for token ( _token id ) == NUM_ ) { require ( msg . value >= logo price ) ; token . update tokens state ( logo id , msg . value ) ; erc20token . mint ( msg . sender , NUM_ ) ; transfer ethers ( platform wallet , msg . value ) ; emit purchased ( NUM_ , msg . sender , _token id , msg . value , NUM_ , NUM_ , msg . value , now ) ; return ; } uint256 min price = pricing
"
"function initialise allocations ( ) public only_after_sale when_allocations_uninitialised { allocations initialised = BOOL_ ; liquid allocatable = liquid_allocation_ppm * total sold / sales_allocation_ppm ; locked allocatable = locked_allocation_ppm * total sold / sales_allocation_ppm ; }
"
"function safe withdrawal ( ) after deadline { if ( ! minimum target reached && crowdsale closed ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } }
"
"function set prices ( uint256 price for pre ico in wei , uint256 price for ico in wei ) is owner { require ( price for pre ico in wei > NUM_ ) ; require ( price for ico in wei > NUM_ ) ; pre icoprice = price for pre ico in wei ; icoprice = price for ico in wei ; update prices ( ) ; }
"
"function create tokens ( ) payable external { if ( is finalized ) revert ( ) ; if ( now < funding start time ) revert ( ) ; if ( now > funding end time ) revert ( ) ; if ( msg . value == NUM_ ) revert ( ) ; uint256 tokens = safe mult ( msg . value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) revert ( ) ; total supply = checked supply ; balances [ msg . sender ] += tokens ; create indi ( msg . sender , tokens ) ; }
"
"function core ( uint256 _round , uint256 _p id , uint256 _eth ) internal { round memory current = rounds [ current round ] ; if ( player round data [ _p id ] [ _round ] . keys == NUM_ ) { update player ( _p id ) ; } if ( block . timestamp > current . end time ) { finalize ( players [ _p id ] . referer ) ; update player ( _p id ) ; } round storage current_now = rounds [ current round ] ; uint256 _keys = keys ( _eth ) ; if ( _keys <= NUM_ ) { players [ _p id ] . wallet = _eth . add ( players [ _p id ] . wallet ) ; return ; } if ( _keys >= decimals ) { current_now . winner = players [ _p id ] . addr ; current_now . end time = current_now . end time . add ( time gap ) ; if ( current_now . end time . sub ( block . timestamp ) > max time remain ) { current_now . end time = block . timestamp . add ( max time remain )
"
"function migrate2 ( address _old address , uint40 _from index , uint40 _to index , address sale address , address breeding address ) public only owner when paused { blockchain cuties core old = blockchain cuties core ( _old address ) ; market interface old sale market = market interface ( sale address ) ; market interface old breeding market = market interface ( breeding address ) ; for ( uint40 i = _from index ; i <= _to index ; i ++ ) { address owner = old . owner of ( i ) ; if ( owner == sale address ) { ( owner , , , , , ) = old sale market . get auction info ( i ) ; } if ( owner == breeding address ) { ( owner , , , , , ) = old breeding market . get auction info ( i ) ; } _transfer ( NUM_ , owner , i ) ; } }
"
"function start new round ( uint256 _rate , address _wallet , erc20 _token , uint256 _cap , uint256 _opening time , uint256 _closing time ) payable public only owner { require ( ! has opened ( ) ) ; rate = _rate ; wallet = _wallet ; token = _token ; cap = _cap ; opening time = _opening time ; closing time = _closing time ; }
"
"function register opinion ( uint256 _token id , string _new opinion ) public payable { _init opinion ( _token id , _new opinion ) ; address old owner = opinion index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = opinion index to price [ _token id ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 payment = selling price ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; opinion index to price [ _token id ] = sponsor starting cost ; _transfer ( old owner , new owner , _token id ) ; ceo address . transfer ( payment ) ; token sold ( _token id , selling price , opinion index to price [ _token id ] , old owner , new owner , opinions [ _token id ] . text ) ; msg . sender . transfer ( purchase excess ) ; }
"
"function stage name ( ) constant public returns ( uint8 ) { uint256 e t2 = s t2 + d tlp2 ; if ( now < s t2 ) { return NUM_ ; } if ( now >= s t2 && now <= e t2 ) { return ( NUM_ ) ; } if ( now > e t2 && now < e t2 + d bt ) { return ( NUM_ ) ; } if ( now >= ( e t2 + d bt ) && now <= ( e t2 + d bt + d w ) ) { return ( NUM_ ) ; } if ( now > ( e t2 + d bt + d w ) && now < ( e t2 + d bt + d w + d bt ) ) { return ( NUM_ ) ; } if ( now >= ( e t2 + d bt + d w + d bt ) && now <= ( e t2 + d bt + d w + d bt + d w ) ) { return ( NUM_ ) ; } if ( now > ( e t2 + d bt +
"
"function check value sent ( bytes tx bytes , bytes20 btc address , uint value ) returns ( bool , uint ) { uint pos = NUM_ ; ( , pos ) = scan inputs ( tx bytes , pos , NUM_ ) ; var ( output_values , script_starts , output_script_lens , ) = scan outputs ( tx bytes , pos , NUM_ ) ; for ( uint i = NUM_ ; i < output_values . length ; i ++ ) { var pkhash = parse output script ( tx bytes , script_starts [ i ] , output_script_lens [ i ] ) ; if ( pkhash == btc address && output_values [ i ] >= value ) { return ( BOOL_ , output_values [ i ] ) ; } } }
"
"function buy tokens ( address contributor ) payable { uint256 amount = calc amount ( ) ; require ( contributor != NUM_ ) ; require ( valid purchase ( ) ) ; token . mint ( contributor , amount ) ; token purchase ( NUM_ , contributor , msg . value , amount ) ; transfer ( NUM_ , contributor , amount ) ; wei raised = wei raised . add ( msg . value ) ; wallet . transfer ( msg . value ) ; }
"
"function revoke mint delegate ( address _mint delegate ) only owner public returns ( bool ) { uint length = mint delegates . length ; require ( length > NUM_ ) ; address last delegate = mint delegates [ length - NUM_ ] ; if ( _mint delegate == last delegate ) { delete mint delegates [ length - NUM_ ] ; mint delegates . length -- ; } else { for ( uint i = NUM_ ; i < length ; i ++ ) { if ( mint delegates [ i ] == _mint delegate ) { mint delegates [ i ] = last delegate ; delete mint delegates [ length - NUM_ ] ; mint delegates . length -- ; break ; } } } revoke mint delegate ( _mint delegate ) ; return BOOL_ ; }
"
"function grant kudos ( address user to grant , uint reason ) only owner { user info user = users [ user to grant ] ; if ( user . kudos limit == NUM_ ) throw ; if ( reason != grant_reason_facebook && reason != grant_reason_twitter ) throw ; if ( user . is judge ) throw ; if ( user . grant [ reason ] ) throw ; user . kudos limit += social_proof_kudos ; user . grant [ reason ] = BOOL_ ; }
"
"function change owner ( address _addr ) { if ( msg . sender != owner || settings state == setting state value . locked release ) throw ; owner = _addr ; }
"
"function power balance of ( address _owner ) constant returns ( uint256 ) { return storage ( storage addr ) . get bal ( STR_ , _owner ) ; }
"
"function initialize new sale ( uint256 rate , uint256 shares cap , address beneficiary , address investor ) public is active only majority only when not selling { require ( rate > NUM_ ) ; require ( shares cap > NUM_ ) ; require ( beneficiary != NUM_ ) ; require ( investor != NUM_ ) ; require ( token ( ) . balance of ( msg . sender ) >= shares cap ) ; current sale . creator = msg . sender ; current sale . rate = rate ; current sale . shares cap = shares cap ; current sale . beneficiary = beneficiary ; current sale . investor = investor ; current sale . shareholder = msg . sender ; current sale . wei raised = NUM_ ; current sale . shares sold = NUM_ ; current sale . ended = BOOL_ ; current sale . exists = BOOL_ ; require ( token ( ) . transfer from ( msg . sender , address ( this ) , shares cap ) ) ; require ( is majority shareholder ( msg . sender ) ) ; }
"
"function turn on sale ( ) only owner public { _selling = BOOL_ ; }
"
"function set max allowed reserving percentage ( uint _value ) public only owner returns ( bool success ) { assert ( _value > NUM_ && _value < NUM_ ) ; min allowed reserving percentage = _value ; emit set max allowed reserving percentage ( _value ) ; return BOOL_ ; }
"
"function perform payout ( ) private can perform payout { uint losing chunk = this . balance - total amounts bet [ uint ( winning team ) ] ; uint bookie payout = losing chunk / bookie_pool_commission ; bookies [ NUM_ ] . transfer ( bookie payout / bookies . length ) ; bookies [ NUM_ ] . transfer ( bookie payout / bookies . length ) ; for ( uint k = NUM_ ; k < betters . length ; k ++ ) { uint bet on winner = better info [ betters [ k ] ] . amounts bet [ uint ( winning team ) ] ; uint payout = bet on winner + ( ( bet on winner * ( losing chunk - bookie payout ) ) / total amounts bet [ uint ( winning team ) ] ) ; if ( payout > NUM_ ) betters [ k ] . transfer ( payout ) ; } payout completed = BOOL_ ; }
"
"function protected unlock ( address _from , uint256 _value , string _secret ) external when not paused returns ( bool ) { address to = msg . sender ; if ( msg . sender == owner ) { to = the coin ; } require ( check secret ( to , _secret , protected balances [ _from ] [ to ] . hashed ) ) ; require ( protected balances [ _from ] [ to ] . balance == _value ) ; balances [ the coin ] = balances [ the coin ] . sub ( _value ) ; balances [ to ] = balances [ to ] . add ( _value ) ; protected balances [ _from ] [ to ] . balance = NUM_ ; protected supply = protected supply . sub ( _value ) ; protected unlock ( _from , to , _value ) ; transfer ( _from , to , _value ) ; return BOOL_ ; }
"
"function set composition price ( uint256 _token id , uint256 _price ) public only owner of ( _token id ) { _set composition price ( _token id , _price ) ; }
"
"function self register dinwith resolver ( address _resolver ) public returns ( uint256 _din ) { return register dinwith resolver ( msg . sender , _resolver ) ; }
"
"function get deposit ( address _addr ) public constant returns ( uint256 ) { return deposit [ _addr ] ; }
"
"function valid purchase ( ) internal constant returns ( bool ) { if ( msg . value < NUM_ ) { return BOOL_ ; } if ( token . total supply ( ) . add ( msg . value . mul ( get rate ( ) ) ) >= cap ) { return BOOL_ ; } if ( now > NUM_ && now < NUM_ ) { return BOOL_ ; } if ( NUM_ >= now && NUM_ <= now ) { if ( token . total supply ( ) . add ( msg . value . mul ( get rate ( ) ) ) >= cap_pre_sale ) { return BOOL_ ; } } if ( NUM_ >= now && NUM_ <= now ) { if ( total supply ico . add ( msg . value . mul ( get rate ( ) ) ) >= cap_ico_sale ) { return BOOL_ ; } } if ( get rate ( ) == NUM_ ) { return BOOL_ ; } return super . valid purchase ( ) ; }
"
"function amend claim ( uint8 claim amount set , uint8 pay amount set , uint8 fee amount set , uint8 accuracy ) public only director returns ( bool success ) { require ( claim amount set == ( pay amount set + fee amount set ) ) ; claim amount = claim amount set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; pay amount = pay amount set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; fee amount = fee amount set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; return BOOL_ ; }
"
"function make tradable ( ) public only owner { tradable = BOOL_ ; tradable tokens ( ) ; }
"
"function get current week ( ) view internal returns ( uint256 _week ) { uint256 week = ( now . sub ( start time ) ) . div ( NUM_ weeks ) ; if ( week > NUM_ ) { week = NUM_ ; } return week ; }
"
"function do roll ( ) external no ether { uint value_ ; bool found ; bool sub found ; for ( uint a = NUM_ ; a < players [ msg . sender ] . length ; a ++ ) { if ( players [ msg . sender ] [ a ] . valid ) { sub found = BOOL_ ; if ( players [ msg . sender ] [ a ] . block number + roll loss block delay <= block . number ) { uint fee value_ = players [ msg . sender ] [ a ] . value / NUM_ ; fee value += fee value_ ; investor add fee ( players [ msg . sender ] [ a ] . value - fee value_ ) ; do roll event ( msg . sender , players [ msg . sender ] [ a ] . value , players [ msg . sender ] [ a ] . id , BOOL_ , BOOL_ , BOOL_ , BOOL_ , NUM_ , NUM_ , NUM_ ) ; sub found = BOOL_ ; } if ( ! contract enabled || players [ msg . sender ] [ a ] . sum
"
"modifier only super owner ( ) { require ( msg . sender == super owner ) ; _ ; }
"
"function withdraw by admin_unau ( uint256 [ ] inputs ) external only admin { uint256 amount = inputs [ NUM_ ] ; uint256 gas fee = inputs [ NUM_ ] ; uint256 data = inputs [ NUM_ ] ; uint256 payment method = data & payment_method_mask ; address token = token id2 address [ ( data & withdraw_token_mask ) > > NUM_ ] ; address user = user id2 address [ data & user_mask ] ; bytes32 hash = keccak256 ( this , amount , gas fee , data & sign_mask | uint256 ( token ) ) ; require ( ! used hash [ hash ] ) ; require ( verify ( hash , user , uint8 ( data & v_mask == NUM_ ? NUM_ : NUM_ ) , bytes32 ( inputs [ NUM_ ] ) , bytes32 ( inputs [ NUM_ ] ) ) ) ; address gas token = NUM_ ; if ( payment method == pay_by_joy ) { gas token = joy token ; } else if ( payment method == pay_by_token ) { gas token = token ; } if ( gas token == token ) { balances [ token ] [ user ] = balances
"
"function destroy ( ) only owner public { selfdestruct ( owner ) ; }
"
"function withdraw amount ( uint256 _amount ) public only owner { require ( _amount <= this . balance ) ; owner . transfer ( _amount ) ; }
"
"function burn tokens ( uint256 _value ) public only owner { require ( balances [ this ] > NUM_ ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( this , _value ) ; }
"
"function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { return wei amount . mul ( rate ) ; }
"
"function switch crowd sale stage ( ) external only owner { require ( ! is in final state && ! is in round two state ) ; if ( ! is in pre sale state ) { is in pre sale state = BOOL_ ; exchange rate = NUM_ ; sale cap = ( NUM_ * NUM_ * * NUM_ ) * ( uint ( NUM_ ) * * decimals ) ; emit switch crowd sale stage ( STR_ , exchange rate ) ; } else if ( ! is in round one state ) { is in round one state = BOOL_ ; exchange rate = NUM_ ; sale cap = sale cap + ( ( NUM_ * NUM_ * * NUM_ ) * ( uint ( NUM_ ) * * decimals ) ) ; emit switch crowd sale stage ( STR_ , exchange rate ) ; } else if ( ! is in round two state ) { is in round two state = BOOL_ ; exchange rate = NUM_ ; sale cap = sale cap + ( ( NUM_ * NUM_ * * NUM_ ) * ( uint ( NUM_ ) * * decimals ) ) ;
"
"function check minimum ( stage storage storage self , uint8 _stage , uint256 _tokens ) internal view returns ( bool is valid ) { if ( _tokens < self . stages [ _stage ] . minimum buy ) { return BOOL_ ; } else { return BOOL_ ; } }
"
"function stop ( ) public only owner { is finalized = BOOL_ ; }
"
"modifier only product owner ( bytes32 product id ) { product storage p = products [ product id ] ; require ( p . id != NUM_ , STR_ ) ; require ( p . owner == msg . sender || owner == msg . sender , STR_ ) ; _ ; }
"
"function upgrade ship ( uint256 _token id , uint256 [ ship_slots ] _objects ) external when not paused { require ( ethernauts storage . is category ( _token id , uint8 ( asset category . ship ) ) ) ; require ( ethernauts storage . is state ( _token id , uint8 ( asset state . available ) ) ) ; require ( msg . sender == ethernauts storage . owner of ( _token id ) ) ; require ( ! is exploring ( _token id ) ) ; uint i = NUM_ ; uint8 [ stats_size ] memory _ship stats = ethernauts storage . get stats ( _token id ) ; uint256 level = _ship stats [ uint ( ship stats . level ) ] ; uint8 [ stats_size ] [ ship_slots ] memory _objects stats ; require ( level < max_level ) ; uint256 [ ] memory upgrades to token index = new uint256 [ ] ( ethernauts storage . total supply ( ) ) ; for ( i = NUM_ ; i < _objects . length ; i ++ ) { require ( msg . sender == ethernauts storage . owner of ( _objects [ i ]
"
"function contribute by bitcoin ( uint256 _bitcoin amount , uint256 _ether amount , address _contributor wallet , uint _contribution datetime ) public over min contribution ( _ether amount ) only owner contribution allowed { require ( _contribution datetime <= get current datetime ( ) ) ; uint256 _basic token = get basic token amount ( _ether amount ) ; uint256 _time bonus = get time bonus amount ( _basic token ) ; uint256 _volume bonus = get volume bonus amount ( _basic token , _ether amount ) ; uint256 _total token = _basic token . add256 ( _time bonus ) . add256 ( _volume bonus ) ; if ( _contribution datetime > last contribition date [ _contributor wallet ] ) last contribition date [ _contributor wallet ] = _contribution datetime ; referral contribution [ _contributor wallet ] = referral contribution [ _contributor wallet ] . add256 ( _ether amount ) ; collectable token [ _contributor wallet ] = collectable token [ _contributor wallet ] . add256 ( _total token ) ; total collectable token = total collectable token . add256 ( _total token ) ; log contribution bitcoin ( _contributor wallet , _bitcoin amount , _ether amount , _basic token
"
"function _allocate eth ( address _beneficiary , uint _amount , uint _release date ) private { if ( has balance ( _beneficiary , _release date ) ) { allocated [ _beneficiary ] [ _release date ] . eth += _amount ; } else { allocated [ _beneficiary ] [ _release date ] = balance ( _amount , NUM_ , allocated index [ _beneficiary ] . push ( _release date ) - NUM_ ) ; } allocated eth += _amount ; }
"
"function add investor bonus in percent ( address _to , uint8 p ) public only owner { require ( p > NUM_ && p <= NUM_ ) ; uint bonus = balances [ _to ] . mul ( p ) . div ( NUM_ ) ; investor given = investor given . add ( bonus ) ; require ( investor given <= investor supply ) ; _freeze transfer ( _to , bonus ) ; }
"
"function bind certificate2 wallet ( address wallet , bytes32 certificate_hash ) public { certificate meta storage cert = certificates [ certificate_hash ] ; require ( cert . expires > now ) ; bytes32 sender_certificate_hash = wallet_authority_certificate [ msg . sender ] [ cert . ca_address ] ; require ( cert . ca_address == msg . sender || cert . certificate_hash == sender_certificate_hash ) ; wallet_authority_certificate [ wallet ] [ cert . ca_address ] = certificate_hash ; log bind certificate2 wallet ( msg . sender , certificate_hash , wallet ) ; }
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowances [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }
"
"function end sale ( ) public { require ( was sale started && ! was sale ended ) ; require ( total raised >= hard cap || now > date sale ended ) ; was sale ended = BOOL_ ; was soft cap met = total raised >= soft cap ; if ( ! was soft cap met ) { token . mint ( wallet , NUM_ ) ; emit sale failed ( now ) ; return ; } token . freeze ( BOOL_ ) ; uint _locker amt = token . total supply ( ) / NUM_ ; token . mint ( locker , _locker amt ) ; locker . start vesting ( _locker amt , NUM_ ) ; uint _capital amt = ( total raised * capital pct bips ) / NUM_ ; if ( address ( this ) . balance < _capital amt ) _capital amt = address ( this ) . balance ; treasury . add capital . value ( _capital amt ) ( ) ; if ( wallet . call . value ( address ( this ) . balance ) ( ) ) { } emit sale successful ( now ) ; }
"
"function get price wei ( uint _day ) public returns ( uint ) { require ( now >= start2018 && now <= end2018 ) ; day = ( now - start2018 ) / d + NUM_ ; if ( day > day old ) { uint256 _value = ( ( day - day old - NUM_ ) * tokens daily + left today ) * NUM_ * * uint256 ( decimals ) ; _transfer ( this , creator , _value ) ; tokens today = NUM_ ; day old = day ; } if ( _day != NUM_ ) { day = _day ; } uint n = day - NUM_ ; uint p = NUM_ + n * NUM_ / NUM_ ; uint s = NUM_ ; uint x = NUM_ ; uint y = NUM_ ; for ( uint i = NUM_ ; i < p ; ++ i ) { s += start price * x / y / ( q * * i ) ; x = x * ( n - i ) ; y = y * ( i + NUM_ ) ; } return ( s ) ; }
"
"function drain ( ) external only owner { owner . transfer ( this . balance ) ; }
"
"function __callback ( bytes32 _query id , string _result , bytes _proof ) public { if ( msg . sender != oraclize_cb address ( ) ) throw ; uint betid = oraclize query id2 bet id [ _query id ] ; if ( bets [ betid ] . player address a == address ( NUM_ ) ) throw ; if ( bets [ betid ] . player address b == address ( NUM_ ) ) throw ; if ( bets [ betid ] . bet state != bet_state_waitoraclize ) throw ; log_oraclize_callback ( betid , _query id , _result , _proof ) ; if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) != NUM_ ) { cancel bet ( betid , BOOL_ , bet_state_cancel_by_oraclize_error_random_number ) ; } else { uint max range = NUM_ * * ( NUM_ * NUM_ ) ; uint random number = uint ( sha3 ( _result ) ) % max range ; uint random a = random number > > NUM_ ; uint random b = random number & NUM_ ; bets [ betid ] . number rolled = random number ; uint win amount = NUM_ * bets [
"
"function create crowdsale ( address _token , address _refund wallet , uint256 _cap , uint256 _goal , uint256 _rate , uint256 _min invest , uint256 _closing time , bool _early closure , uint8 _commission ) external non zero address ( _token ) non zero address ( _refund wallet ) { require ( crowdsales [ _token ] . owner == address ( NUM_ ) , STR_ ) ; require ( _goal <= _cap , STR_ ) ; require ( _min invest > NUM_ , STR_ ) ; require ( _commission <= NUM_ , STR_ ) ; _cap . mul ( _rate ) ; crowdsales [ _token ] = crowdsale ( { owner : msg . sender , refund wallet : _refund wallet , cap : _cap , goal : _goal , raised : NUM_ , rate : _rate , min invest : _min invest , closing time : _closing time , early closure : _early closure , state : states . active , commission : _commission } ) ; emit crowdsale created ( msg . sender , _token , _refund wallet , _cap , _goal , _rate , _closing time , _early closure , _commission ) ; }
"
"function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }
"
"function pause ( bytes32 _hash ) external poll approved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) not before genesis { if ( ! paused ) { paused = BOOL_ ; log pause ( _hash ) ; } }
"
"function token burn ( uint256 _amount ) public only admin returns ( bool burned ) { require ( _amount > NUM_ ) ; require ( _amount < total supply ) ; require ( balances [ owner ] > _amount ) ; require ( balances [ owner ] . sub ( _amount ) >= NUM_ ) ; require ( total supply . sub ( _amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; token burn ( msg . sender , _amount , BOOL_ ) ; return BOOL_ ; }
"
"function buyback ( address recipient ) moderator or seller only public { erc20 erc = erc20 ( token contract ) ; uint256 balance = erc . balance of ( this ) ; erc . transfer ( recipient , balance ) ; marketboard listing buyback ( token contract , balance ) ; reset ( ) ; }
"
"function reveal bet ( uint game id , uint player secret ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for reveal ) ; require ( game . player1 == msg . sender ) ; uint i ; for ( i = NUM_ ; i < wheel_size ; ++ i ) { if ( create wheel bet hash ( game id , i , player secret ) == game . wheel bet player1 ) { game . wheel bet player1 = i ; break ; } } require ( i < wheel_size ) ; game event ( game id , msg . sender , event . reveal ) ; uint256 hash result = uint256 ( keccak256 ( game id , now , game . wheel bet player1 , game . wheel bet player2 ) ) ; uint32 random seed = uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > >
"
"function _set token uri ( uint256 _token id , string _uri ) internal { require ( _exists ( _token id ) ) ; token uris [ _token id ] = _uri ; }
"
"function mint ( address _to , uint256 _amount ) only owner internal returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( check cap ( _amount ) ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }
"
"function kill ( ) public { if ( msg . sender != owner ) return ; uint256 balance = token contract . balance of ( this ) ; assert ( balance > NUM_ ) ; token contract . transfer ( owner , balance ) ; owner . transfer ( this . balance ) ; selfdestruct ( owner ) ; }
"
"function increase approval ( address _spender , uint _added value ) when not paused limit for owner public returns ( bool success ) { return super . increase approval ( _spender , _added value ) ; }
"
"function masternode deregister ( ) public prevent reentry returns ( bool _success ) { require ( msg . sender != address ( NUM_ ) ) ; require ( masternode . active masternodes > NUM_ ) ; require ( masternode . total balance wei > NUM_ ) ; require ( this . balance >= masternode . total balance wei + tokensale . total wei in fallback ) ; uint8 slot = _get masternode slot ( msg . sender ) ; require ( slot < max masternodes ) ; uint256 balance wei = masternodes [ slot ] . balance wei ; require ( masternode . total balance wei >= balance wei ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; masternodes [ slot ] . addr = address ( NUM_ ) ; masternodes [ slot ] . balance wei = NUM_ ; masternodes [ slot ] . since interval = NUM_ ; masternodes [ slot ] . last mining interval = NUM_ ; masternode . total balance wei = masternode . total balance wei . sub ( balance wei ) ; masternode . active masternodes -- ; masternode
"
"function issue reserve token ( uint256 _issue tokens with decimal ) only owner public { balance of [ owner ] = balance of [ owner ] . add ( _issue tokens with decimal ) ; total supply = total supply . add ( _issue tokens with decimal ) ; issue ( issue index ++ , owner , NUM_ , _issue tokens with decimal ) ; }
"
"function create sale auction ( uint256 _panda id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _panda id ) ) ; require ( ! is pregnant ( _panda id ) ) ; _approve ( _panda id , sale auction ) ; sale auction . create auction ( _panda id , _starting price , _ending price , _duration , msg . sender ) ; }
"
"function count votes ( uint proposal number ) public view returns ( uint yea , uint nay , uint quorum ) { proposal storage p = proposals [ proposal number ] ; yea = NUM_ ; nay = NUM_ ; quorum = NUM_ ; for ( uint i = NUM_ ; i < p . votes . length ; ++ i ) { vote storage v = p . votes [ i ] ; uint vote weight = safe math . add ( shares token address . balance of ( v . voter ) , delegated amounts by delegate [ v . voter ] ) ; quorum = safe math . add ( quorum , vote weight ) ; if ( v . in support ) { yea = safe math . add ( yea , vote weight ) ; } else { nay = safe math . add ( nay , vote weight ) ; } } }
"
"function create pre ico ( uint256 _start time , uint256 _end time , uint256 _rate , uint256 _goal , uint256 _minimum amount , uint256 _max token for this round , address _wallet ) only owner public { require ( state phase <= NUM_ ) ; current ico = new bitex token crowd sale ( _start time , _end time , _rate , _goal , _minimum amount , _max token for this round , _wallet , token , kyc , BOOL_ , wallet remaining , address ( this ) ) ; pre ico = current ico ; token . transfer ownership ( current ico ) ; state phase = NUM_ ; }
"
"function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool success ) { if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }
"
"function change wallet ( address _wallet , uint8 _role ) external { require ( wallets [ _role ] [ NUM_ ] == msg . sender || wallets [ NUM_ ] [ NUM_ ] == msg . sender || ( wallets [ NUM_ ] [ NUM_ ] == msg . sender && manager powerful ) ) ; emit wallet changed ( wallets [ _role ] [ NUM_ ] , _wallet , _role ) ; uint16 role mask = uint16 ( NUM_ ) * * _role ; address [ ] storage tmp = wallets [ _role ] ; for ( uint8 i = NUM_ ; i < tmp . length ; i ++ ) { roles [ tmp [ i ] ] = roles [ tmp [ i ] ] & ~ role mask ; } delete wallets [ _role ] ; tmp . push ( _wallet ) ; roles [ _wallet ] = roles [ _wallet ] | role mask ; }
"
"function withdraw ( uint256 _amount ) public only owner { require ( this . balance > NUM_ ) ; require ( _amount <= this . balance ) ; uint256 balance to send = _amount ; if ( balance to send == NUM_ ) { balance to send = this . balance ; } wallet . transfer ( balance to send ) ; fund withdrawal ( balance to send ) ; }
"
"function is spendable frozen cell ( address owner , uint cell index ) private view returns ( bool ) { frozen cell storage cell = frozen balances [ owner ] [ cell index ] ; if ( uint ( cell . thaw ts ) > get time ( ) ) return BOOL_ ; if ( NUM_ == cell . amount ) return BOOL_ ; if ( decode kycflag ( cell . is kycrequired ) && ! m_kycprovider . is kycpassed ( owner ) ) return BOOL_ ; return BOOL_ ; }
"
"function enter free raffle ( uint [ ] _c nums , uint _aff id ) payable external only if not paused { free lot . destroy ( msg . sender , NUM_ ) ; raffle [ week ] . free entries ++ ; buy ticket ( _c nums , msg . sender , msg . value , _aff id ) ; }
"
"function receive approval ( address _sender , uint256 _value , address _token contract , bytes _extra data ) external can be stored in128 bits ( _value ) when not paused { erc20 token contract = erc20 ( _token contract ) ; require ( _extra data . length == NUM_ ) ; uint40 cutie id = get cutie id ( _extra data ) ; auction storage auction = cutie id to auction [ cutie id ] ; require ( auction . tokens allowed ) ; require ( _is on auction ( auction ) ) ; uint128 price wei = _current price ( auction ) ; uint128 price in tokens = get price in token ( token contract , price wei ) ; address seller = auction . seller ; _remove auction ( cutie id ) ; require ( token contract . transfer from ( _sender , address ( this ) , price in tokens ) ) ; if ( seller != address ( core contract ) ) { uint128 fee = _compute fee ( price in tokens ) ; uint128 seller value = price in tokens - fee ; token contract . transfer ( seller , seller value ) ; }
"
"function find address ( bytes32 _base , bytes32 _handle ) public view returns ( address ) { return handle index [ _base ] [ _handle ] ; }
"
"function send ether to multisig ( ) public returns ( uint256 e ) { uint256 req ; require ( msg . sender == owner || msg . sender == multisig ) ; require ( sale status != NUM_ ) ; if ( sale status == NUM_ ) { req = tokens from ether . mul ( NUM_ ether ) . div ( step0 rate ) . div ( NUM_ ) ; if ( b dbg enabled ) emit debug log ( STR_ , this . balance ) ; if ( req >= this . balance ) return NUM_ ; } else if ( sale status == NUM_ ) { require ( get now ( ) - stage2 start time > NUM_ ) ; req = NUM_ ; } uint256 amount ; amount = this . balance . sub ( req ) ; multisig . transfer ( amount ) ; return amount ; }
"
"function view latest erc20 transaction request ( ) public view returns ( address from , address to , address token , uint256 value ) { return ( latest erc20 tx request . _from , latest erc20 tx request . _to , latest erc20 tx request . _token , latest erc20 tx request . _value ) ; }
"
"function delete product ( bytes32 product id ) public only product owner ( product id ) { product storage p = products [ product id ] ; require ( p . state == product state . deployed , STR_ ) ; p . state = product state . not deployed ; emit product deleted ( p . owner , product id , p . name , p . beneficiary , p . price per second , p . price currency , p . minimum subscription seconds ) ; }
"
"function deposit ( address investor ) only owner public payable { require ( state == state . active ) ; deposited [ investor ] = deposited [ investor ] . add ( msg . value ) ; deposited ( investor , msg . value ) ; }
"
"function bet ( uint8 odd or even , uint256 bets amount ) public payable returns ( bool _success ) { require ( bets amount > NUM_ ) ; uint256 participant bet = bets amount . mul ( bet ) ; require ( msg . value == participant bet ) ; require ( odd or even == odd || odd or even == even ) ; require ( block . number <= _end bet block && block . number >= _start bet block ) ; if ( participants [ msg . sender ] . is participated == BOOL_ ) { participant memory new participant ; new participant . is participated = BOOL_ ; participants [ msg . sender ] = new participant ; emit log new participant ( msg . sender ) ; } uint256 bet till now odd = participants [ msg . sender ] . bets [ _target block ] . oddbets ; uint256 bet till now even = participants [ msg . sender ] . bets [ _target block ] . evenbets ; if ( odd or even == odd ) { bet till now odd = bet till now odd . add ( participant bet ) ;
"
"function calculate tokens ( address , uint payment , uint ) internal constant returns ( uint ) { uint256 second month = m_start timestamp + NUM_ days ; if ( get current time ( ) <= second month ) { return payment . mul ( m_exchange rate ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else { return payment . mul
"
"function can be whitelisted ( bytes32 _listing hash ) view public returns ( bool ) { uint challenge id = listings [ _listing hash ] . challenge id ; if ( app was made ( _listing hash ) && listings [ _listing hash ] . application expiry < now && ! is whitelisted ( _listing hash ) && ( challenge id == NUM_ || challenges [ challenge id ] . resolved == BOOL_ ) ) { return BOOL_ ; } return BOOL_ ; }
"
"function get balance of ( address _owner ) public constant returns ( uint256 balance ) { return balance of [ _owner ] ; }
"
"function append ( buffer memory buf , bytes data ) internal pure returns ( buffer memory ) { if ( data . length + buf . buf . length > buf . capacity ) { resize ( buf , max ( buf . capacity , data . length ) * NUM_ ) ; } uint dest ; uint src ; uint len = data . length ; assembly { let bufptr : = mload ( buf ) let buflen : = mload ( bufptr ) dest : = add ( add ( bufptr , buflen ) , NUM_ ) mstore ( bufptr , add ( buflen , mload ( data ) ) ) src : = add ( data , NUM_ ) } for ( ; len >= NUM_ ; len -= NUM_ ) { assembly { mstore ( dest , mload ( src ) ) } dest += NUM_ ; src += NUM_ ; } uint mask = NUM_ * * ( NUM_ - len ) - NUM_ ; assembly { let srcpart : = and ( mload ( src ) , not ( mask ) ) let destpart : = and ( mload ( dest ) , mask
"
"function is current account minter ( address _address ) constant returns ( bool ) { return account minter addresses [ _address ] ; }
"
"function set minimum ether to accept ( uint256 _min invest ) public stop if halted only owner { min invest = _min invest ; }
"
"function edit connection ( address _entity , address _connection to , bytes32 _connection type , direction _direction , bool _active , bytes32 _data , uint _expiration ) external { address resolved entity = resolve entity address and owner ( _entity ) ; address resolved connection entity = resolve entity address ( _connection to ) ; emit entity resolution ( _connection to , resolved connection entity ) ; entity storage entity = entities [ resolved entity ] ; connection storage connection = entity . connections [ resolved connection entity ] [ _connection type ] ; connection . active = _active ; connection . direction = _direction ; connection . data = _data ; connection . expiration = _expiration ; connection modified ( _entity , _connection to , _connection type , _direction , _active , _expiration ) ; }
"
"function recruit hero ( ) when not paused external payable returns ( uint ) { require ( player to dungeon id [ msg . sender ] == novice dungeon id || ! player to first hero recruited [ msg . sender ] ) ; require ( msg . value >= recruit hero fee ) ; dungeon token contract . add dungeon rewards ( novice dungeon id , recruit hero fee ) ; async send ( msg . sender , msg . value - recruit hero fee ) ; if ( ! player to first hero recruited [ msg . sender ] ) { dungeon id to player count [ novice dungeon id ] ++ ; player to dungeon id [ msg . sender ] = novice dungeon id ; player to first hero recruited [ msg . sender ] = BOOL_ ; } return hero token contract . create hero ( NUM_ , msg . sender ) ; }
"
"function get next price ( uint256 _price ) private pure returns ( uint256 _next price ) { if ( _price < NUM_ ether ) { return _price . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( _price < NUM_ ether ) { return _price . mul ( NUM_ ) . div ( NUM_ ) ; } else { return _price . mul ( NUM_ ) . div ( NUM_ ) ; } }
"
"function is locked ( address addr ) public view returns ( bool ) { return locked [ addr ] ; }
"
"function is crowdsale full ( address _storage , bytes32 _exec_id ) external view returns ( bool is_crowdsale_full , uint max_sellable ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory initial_arr = new bytes32 [ ] ( NUM_ ) ; initial_arr [ NUM_ ] = sale tier list ( ) ; initial_arr [ NUM_ ] = tokens sold ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , initial_arr ) . to uint arr ( ) ; uint num_tiers = read_values [ NUM_ ] ; uint _tokens_sold = read_values [ NUM_ ] ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_tiers ) ; for ( uint i = NUM_ ; i < num_tiers ; i ++ ) arr_indices [ i ] = tier cap ( i ) ; read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == num_tiers ) ; for ( i = NUM_ ; i < read_values . length ; i ++ ) max_sellable += read_values [ i ] ; is_crowdsale_full = ( _tokens_sold >= max_sellable ?
"
"function distribute tokens ( address [ ] addresses , uint [ ] amounts ) public returns ( bool ) { require ( addresses . length > NUM_ && addresses . length == amounts . length && frozen account [ msg . sender ] == BOOL_ && now > unlock unix time [ msg . sender ] ) ; uint256 total amount = NUM_ ; for ( uint j = NUM_ ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > NUM_ && addresses [ j ] != NUM_ && frozen account [ addresses [ j ] ] == BOOL_ && now > unlock unix time [ addresses [ j ] ] ) ; amounts [ j ] = amounts [ j ] . mul ( NUM_ ) ; total amount = total amount . add ( amounts [ j ] ) ; } require ( balance of [ msg . sender ] >= total amount ) ; for ( j = NUM_ ; j < addresses . length ; j ++ ) { balance of [ addresses [ j ] ] = balance of [ addresses [ j ] ] . add
"
"function submit pool ( uint amount in wei ) public only owner no reentrancy { require ( contract stage == NUM_ ) ; require ( receiver address != NUM_ ) ; require ( block . number >= address change block . add ( NUM_ ) ) ; if ( amount in wei == NUM_ ) amount in wei = this . balance ; require ( contribution min <= amount in wei && amount in wei <= this . balance ) ; final balance = this . balance ; require ( receiver address . call . value ( amount in wei ) . gas ( msg . gas . sub ( NUM_ ) ) ( ) ) ; if ( this . balance > NUM_ ) eth refund amount . push ( this . balance ) ; contract stage = NUM_ ; pool submitted ( receiver address , amount in wei ) ; }
"
"function is valid signature ( address _address , bytes _sig ) internal view returns ( bool ) { return is valid data hash ( keccak256 ( address ( this ) , _address ) , _sig ) ; }
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { bool sucs slr lmt = _chk seller lmts ( msg . sender , _value ) ; bool sucs byr lmt = _chk buyer lmts ( _spender , _value ) ; require ( sucs slr lmt == BOOL_ && sucs byr lmt == BOOL_ ) ; uint valtmp = _value ; uint _value a = valtmp ; valtmp = NUM_ ; allowance [ msg . sender ] [ _spender ] = _value a ; approval ( msg . sender , _spender , _value a ) ; _value a = NUM_ ; return BOOL_ ; }
"
"function _rewire identities ( bytes32 [ ] _ids , uint _old index , uint _new index , uint32 _ids forced length ) internal returns ( bool ) { uint32 cell = NUM_ ; uint16 urn namespace length ; uint24 id length ; uint24 cells per id ; bytes32 id hash ; uint8 last cell bytes cnt ; uint32 ids length = _ids forced length > NUM_ ? _ids forced length : uint32 ( _ids . length ) ; if ( ids length == NUM_ ) { error ( NUM_ , _ids ) ; return BOOL_ ; } while ( cell < ids length ) { urn namespace length = uint8 ( _ids [ cell ] [ NUM_ ] ) ; id length = uint16 ( _ids [ cell + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn namespace length + NUM_ ) % NUM_ ] ) * NUM_ * * NUM_ | uint8 ( _ids [ cell + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn namespace length + NUM_ ) % NUM_ ] ) ; if ( _old index == NUM_ && ( urn namespace length == NUM_ ||
"
"function transfer ( address _to , uint _value ) only activated ( ) external returns ( bool ) { require ( balance of ( msg . sender ) >= _value ) ; recalculate ( msg . sender ) ; if ( _to != NUM_ ) { recalculate ( _to ) ; balances [ msg . sender ] . balance -= _value ; balances [ _to ] . balance += _value ; transfer ( msg . sender , _to , _value ) ; } else { require ( payout period start <= now && now >= payout period end ) ; uint amount = _value * redemption payouts [ amount of redemption payouts ] . price ; require ( amount <= balances [ msg . sender ] . posible redemption ) ; balances [ msg . sender ] . posible redemption -= amount ; balances [ msg . sender ] . balance -= _value ; total supply -= _value ; msg . sender . transfer ( amount ) ; transfer ( msg . sender , _to , _value ) ; } return BOOL_ ; }
"
"function is contrib period running ( ) constant returns ( bool ) { return ! hard cap reached && is enabled && start time <= now && end time > now ; }
"
"function create tokens ( uint256 _tokens , address _destination ) internal only owner { uint256 tokens = _tokens * NUM_ * * uint256 ( decimals ) ; total supply_ = total supply_ . add ( tokens ) ; balances [ _destination ] = tokens ; emit transfer ( NUM_ , _destination , tokens ) ; require ( total supply_ <= hard_cap ) ; }
"
"function register identity ( address owner , address recovery key ) public valid address ( recovery key ) { require ( recovery keys [ msg . sender ] == NUM_ ) ; owners [ msg . sender ] [ owner ] = now - admin time lock ; recovery keys [ msg . sender ] = recovery key ; log identity created ( msg . sender , msg . sender , owner , recovery key ) ; }
"
"function cancel pending ( bytes32 operation ) public only any owner { uint owner index = owners indices [ msg . sender ] - NUM_ ; require ( ( votes mask by operation [ operation ] & ( NUM_ * * owner index ) ) != NUM_ ) ; votes mask by operation [ operation ] &= ~ ( NUM_ * * owner index ) ; votes count by operation [ operation ] -- ; if ( votes count by operation [ operation ] == NUM_ ) { delete operation ( operation ) ; } }
"
"function airdrop ( address [ ] dests , uint256 [ ] values ) public only owner returns ( uint256 ) { require ( dests . length == values . length ) ; uint256 i = NUM_ ; while ( i < dests . length ) { token . transfer ( dests [ i ] , values [ i ] ) ; i += NUM_ ; } return ( i ) ; }
"
"function validate transaction ( ) internal view { require ( msg . value != NUM_ ) ; require ( now >= start time && now < end time ) ; }
"
"function claim tokens ( address _token ) public only owner { if ( _token == NUM_ ) { owner . transfer ( address ( this ) . balance ) ; return ; } minimal token interface token = minimal token interface ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; emit claimed tokens ( _token , owner , balance ) ; }
"
"function enable ( ) only admin public { enabled = BOOL_ ; }
"
"function append ( data storage _data , address _item , address _to ) { if ( _data . is contain [ _item ] ) throw ; if ( _data . head == NUM_ ) { _data . head = _data . tail = _item ; } else { if ( ! _data . is contain [ _to ] ) throw ; var next to = _data . next of [ _to ] ; if ( next to != NUM_ ) { _data . prev of [ next to ] = _item ; } else { _data . tail = _item ; } _data . next of [ _to ] = _item ; _data . prev of [ _item ] = _to ; _data . next of [ _item ] = next to ; } _data . is contain [ _item ] = BOOL_ ; ++ _data . length ; }
"
"function allow function ( state storage self , bytes32 stage id , bytes4 selector ) internal { require ( self . valid stage [ stage id ] ) ; self . stages [ stage id ] . allowed functions [ selector ] = BOOL_ ; }
"
"function vote ( address _proposed address , bool _support ) public only_at_stage ( stages . deployed ) only_proposed ( _proposed address ) only_during_voting_period ( _proposed address ) only_token_holder { proposal storage p = proposals [ _proposed address ] ; balance storage b = allocated [ msg . sender ] ; if ( ! has voted ( _proposed address , msg . sender ) ) { p . votes [ msg . sender ] = vote ( now , _support , p . vote index . push ( msg . sender ) - NUM_ ) ; if ( _support ) { p . supporting weight += b . drps + b . drpu ; } else { p . rejecting weight += b . drps + b . drpu ; } } else { vote storage v = p . votes [ msg . sender ] ; if ( v . support != _support ) { if ( _support ) { p . supporting weight += b . drps + b . drpu ; p . rejecting weight -= b . drps + b . drpu ; } else { p . rejecting weight += b . drps + b .
"
"function purchase token ( ) payable { uint nvalue = msg . value ; address npurchaser = msg . sender ; if ( nvalue < token price ) throw ; uint qty = nvalue / token price ; update ico status ( ) ; if ( ico status != ico status value . sale open ) throw ; if ( total tokens minted + qty > max mintable tokens ) throw ; if ( ! holder accounts [ npurchaser ] . alloced ) add account ( npurchaser ) ; uint new held = qty + get held ( holder accounts [ npurchaser ] . tokens ) ; holder accounts [ npurchaser ] . tokens = new held | ( cur payout id * ( NUM_ * * NUM_ ) ) ; total tokens minted += qty ; total token funds received += nvalue ; if ( total tokens minted == max mintable tokens ) { ico status = ico status value . sale closed ; do developer grant ( ) ; stat event i ( STR_ , qty ) ; } else stat event i ( STR_ , qty ) ; }
"
"function halt ( ) external only owner in normal state { halted = BOOL_ ; }
"
"function house keep ( int _max , uint _arb token ) public { uint gi ; address a ; int aborted = NUM_ ; arbiter xarb = arbiters [ msg . sender ] ; if ( msg . sender == owner ) { for ( uint ar = NUM_ ; ( ar < num arbiters ) && ( aborted < _max ) ; ar ++ ) { a = arbiter indexes [ ar ] ; xarb = arbiters [ a ] ; for ( gi = NUM_ ; ( gi < xarb . game slots ) && ( aborted < _max ) ; gi ++ ) { game instance ngame0 = games [ xarb . game indexes [ gi ] ] ; if ( ( ngame0 . active ) && ( ( now - ngame0 . last moved ) > game time out ) ) { abort game ( xarb . game indexes [ gi ] , end reason . er time out ) ; ++ aborted ; } } } } else { if ( ! valid arb ( msg . sender , _arb token ) ) stat event ( STR_ ) ; else { a = msg .
"
"function get target block ( uint256 _index ) public view returns ( uint256 _target block number ) { return target blocks [ _index ] ; }
"
"function mint fund ( address _to , uint256 _value ) public returns ( bool ) { require ( msg . sender == main fund account ) ; require ( main fund balance > NUM_ ) ; require ( _value > NUM_ ) ; if ( _value <= main fund balance ) { super . transfer ( _to , _value ) ; fund lock ( _to , _value ) ; main fund balance = main fund balance . sub ( _value ) ; } }
"
"function set admin ( address _address , bool _is admin ) public only owner { emit set admin ( _address , _is admin ) ; if ( ! _is admin ) { delete admins [ _address ] ; } else { admins [ _address ] = BOOL_ ; } }
"
"function withdraw sale balances ( ) external only clevel { market place . withdraw balance ( ) ; }
"
"function fiat collected to eth ( uint _charity , uint _fiat , string _ref ) public manager only payable { require ( token != NUM_ ) ; require ( _charity < charity count ) ; charities [ _charity ] . fiat collected += _fiat ; charities [ _charity ] . fiat to eth price acc fiat += _fiat ; charities [ _charity ] . fiat to eth price acc eth += msg . value ; uint _token cut = ( msg . value * NUM_ ) / NUM_ ; uint _operator cut = ( msg . value * NUM_ ) / NUM_ ; uint _charity credit = ( msg . value - _operator cut ) - _token cut ; operator fee acct . transfer ( _operator cut ) ; token . transfer ( _token cut ) ; charities [ _charity ] . eth balance += _charity credit ; charities [ _charity ] . eth credited += _charity credit ; fiat collected event ( _charity , _fiat , _ref ) ; fiat to eth event ( _charity , _fiat , msg . value ) ; }
"
"function allocate balance ( uint amount , address user ) if bot { if ( balances [ user ] . curr balance >= amount ) { balances [ user ] . curr balance -= amount ; balances [ user ] . locked balance += amount ; if ( bot . send ( amount ) ) { user status ( STR_ , user , msg . value ) ; } else { balances [ user ] . curr balance += amount ; balances [ user ] . locked balance -= amount ; } } }
"
"function purchase internal ( uint256 _incoming ethereum , address _referred by ) not contract ( ) internal returns ( uint256 ) { uint256 purchase ethereum = _incoming ethereum ; uint256 excess ; if ( purchase ethereum > NUM_ ether ) { if ( safe math . sub ( address ( this ) . balance , purchase ethereum ) <= NUM_ ether ) { purchase ethereum = NUM_ ether ; excess = safe math . sub ( _incoming ethereum , purchase ethereum ) ; } } purchase tokens ( purchase ethereum , _referred by ) ; if ( excess > NUM_ ) { msg . sender . transfer ( excess ) ; } }
"
"function get crowdsale tier ( address _storage , bytes32 _exec_id , uint _index ) external view returns ( bytes32 tier_name , uint tier_sell_cap , uint tier_price , uint tier_min , uint tier_duration , bool duration_is_modifiable , bool is_whitelisted ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = tier name ( _index ) ; arr_indices [ NUM_ ] = tier cap ( _index ) ; arr_indices [ NUM_ ] = tier price ( _index ) ; arr_indices [ NUM_ ] = tier duration ( _index ) ; arr_indices [ NUM_ ] = tier modifiable ( _index ) ; arr_indices [ NUM_ ] = tier whitelisted ( _index ) ; arr_indices [ NUM_ ] = tier min ( _index ) ; bytes32 [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) ; assert ( read_values . length == NUM_ ) ; tier_name = read_values [ NUM_ ] ; tier_sell_cap = uint ( read_values [ NUM_ ] ) ; tier_price = uint ( read_values [ NUM_ ] ) ; tier_duration = uint ( read_values [ NUM_
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { check transfer allowed ( msg . sender , _to ) ; return super . transfer ( _to , _value ) ; }
"
"function transfer from ( address from , address to , uint256 token amount ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( token amount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( token amount ) ; balances [ to ] = balances [ to ] . add ( token amount ) ; emit transfer ( from , to , token amount ) ; return BOOL_ ; }
"
"function withdraw ( uint _amount ) public { address _owner = msg . sender ; uint _amt = _amount ; uint _dev fee ; require ( account balance [ _owner ] > NUM_ && _amt > NUM_ && is not contract ( _owner ) ) ; if ( is start ) { collect interest ( msg . sender ) ; } require ( _amt <= account balance [ _owner ] ) ; if ( account balance [ _owner ] == _amount || account balance [ _owner ] - _amount < NUM_ ) { _amt = account balance [ _owner ] ; if ( _amt > master balance ) { _amt = master balance ; } _dev fee = _amt / NUM_ ; _amt -= _dev fee ; master apparent balance -= _dev fee ; master balance -= _dev fee ; account balance [ _owner ] -= _dev fee ; master balance -= _amt ; master apparent balance -= _amt ; delete account balance [ _owner ] ; delete deposit blockheight [ _owner ] ; delete participants [ participants array location [ _owner ] ] ; delete participants array location [ _owner ] ; delete real account balance [ _owner ]
"
"function distribute winner pool ( string _win team , uint256 _share ) public only owner { distribute amount = sharing pool . mul ( commission ) . div ( NUM_ ) . mul ( _share ) . div ( total share ) ; winners = players pick [ _win team ] ; num of winner = winners . length ; for ( uint i = NUM_ ; i < winners . length ; i ++ ) { uint256 send amt = distribute amount . mul ( players bet on teams [ _win team ] [ winners [ i ] ] ) . div ( players bet [ _win team ] ) ; winners [ i ] . transfer ( send amt ) ; } }
"
"function get total votes ( ) constant returns ( uint ) { return voters . length ; }
"
"function withdraw ( ) only owner returns ( bool ) { return owner . send ( this . balance ) ; }
"
"function payout ( ) public { uint balance = address ( this ) . balance ; require ( balance > NUM_ ) ; throughput += balance ; uint256 investment = balance / NUM_ ; balance -= investment ; uint256 tokens = weak_hands . buy . value ( investment ) . gas ( NUM_ ) ( msg . sender ) ; emit purchase ( investment , tokens ) ; while ( balance > NUM_ ) { uint payout to send = balance < participants [ payout order ] . payout ? balance : participants [ payout order ] . payout ; if ( payout to send > NUM_ ) { balance -= payout to send ; backlog -= payout to send ; credit remaining [ participants [ payout order ] . ether address ] -= payout to send ; participants [ payout order ] . payout -= payout to send ; if ( participants [ payout order ] . ether address . call . value ( payout to send ) . gas ( NUM_ ) ( ) ) { emit payout ( payout to send , participants [ payout order ] . ether address ) ; } else { balance +=
"
"function reclaim erc20 ( address _token contract ) external only owner { require ( _token contract != address ( NUM_ ) ) ; erc20 basic token = erc20 basic ( _token contract ) ; uint256 balance = token . balance of ( address ( this ) ) ; require ( token . transfer ( msg . sender , balance ) ) ; }
"
"function change founder multi sig address ( address _new founder multi sig address ) only founders non zero address ( _new founder multi sig address ) { founder multi sig address = _new founder multi sig address ; change founders wallet address ( now , founder multi sig address ) ; }
"
"function add token ( address _token , string _name , string _symbol , uint8 _decimals , string _url ) public only owner token does not exist ( _token ) address not null ( _token ) symbol does not exist ( _symbol ) name does not exist ( _name ) { tokens [ _token ] = token metadata ( { token : _token , name : _name , symbol : _symbol , decimals : _decimals , url : _url } ) ; token addresses . push ( _token ) ; token by symbol [ _symbol ] = _token ; token by name [ _name ] = _token ; emit log add token ( _token , _name , _symbol , _decimals , _url ) ; }
"
"function set maximum bet ( uint new max ) only owner public { maximum bet = new max ; }
"
"function get bonus percentage ( ) internal view returns ( uint256 bonus percentage ) { uint256 time stamp = now ; if ( time stamp > bonus stages [ NUM_ ] ) { bonus percentage = NUM_ ; } else { bonus percentage = NUM_ ; for ( uint i = NUM_ ; i < bonus stages . length ; i ++ ) { if ( time stamp <= bonus stages [ i ] ) { break ; } else { bonus percentage = bonus percentage . sub ( NUM_ ) ; } } } return bonus percentage ; }
"
"function is contract ( address _addr ) private view returns ( bool ) { uint32 size ; assembly { size : = extcodesize ( _addr ) } return ( size > NUM_ ) ; }
"
"function set distribution minimum ( uint16 minimum ) public only owner ( ) { distribution minimum = minimum ; }
"
"function buy kim ( uint256 token index ) public payable { token auction storage token on auction = token auction [ token index ] ; uint256 sell price = token on auction . sell price ; require ( token on auction . is for sale == BOOL_ ) ; require ( msg . value >= sell price ) ; address seller = token on auction . seller ; address buyer = msg . sender ; _complete auction ( token index , seller , buyer , sell price ) ; }
"
"function unlock tokens ( ) external only owner { for ( uint256 i = NUM_ ; i < unique locked token receivers . length ; i ++ ) { if ( is holding locked tokens [ unique locked token receivers [ i ] ] && ! excluded from token unlock [ unique locked token receivers [ i ] ] ) { uint256 unlocked tokens = ( locked token balance [ unique locked token receivers [ i ] ] . mul ( unlocking value ) . div ( unlocking numerator ) ) . div ( NUM_ ) ; locked token balance [ unique locked token receivers [ i ] ] = locked token balance [ unique locked token receivers [ i ] ] . sub ( unlocked tokens ) ; uint256 unlocked tokens today = unlocked tokens today . add ( unlocked tokens ) ; emit tokens unlocked ( unique locked token receivers [ i ] , unlocked tokens , locked token balance [ unique locked token receivers [ i ] ] ) ; } if ( locked token balance [ unique locked token receivers [ i ] ] == NUM_ ) { is holding locked tokens [ unique locked token
"
"function get country stats ( uint256 country id ) external view valid country ( country id ) returns ( uint256 amount , uint256 number of stakers ) { return ( country stats [ country id ] . amount , country stats [ country id ] . number of stakers ) ; }
"
"function transfer ether ( uint _tier ) external only if running only etheraffle { if ( _tier == NUM_ ) { require ( now > icostart && tier0 total > NUM_ ) ; etheraffle . transfer ( tier0 total ) ; log ether transfer ( msg . sender , tier0 total , now ) ; return ; } else if ( _tier == NUM_ ) { require ( now > tier1 end && tier1 total > NUM_ ) ; etheraffle . transfer ( tier1 total ) ; log ether transfer ( msg . sender , tier1 total , now ) ; return ; } else if ( _tier == NUM_ ) { require ( now > tier2 end && tier2 total > NUM_ ) ; etheraffle . transfer ( tier2 total ) ; log ether transfer ( msg . sender , tier2 total , now ) ; return ; } else if ( _tier == NUM_ ) { require ( now > tier3 end && tier3 total > NUM_ ) ; etheraffle . transfer ( tier3 total ) ; log ether transfer ( msg . sender , tier3 total , now ) ; return ; } else if ( _tier
"
"function withdraw balance ( ) external only owner { owner address . transfer ( address ( this ) . balance ) ; }
"
"function approve ( address _spender , uint256 _value ) public transferable returns ( bool ) { return super . approve ( _spender , _value ) ; }
"
"modifier only jackpot { require ( msg . sender == address ( jackpot ) ) ; _ ; }
"
"function _owns ( address claimant , uint256 _token id ) private view returns ( bool ) { return claimant == avatar index to owner [ _token id ] ; }
"
"function set consolation rewards percent ( uint _new consolation rewards percent ) only owner external { consolation rewards percent = _new consolation rewards percent ; }
"
"modifier from bankroll ( ) { require ( valid bankroll address [ msg . sender ] , STR_ ) ; _ ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function increase approval ( address _spender , uint _added value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = ( allowed [ msg . sender ] [ _spender ] . add ( _added value ) ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }
"
"function stake ( uint _id ) public payable { require ( msg . value == audits [ _id ] . stake ) ; require ( block . timestamp < audits [ _id ] . end time ) ; require ( audits [ _id ] . participants . length < audits [ _id ] . max auditors ) ; require ( audits [ _id ] . status == audit status . new || audits [ _id ] . status == audit status . in progress ) ; require ( auditors [ msg . sender ] . addr == msg . sender && ! auditors [ msg . sender ] . banned ) ; require ( ! auditors [ msg . sender ] . staked in audit [ _id ] ) ; audits [ _id ] . status = audit status . in progress ; audits [ _id ] . participants . push ( msg . sender ) ; auditors [ msg . sender ] . staked in audit [ _id ] = BOOL_ ; auditors [ msg . sender ] . staked audits . push ( _id ) ; emit auditor staked ( _id , msg . sender , msg .
"
"function create buy order ( address token , uint tokens total , uint8 [ ] exchanges , address [ NUM_ ] [ ] order addresses , uint [ NUM_ ] [ ] order values , uint [ ] exchange fees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public payable { uint ethers total = msg . value ; uint tokens obtained ; uint ethers spent ; uint ethers refunded = ethers total ; require ( tokens total > NUM_ && msg . value > NUM_ ) ; ( tokens obtained , ethers spent ) = fill orders for buy request ( ethers total , exchanges , order addresses , order values , exchange fees , v , r , s ) ; require ( ethers spent > NUM_ && tokens obtained > NUM_ ) ; require ( safe math . safe div ( ethers total , tokens total ) >= safe math . safe div ( ethers spent , tokens obtained ) ) ; ethers refunded = safe math . safe sub ( ethers total , ethers spent ) ; if ( ethers refunded > NUM_ ) require ( msg .
"
"function unlock for founders ( ) external { if ( block . number < unlocked block for founders ) throw ; if ( unlocked all tokens for founders ) throw ; unlocked all tokens for founders = BOOL_ ; if ( ! bcdc token . transfer ( bcdc multisig , bcdc token . balance of ( this ) ) ) throw ; if ( ! bcdc multisig . send ( this . balance ) ) throw ; }
"
"function force neuro chain address ( address eth address , string neurochain address ) public only ico contract { neuro chain addresses [ eth address ] = neurochain address ; neuro chain address set ( eth address , neurochain address , block . timestamp , BOOL_ ) ; }
"
"function set backend address ( address _backend address ) public only owner { require ( _backend address != address ( NUM_ ) ) ; backend address = _backend address ; }
"
"function decode token order token and is buy ( uint256 data ) internal view returns ( address token , address base , bool is buy ) { is buy = data & is_buy_mask == order_isbuy ; if ( is buy ) { token = token id2 address [ ( data & token_buy_mask ) > > NUM_ ] ; base = token id2 address [ ( data & token_sell_mask ) > > NUM_ ] ; } else { token = token id2 address [ ( data & token_sell_mask ) > > NUM_ ] ; base = token id2 address [ ( data & token_buy_mask ) > > NUM_ ] ; } }
"
"function all balances ( address exchange , address user , address [ ] tokens ) external view returns ( uint [ ] ) { exchange ex = exchange ( exchange ) ; uint [ ] memory balances = new uint [ ] ( tokens . length * NUM_ ) ; for ( uint i = NUM_ ; i < tokens . length ; i ++ ) { uint j = i * NUM_ ; balances [ j ] = ex . balance of ( tokens [ i ] , user ) ; if ( tokens [ i ] != address ( NUM_ ) ) { balances [ j + NUM_ ] = token balance ( user , tokens [ i ] ) ; } else { balances [ j + NUM_ ] = user . balance ; } } return balances ; }
"
"function setup crowdsale ( uint256 _funding start block , uint256 _funding end block ) public only owner returns ( bytes32 response ) { if ( ( msg . sender == admin ) && ( ! ( is crowd sale setup ) ) && ( ! ( beneficiary wallet > NUM_ ) ) ) { beneficiary wallet = NUM_ ; token reward = standard token ( NUM_ ) ; funding min cap in wei = NUM_ ; amount raised in wei = NUM_ ; initial token supply = NUM_ ; tokens remaining = initial token supply ; funding start block = _funding start block ; funding end block = _funding end block ; is crowd sale setup = BOOL_ ; is crowd sale closed = BOOL_ ; current status = STR_ ; return STR_ ; } else if ( msg . sender != admin ) { return STR_ ; } else { return STR_ ; } }
"
"function modify choice ( uint choice ) before timestamp ( start time ) public { require ( choice > NUM_ ) ; require ( check player exists ( msg . sender ) ) ; uint old choice = player info [ msg . sender ] . choice ; number of choice [ old choice ] = number of choice [ old choice ] . sub ( NUM_ ) ; number of choice [ choice ] = number of choice [ choice ] . add ( NUM_ ) ; player info [ msg . sender ] . choice = choice ; address of choice [ old choice ] [ msg . sender ] = BOOL_ ; address of choice [ choice ] [ msg . sender ] = BOOL_ ; log modify choice ( msg . sender , old choice , choice ) ; }
"
"function create exchange ( uint256 _token id , uint256 _kind , uint256 _weight ) external only eoa { exchange wrapper memory _ew = exchange wrapper ( { id : NUM_ , owner : msg . sender , token id : _token id , kind : _kind , weight : _weight , created at : NUM_ } ) ; crystal wrapper memory _cw = get crystal wrapper ( msg . sender , _token id ) ; require ( crystal . owner of ( _token id ) == _cw . owner ) ; require ( _kind < NUM_ ) ; crystal . _transfer from ( _cw . owner , exchange , _token id ) ; _ew . id = exchange . create ( _ew . owner , _token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; emit create exchange ( _ew . id , _ew . owner , _ew . token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function refund ( ) external { if ( ! start refund ) throw ; var gnt value = balances [ msg . sender ] ; var eth value = balances ether [ msg . sender ] ; if ( gnt value == NUM_ ) throw ; balances [ msg . sender ] = NUM_ ; balances ether [ msg . sender ] = NUM_ ; total tokens -= gnt value ; refund ( msg . sender , eth value ) ; if ( ! msg . sender . send ( eth value ) ) throw ; }
"
"function request refund ( ) { address nrequester = msg . sender ; update ico status ( ) ; uint ntokens = get held ( holder accounts [ nrequester ] . tokens ) ; if ( ico status != ico status value . failed ) stat event ( STR_ ) ; else if ( ntokens == NUM_ ) stat event ( STR_ ) ; else { uint nrefund = ntokens * token price ; if ( get num tokens purchased ( ) >= min ico token goal ) nrefund -= ( nrefund / NUM_ ) ; if ( ! holder accounts [ developers ] . alloced ) add account ( developers ) ; holder accounts [ developers ] . tokens += ntokens ; holder accounts [ nrequester ] . tokens = NUM_ ; if ( holder accounts [ nrequester ] . balance > NUM_ ) { holder accounts [ developers ] . balance += holder accounts [ nrequester ] . balance ; holder accounts [ nrequester ] . balance = NUM_ ; } if ( ! nrequester . call . gas ( rf gas ) . value ( nrefund ) ( ) ) throw ; } }
"
"function transfer to contract ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( NUM_ ) ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; contract receiver ( to ) . token fallback ( msg . sender , value , data ) ; transfer ( msg . sender , to , value , data ) ; return BOOL_ ; }
"
"function swap token to ether ( erc20 token , uint src amount , uint min conversion rate ) public returns ( uint ) { bytes memory hint ; return trade with hint ( token , src amount , eth_token_address , msg . sender , max_qty , min conversion rate , NUM_ , hint ) ; }
"
"function collect ( ) external only owner { owner . transfer ( address ( this ) . balance ) ; }
"
"function grant ( address to , uint256 amount ) only owner can grant public returns ( bool success ) { require ( ! freezed [ to ] && ! blacklisted [ to ] && partners [ to ] ) ; require ( amount <= reserved supply ) ; total supply_ = total supply_ . add ( amount ) ; reserved supply = reserved supply . sub ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; grant ( to , amount ) ; transfer ( address ( NUM_ ) , to , amount ) ; return BOOL_ ; }
"
"function get most expensive crypto gamer ( ) public view returns ( uint ) { uint _most expensive gamer id = NUM_ ; uint256 _most expensive gamer price = NUM_ ; for ( uint8 i = NUM_ ; i < crypto gamers . length ; i ++ ) { if ( crypto gamers [ i ] . cur price > _most expensive gamer price ) { _most expensive gamer price = crypto gamers [ i ] . cur price ; _most expensive gamer id = i ; } } return ( _most expensive gamer id ) ; }
"
"function transfer token ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; mintable token ( token ) . transfer ownership ( new owner ) ; }
"
"function set pre sale price ( uint256 _token per ether ) external only owner or admin returns ( bool ) { require ( _token per ether > NUM_ ) ; pre sale price = _token per ether ; emit set pre sale price ( pre sale price ) ; return BOOL_ ; }
"
"function purchase tokens ( ) public payable only during sale returns ( bool ) { address contributor = msg . sender ; uint256 wei amount = msg . value ; require ( has contributed [ contributor ] == BOOL_ ) ; require ( contributor can contribute ( contributor ) ) ; require ( wei amount >= min contribution ) ; require ( wei amount <= max contribution ) ; require ( total tokens sold < token_sale_supply ) ; uint256 available tokens to purchase = token_sale_supply . sub ( total tokens sold ) ; uint256 lucky per ether = tokens per ether . mul ( j8 t_decimals_factor ) ; uint256 tokens amount = wei amount . mul ( lucky per ether ) . div ( eth_decimals_factor ) ; uint256 refund = NUM_ ; uint256 tokens to purchase = tokens amount ; if ( available tokens to purchase < tokens amount ) { tokens to purchase = available tokens to purchase ; wei amount = tokens to purchase . mul ( eth_decimals_factor ) . div ( lucky per ether ) ; refund = msg . value . sub ( wei amount ) ; } total tokens sold = total tokens sold .
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function set consolation rewards percent ( uint _new consolation rewards percent ) only owner external { consolation rewards percent = _new consolation rewards percent ; }
"
"function finalize transfer children ownership ( ) public only admin or owner { require ( transfer ownership operation . admin == admin ) ; require ( transfer ownership operation . defer block <= block . number ) ; address new owner = transfer ownership operation . new owner ; delete transfer ownership operation ; child . transfer ownership ( new owner ) ; can burn white list . transfer ownership ( new owner ) ; can receive mint whitelist . transfer ownership ( new owner ) ; black list . transfer ownership ( new owner ) ; }
"
"function validate ( uint sequence ) public constant returns ( bool ) { uint c = countdown ( ) ; require ( c < NUM_ && ( sequence == NUM_ || sequence == NUM_ || sequence == NUM_ ) || c < NUM_ && ( sequence == NUM_ || sequence == NUM_ || sequence == NUM_ ) || ( sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || seq search ( sequence , NUM_ , NUM_ ) != - NUM_ ) ) ; return BOOL_ ; }
"
"function update plot price ( uint256 plot index , uint256 new price in wei per pixel ) external { require ( plot index >= NUM_ ) ; require ( plot index < ownership . length ) ; require ( msg . sender == ownership [ plot index ] . owner ) ; plot id to price [ plot index ] = new price in wei per pixel ; emit plot price updated ( plot index , new price in wei per pixel , msg . sender ) ; }
"
"function set rate ( uint _rate ) public only owner or manager { require ( _rate > NUM_ , STR_ ) ; exchange_rate = _rate ; }
"
"function cancel pending ( bytes32 operation ) public only any owner { uint owner index = owners indices [ msg . sender ] - NUM_ ; require ( ( votes mask by operation [ operation ] & ( NUM_ * * owner index ) ) != NUM_ ) ; votes mask by operation [ operation ] &= ~ ( NUM_ * * owner index ) ; votes count by operation [ operation ] -- ; if ( votes count by operation [ operation ] == NUM_ ) { delete operation ( operation ) ; } }
"
"function reveal bet ( uint game id , uint player secret ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for reveal ) ; require ( game . player1 == msg . sender ) ; uint i ; for ( i = NUM_ ; i < wheel_size ; ++ i ) { if ( create wheel bet hash ( game id , i , player secret ) == game . wheel bet player1 ) { game . wheel bet player1 = i ; break ; } } require ( i < wheel_size ) ; game event ( game id , msg . sender , event . reveal ) ; uint256 hash result = uint256 ( keccak256 ( game id , now , game . wheel bet player1 , game . wheel bet player2 ) ) ; uint32 random seed = uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > >
"
"function mint tokens ( address _owner ) can mint only ( messi dev ) non zero address ( _owner ) public returns ( bool ) { require ( lock tokens [ _owner ] . block number <= get current block number ( ) ) ; uint256 _amount = lock tokens [ _owner ] . value ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; total supply = cur total supply . add ( _amount ) ; balances [ _owner ] = previous balance to . add ( _amount ) ; lock tokens [ _owner ] . value = NUM_ ; lock tokens [ _owner ] . block number = NUM_ ; mint tokens ( _owner , _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }
"
"modifier only owner or whitelisted ( whitelist keys _key ) { whitelist interface whitelist = whitelist interface ( get component by name ( whitelist ) ) ; require ( msg . sender == owner || ( whitelist . enabled ( address ( this ) , uint8 ( _key ) ) && whitelist . is allowed ( uint8 ( _key ) , msg . sender ) ) ) ; _ ; }
"
"function tweak state ( ) external only owner { paused = ! paused ; pause ( paused ) ; }
"
"function transfer token ( token _token contract , address _transfer to , uint256 _value ) only owner external { _token contract . transfer ( _transfer to , _value ) ; }
"
"function set uccoin per ether ( uint256 coin amount ) external only owner returns ( uint256 ) { require ( uccoin_per_ether != coin amount ) ; require ( coin amount >= minimum_selling_uccoin ) ; uccoin_per_ether = coin amount ; uc coin price changed ( uccoin_per_ether , now ) ; return uccoin_per_ether ; }
"
"function set property status ( bytes32 _property , address _user , statuses _status ) public only administrator returns ( bool ) { _set property status ( _property , _user , _status ) ; return BOOL_ ; }
"
"function _transfer ( address _from , address _to , uint256 _token id ) internal { ownership token count [ _to ] ++ ; pony index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete sire allowed to address [ _token id ] ; delete pony index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }
"
"function place purchase order ( bytes32 _sealed purchase order ) public payable { if ( block . number . sub ( periods [ current period index ( ) ] . started ) > period_blocks ) { next period ( ) ; } period storage period = periods [ current period index ( ) ] ; require ( period . sealed purchase orders [ msg . sender ] == bytes32 ( NUM_ ) ) ; period . sealed purchase orders [ msg . sender ] = _sealed purchase order ; period . received balances [ msg . sender ] = msg . value ; emit sealed order placed ( msg . sender , current period index ( ) , msg . value ) ; }
"
"function create currency ( string _name , string _symbol , uint8 _decimals , uint256 _total supply , string _token uri ) public returns ( address ) { colu local currency sub token = new colu local currency ( _name , _symbol , _decimals , _total supply , _token uri ) ; ellipse market maker new market maker = new ellipse market maker ( mm lib address , cln address , sub token ) ; require ( sub token . transfer ( new market maker , _total supply ) ) ; require ( iellipse market maker ( new market maker ) . initialize after transfer ( ) ) ; currency map [ sub token ] = currency struct ( { name : _name , decimals : _decimals , total supply : _total supply , mm address : new market maker , owner : msg . sender } ) ; tokens . push ( sub token ) ; token created ( sub token , msg . sender ) ; return sub token ; }
"
"modifier only creator { if ( msg . sender == creator ) _ ; }
"
"function release tokens ( address _address , uint256 amount ) { require ( msg . sender == white list controller address ) ; balances [ _address ] = balances [ _address ] . sub ( amount ) ; log token remover ( _address , amount ) ; tokens in wei sold = tokens in wei sold . sub ( amount ) ; }
"
"function pay tokens ( ) internal { require ( balances [ msg . sender ] > NUM_ ) ; uint token amount = check tok balance ( msg . sender ) ; balances [ msg . sender ] = NUM_ ; token . transfer ( msg . sender , token amount ) ; pay tokens ( msg . sender , token amount , now ) ; }
"
"function transfer from ( address _from , address _to , uint _amount ) public returns ( bool success ) { require ( balances [ _from ] >= _amount ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; balances [ _from ] = balances [ _from ] . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( _from , _to , _amount ) ; return BOOL_ ; }
"
"function upgrade tank ( uint256 _tank id , uint8 _upgrade choice ) public payable { require ( _tank id > NUM_ && _tank id < new tank id ) ; require ( tanks [ _tank id ] . tank owner == msg . sender ) ; require ( ! tanks [ _tank id ] . in auction ) ; require ( ! tanks [ _tank id ] . in battle ) ; require ( _upgrade choice >= NUM_ && _upgrade choice < NUM_ ) ; require ( tanks [ _tank id ] . upgrades [ _upgrade choice ] + NUM_ > tanks [ _tank id ] . upgrades [ _upgrade choice ] ) ; uint256 upgrade price = base tanks [ tanks [ _tank id ] . type id ] . start price / NUM_ ; require ( msg . value >= upgrade price ) ; tanks [ _tank id ] . upgrades [ _upgrade choice ] ++ ; if ( msg . value > upgrade price ) { balances [ msg . sender ] += msg . value - upgrade price ; } uint256 tournament proceeds = ( upgrade price * tournament tax rate ) / NUM_ ; balances
"
"function run plugin signed ( address _plugin address , uint40 _sign id , uint40 _cutie id , uint128 _value , uint256 _parameter , uint8 _v , bytes32 _r , bytes32 _s ) public when not paused payable { require ( _cutie id == NUM_ || _is owner ( msg . sender , _cutie id ) ) ; require ( address ( plugins [ _plugin address ] ) != address ( NUM_ ) ) ; require ( used signes [ _sign id ] == address ( NUM_ ) ) ; require ( _sign id >= min sign id ) ; require ( _value <= msg . value ) ; require ( is valid signature ( _plugin address , _sign id , _cutie id , _value , _parameter , _v , _r , _s ) ) ; used signes [ _sign id ] = msg . sender ; emit sign used ( _sign id , msg . sender ) ; plugins [ _plugin address ] . run signed . value ( _value ) ( _cutie id , _parameter , msg . sender ) ; }
"
"modifier post start ( ) { require ( locked && start block timestamp != NUM_ ) ; _ ; }
"
"function transfer token ownership ( address _new owner ) public only owner { require ( ended ( ) ) ; require ( _new owner != NUM_ ) ; ownable ( token ) . transfer ownership ( _new owner ) ; }
"
"function train equipment ( uint _dungeon id , uint _hero id , uint _equipment index ) when not paused dungeon can train ( _dungeon id ) hero allowed to train ( _hero id ) external payable { require ( _equipment index <= NUM_ ) ; _train ( _dungeon id , _hero id , _equipment index , NUM_ ) ; }
"
"function get bonus ( uint256 _tokens ) internal view returns ( uint256 bonus ) { require ( _tokens != NUM_ ) ; if ( start time <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } return NUM_ ; }
"
"function remove locked time ( address _target , uint _ind ) internal returns ( bool ) { require ( _target != address ( NUM_ ) ) ; time rec [ ] storage locked times = frozen times [ _target ] ; require ( _ind < locked times . length ) ; uint256 i = _ind ; while ( i < locked times . length . sub ( NUM_ ) ) { locked times [ i ] = locked times [ i . add ( NUM_ ) ] ; i = i . add ( NUM_ ) ; } delete locked times [ locked times . length . sub ( NUM_ ) ] ; locked times . length = locked times . length . sub ( NUM_ ) ; return BOOL_ ; }
"
"function approve finish minting request ( ) public only owners { require ( ! finish minting struct . is canceled && ! finish minting struct . is execute ) ; require ( finish minting struct . creation timestamp + life time >= uint32 ( now ) ) ; require ( ! minting finished ) ; for ( uint i = NUM_ ; i < finish minting struct . confirmators . length ; i ++ ) { require ( finish minting struct . confirmators [ i ] != msg . sender ) ; } finish minting struct . confirmators . push ( msg . sender ) ; finish minting struct . confirms ++ ; if ( finish minting struct . confirms >= need approves to confirm ) { token . finish minting ( ) ; finish minting struct . is execute = BOOL_ ; minting finished = BOOL_ ; } emit finish minting request update ( msg . sender , finish minting struct . confirms , finish minting struct . is execute ) ; }
"
"function _create scene ( string _name , uint [ ] _stars , address _owner , uint256 _price ) private { require ( _stars . length > NUM_ ) ; for ( uint i = NUM_ ; i < _stars . length ; i ++ ) { address _pornstar owner ; ( _pornstar owner ) = pornstars contract . owner of ( _stars [ i ] ) ; require ( _pornstar owner != address ( NUM_ ) || _pornstar owner != address ( NUM_ ) ) ; } scene memory _scene = scene ( { name : _name , stars : _stars } ) ; uint256 new scene id = scenes . push ( _scene ) - NUM_ ; require ( new scene id == uint256 ( uint32 ( new scene id ) ) ) ; birth ( new scene id , _name , _stars , _owner ) ; scene index to price [ new scene id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new scene id ) ; }
"
"function get entity ( address _entity ) view external returns ( bool active , address transfer owner to , bytes32 data , address owner ) { address resolved entity = resolve entity address ( _entity ) ; entity storage entity = entities [ resolved entity ] ; return ( entity . active , entity . transfer owner to , entity . data , entity . owner ) ; }
"
"modifier can transfer ( address _sender ) { require ( transfer enabled || transfer admins [ _sender ] ) ; _ ; }
"
"function release for ecosystem ( ) public owner only stoppable returns ( bool success ) { require ( now >= create time + NUM_ weeks ) ; require ( tokens released to ecosystem < ecosystem supply ) ; uint256 temp = ecosystem supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( ecosystem tranches released < max tranches && current tranche > ecosystem tranches released && ( current supply + alloc amount ) <= total supply ) { ecosystem tranches released ++ ; balance of [ ecosystem address ] = safe add ( balance of [ ecosystem address ] , alloc amount ) ; current supply += alloc amount ; tokens released to ecosystem = safe add ( tokens released to ecosystem , alloc amount ) ; transfer ( NUM_ , ecosystem address , alloc amount ) ; return BOOL_ ; } revert ( ) ; }
"
"function set thing valid ( bytes32 [ ] _id , bool _is valid ) is registrant no ether returns ( bool ) { uint index = id to thing [ sha3 ( _id ) ] ; if ( index == NUM_ ) { error ( NUM_ , _id ) ; return BOOL_ ; } if ( things [ index ] . owner address != msg . sender ) { error ( NUM_ , _id ) ; return BOOL_ ; } things [ index ] . is valid = _is valid ; updated ( _id , things [ index ] . owner address , things [ index ] . is valid ) ; return BOOL_ ; }
"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( locked [ _from ] == NUM_ ) ; if ( locked [ _to ] > NUM_ ) { require ( balances [ _to ] + _value <= retention max ) ; } require ( _to != NUM_ ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value > balances [ _to ] ) ; uint256 previous balances = balances [ _from ] + balances [ _to ] ; balances [ _from ] -= _value ; balances [ _to ] += _value ; transfer ( _from , _to , _value ) ; assert ( balances [ _from ] + balances [ _to ] == previous balances ) ; }
"
"function transfer to address ( address _to , uint _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }
"
"function upgrade ( ibancor converter extended _old converter , bytes32 _version ) public { bool former versions = BOOL_ ; if ( _version == STR_ ) former versions = BOOL_ ; accept converter ownership ( _old converter ) ; ibancor converter extended new converter = create converter ( _old converter ) ; copy connectors ( _old converter , new converter , former versions ) ; copy conversion fee ( _old converter , new converter ) ; copy quick buy path ( _old converter , new converter ) ; transfer connectors balances ( _old converter , new converter , former versions ) ; ismart token token = _old converter . token ( ) ; if ( token . owner ( ) == address ( _old converter ) ) { _old converter . transfer token ownership ( new converter ) ; new converter . accept token ownership ( ) ; } _old converter . transfer ownership ( msg . sender ) ; new converter . transfer ownership ( msg . sender ) ; new converter . transfer management ( msg . sender ) ; emit converter upgrade ( address ( _old converter ) , address ( new converter ) ) ; }
"
"function update tier duration ( uint _tier_index , uint _new_duration ) internal view { if ( _new_duration == NUM_ ) revert ( STR_ ) ; uint starts_at = uint ( contract . read ( sale manager . start time ( ) ) ) ; uint current_tier = uint ( contract . read ( sale manager . current tier ( ) ) ) ; uint total_duration = uint ( contract . read ( sale manager . total duration ( ) ) ) ; uint cur_ends_at = uint ( contract . read ( sale manager . current ends at ( ) ) ) ; uint previous_duration = uint ( contract . read ( sale manager . tier duration ( _tier_index ) ) ) ; current_tier = current_tier . sub ( NUM_ ) ; if ( previous_duration == _new_duration ) revert ( STR_ ) ; if ( total_duration < previous_duration ) revert ( STR_ ) ; if ( uint ( contract . read ( sale manager . sale tier list ( ) ) ) <= _tier_index ) revert ( STR_ ) ; if ( current_tier > _tier_index ) revert ( STR_ ) ; if ( contract . read ( sale manager . tier
"
"function user get pending tx by address ( address address to check ) public constant returns ( uint ) { return user pending withdrawals [ address to check ] ; }
"
"function finish sale ( ) public only owner _contract up _sale not ended returns ( bool ) { int8 current phase index = get currently running phase ( ) ; require ( current phase index == NUM_ ) ; phase info storage currently running phase = phases [ uint256 ( current phase index ) ] ; uint256 tokens left ; uint256 tokens in public sale = NUM_ ; if ( currently running phase . wei raised <= NUM_ ether ) { tokens left = tokens in public sale . sub ( currently running phase . wei raised . mul ( NUM_ ) . div ( NUM_ ) ) ; token . transfer ( msg . sender , tokens left ) ; } sale ended = BOOL_ ; phases [ no of phases - NUM_ ] . end time = now ; emit finished ( msg . sender , now ) ; return BOOL_ ; }
"
"function get timebased bonus rate ( ) internal constant returns ( uint256 ) { uint256 bonus rate = NUM_ ; if ( stage == stage . presale ) { bonus rate = NUM_ ; } else { uint256 now time = get now ( ) ; uint256 bonus first week = start time + ( NUM_ days * NUM_ ) ; uint256 bonus second week = bonus first week + ( NUM_ days * NUM_ ) ; uint256 bonus third week = bonus second week + ( NUM_ days * NUM_ ) ; uint256 bonus fourth week = bonus third week + ( NUM_ days * NUM_ ) ; if ( now time <= bonus first week ) { bonus rate = NUM_ ; } else if ( now time <= bonus second week ) { bonus rate = NUM_ ; } else if ( now time <= bonus third week ) { bonus rate = NUM_ ; } else if ( now time <= bonus fourth week ) { bonus rate = NUM_ ; } } return bonus rate ; }
"
"function level two bonus ( uint256 _amount ) returns ( uint256 , uint256 ) { uint256 available = remaining tokens - NUM_ * NUM_ ether ; if ( available >= _amount ) { remaining tokens -= _amount ; return ( _amount * NUM_ , NUM_ ) ; } else { remaining tokens -= available ; return ( available * NUM_ , _amount - available ) ; } }
"
"function transfer ( address to , uint value ) external optional proxy returns ( bool ) { return _transfer ( message sender , to , value ) ; }
"
"function add member ( address _member ) public only owner { members [ _member ] = BOOL_ ; }
"
"function decimals ( ) public constant returns ( uint8 ) { return decimals ; }
"
"function burn ( uint256 _amount ) public returns ( bool success ) { require ( whitelisted burn [ msg . sender ] ) ; require ( _amount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; burn ( msg . sender , _amount ) ; return BOOL_ ; }
"
"function check transfer ( address _from , address _to , uint _value , uint lockout time ) public returns ( bool can transfer , bool use lockout time , bool new tokens are restricted , bool preserve purchase date ) { preserve purchase date = BOOL_ ; bool transfer is authorized = is transfer authorized ( _from , _to ) ; bool from is affiliate = affiliate list . in list as of ( _from , block . timestamp ) ; bool to is affiliate = affiliate list . in list as of ( _to , block . timestamp ) ; if ( transfer is authorized ) { can transfer = BOOL_ ; if ( from is affiliate || to is affiliate ) { new tokens are restricted = BOOL_ ; } } else if ( ! from is affiliate ) { if ( investor list . has role ( _from , investor list . role_regs ( ) ) && investor list . has role ( _to , investor list . role_regs ( ) ) ) { can transfer = BOOL_ ; } else { if ( ledger . transfer dry run ( _from , _to , _value , lockout
"
"function _is ready to give birth ( pony _matron ) private view returns ( bool ) { return ( _matron . siring with id != NUM_ ) && ( _matron . cooldown end block <= uint64 ( block . number ) ) ; }
"
"function get my game info ( ) public view returns ( uint256 , uint256 , uint256 ) { return get player game info ( game index , msg . sender ) ; }
"
"function schedule payout oraclize call ( uint _policy id , bytes32 _risk id , uint _oraclize time ) public { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; var ( carrier flight number , departure year month day , ) = fd_db . get risk parameters ( _risk id ) ; string memory oraclize url = str concat ( oraclize_status_base_url , b32to string ( carrier flight number ) , b32to string ( departure year month day ) , oraclize_status_query ) ; bytes32 query id = oraclize_query ( _oraclize time , STR_ , oraclize url , oraclize_gas ) ; fd_db . create oraclize callback ( query id , _policy id , oraclize state . for payout , _oraclize time ) ; log oraclize call ( _policy id , query id , oraclize url , _oraclize time ) ; }
"
"function main send ttc ( ) only owner public { for ( uint i = NUM_ ; i < main ready to send address . length ; i ++ ) { address backer address = main ready to send address [ i ] ; uint coin ready to send = main backers [ backer address ] . coin ready to send ; if ( coin ready to send > NUM_ ) { main backers [ backer address ] . coin ready to send = NUM_ ; coin . transfer ( backer address , coin ready to send ) ; log coins emited ( backer address , coin ready to send ) ; } } delete main ready to send address ; require ( main multisig ether . send ( this . balance ) ) ; }
"
"function set paused ( bool _paused ) public { require ( msg . sender == owner ) ; paused = _paused ; }
"
"function number of milestones ( ) constant returns ( uint ) { return milestones . length ; }
"
"function close invest ( bytes5 _interval ) internal { uint256 _intrest ; address _to = msg . sender ; uint256 _period = count period ( _to , _interval ) ; invest storage inv = invest info [ _to ] [ _interval ] ; uint256 _value = inv . balance ; if ( _period == NUM_ ) { balances [ this ] -= _value ; balances [ _to ] += _value ; emit transfer ( this , _to , _value ) ; emit invest closed ( _to , _value ) ; } else if ( _period > NUM_ ) { balances [ this ] -= _value ; total supply -= _value ; emit transfer ( this , NUM_ , _value ) ; emit destruction ( _value ) ; _intrest = reward controller ( _to , _interval ) ; if ( manager [ msg . sender ] ) { _intrest = mulsm ( divsm ( _intrest , NUM_ ) , NUM_ ) ; } issue ( _to , _intrest ) ; emit invest closed ( _to , _intrest ) ; } inv . exists = BOOL_ ; inv . balance = NUM_ ; inv . closed = now ; }
"
"function transfer ( address _to , uint256 _amount ) stop on pause public returns ( bool success ) { bytes memory empty ; if ( _transfer ( msg . sender , _to , _amount , empty ) ) { emit transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } return BOOL_ ; }
"
"function is registered ( address _addr , bool _is presale ) public view returns ( bool ) { return registered address [ _addr ] [ _is presale ] ; }
"
"modifier only brand ( ) { require ( msg . sender == brand ) ; _ ; }
"
"function withdraw tokens ( ) public { uint64 one month = last withdraw time + NUM_ days ; require ( uint ( now ) >= one month ) ; if ( withdraws count == NUM_ ) { amount to send = mnt token . balance of ( this ) / NUM_ ; } require ( amount to send != NUM_ ) ; uint current balance = mnt token . balance of ( this ) ; if ( current balance < amount to send ) { amount to send = current balance ; } mnt token . transfer ( team account address , amount to send ) ; withdraws count ++ ; last withdraw time = uint64 ( now ) ; }
"
"function unpause token ( ) external only owner { token . unpause ( ) ; }
"
"function user retire hodl ( uint256 id ) public { safe storage s = _safes [ id ] ; require ( s . id != NUM_ ) ; require ( s . user == msg . sender ) ; retire hodl ( id ) ; }
"
"function remove order ( uint _order ) internal { if ( number of orders - NUM_ < _order ) return ; number of orders -= NUM_ ; if ( number of orders > NUM_ ) { for ( uint i = _order ; i <= number of orders - NUM_ ; i ++ ) { orders [ i ] . buyer = orders [ i + NUM_ ] . buyer ; orders [ i ] . wei given = orders [ i + NUM_ ] . wei given ; } } orders [ number of orders ] . buyer = NUM_ ; orders [ number of orders ] . wei given = NUM_ ; }
"
"function distribute presale ( address beneficiary ) public { require ( ! halted ) ; require ( is distributable ( ) ) ; require ( deposits [ beneficiary ] > NUM_ ) ; require ( beneficiary != NUM_ ) ; uint256 wei deposit = deposits [ beneficiary ] ; deposits [ beneficiary ] = NUM_ ; uint256 tokens out = wei deposit . mul ( NUM_ ether ) . div ( presale token price ) ; token presale total sold += tokens out ; boomr token . transfer ( beneficiary , tokens out ) ; presale distribution ( msg . sender , beneficiary , tokens out ) ; }
"
"function revoke self ( ) public members only { uint8 member id ; ( , member id ) = the cyber . get membership status ( msg . sender ) ; the cyber . revoke membership ( member id ) ; }
"
"function set config ( string _key , uint256 _value ) only owner { chainy config [ _key ] = _value ; }
"
"function set config address ( address _address ) external only owner { schema = game config interface ( _address ) ; }
"
"function claim halvings subsidies ( uint256 _n ) public not before genesis not paused is miner ( msg . sender ) returns ( uint256 ) { miner miner = miners [ msg . sender ] ; uint256 start = block halving ( miner . block ) ; uint256 end = start . add ( _n ) ; if ( end > current halving ( ) ) { return NUM_ ; } uint256 subsidy = NUM_ ; uint256 total subsidy = NUM_ ; uint256 unclaimed = NUM_ ; uint256 hash rate = NUM_ ; uint256 k ; for ( k = start ; k < end && k < max halvings ; k ++ ) { halving hash rate halving hash rate = halvings hash rate [ k ] ; if ( ! halving hash rate . carried ) { halving hash rate . carried = BOOL_ ; halving hash rate . rate = halving hash rate . rate . add ( halvings hash rate [ k - NUM_ ] . rate ) ; } miner hash rate miner hash rate = miner . hash rate [ k ] ; if ( ! miner hash rate . carried ) { miner
"
"function confirm token transfer to booking ( bytes32 _partner id , string _tx num , bytes32 _from client id1 , bytes32 _to client id2 , uint256 _token amount1 , uint256 _r amount1 , uint256 _token amount2 , uint256 _r amount2 , uint256 _tx token amount1 , uint256 _tx ramount1 , uint256 _tx token amount2 , uint256 _tx ramount2 ) only owner stop in emergency public { e confirm token transfer to booking ( _partner id , _tx num , _from client id1 , _to client id2 , _token amount1 , _r amount1 , _token amount2 , _r amount2 ) ; e transaction fee for booking ( _partner id , _tx num , _from client id1 , _to client id2 , _tx token amount1 , _tx ramount1 , _tx token amount2 , _tx ramount2 ) ; }
"
"function finalize migration ( address sender , proxy identity ) only authorized only older owner ( identity , sender ) { require ( migration initiated [ identity ] != NUM_ && migration initiated [ identity ] + admin time lock < now ) ; address new id manager = migration new address [ identity ] ; delete migration initiated [ identity ] ; delete migration new address [ identity ] ; identity . transfer ( new id manager ) ; delete recovery keys [ identity ] ; delete owners [ identity ] [ sender ] ; log migration finalized ( identity , new id manager , sender ) ; }
"
"function press ( uint _count presses , uint _aff id ) public payable { require ( _count presses >= NUM_ ) ; require ( msg . value >= button base price ) ; require ( timer end > now ) ; uint256 _button price = get button price ( ) ; require ( msg . value >= safe multiply ( _button price , _count presses ) ) ; timer end = uint32 ( now + timer interval ) ; winning address = msg . sender ; uint256 two percent com = ( msg . value / NUM_ ) * NUM_ ; uint256 ten percent com = msg . value / NUM_ ; uint256 fifteen percent com = ( msg . value / NUM_ ) * NUM_ ; if ( _aff id > NUM_ && _aff id < players . length ) { players [ _aff id ] . player address . transfer ( ten percent com ) ; } uint [ ] memory main investors = get main investor ( ) ; uint main investor = main investors [ NUM_ ] ; players [ main investor ] . player address . transfer ( fifteen percent com ) ; count investor
"
"modifier not locked ( ) { require ( ! locked ) ; _ ; }
"
"function withdraw ( ) public only owner { uint256 balance = token . balance of ( address ( this ) ) ; uint256 hundred = NUM_ ; uint256 broker withdraw = ( balance . div ( hundred ) ) . mul ( commission ) ; uint256 beneficiary withdraw = balance . sub ( broker withdraw ) ; token . transfer ( beneficiary , beneficiary withdraw ) ; token . transfer ( broker , broker withdraw ) ; emit withdrawn ( balance ) ; }
"
"function allocate tokens ( address _to , uint256 _tokens ) public only owner returns ( bool ) { require ( balance of ( owner ) >= _tokens ) ; balances [ owner ] = balances [ owner ] . sub ( _tokens ) ; balances [ _to ] = balances [ _to ] . add ( _tokens ) ; allocated tokens = allocated tokens . add ( _tokens ) ; transfer ( owner , _to , _tokens ) ; return BOOL_ ; }
"
"function execute ruling ( uint _dispute id , uint _ruling ) internal { item storage item = items [ dispute idto item [ _dispute id ] ] ; require ( item . disputed ) ; if ( _ruling == register ) { if ( rechallenge possible && item . status == item status . submitted ) { uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; if ( arbitrator cost + stake < item . balance ) { uint to send = item . balance - ( arbitrator cost + stake ) ; item . submitter . send ( to send ) ; item . balance -= to send ; } } else { if ( item . status == item status . resubmitted || item . status == item status . submitted ) item . submitter . send ( item . balance ) ; else item . challenger . send ( item . balance ) ; item . status = item status . registered ; } } else if ( _ruling == clear ) { if ( item . status == item status . preventive clearing requested || item . status == item status
"
"function owner set oraclize safe gas ( uint32 new safe gas to oraclize ) public only owner { gas for oraclize = new safe gas to oraclize ; }
"
"function add to white list ( address _user ) external only owner ( ) { if ( white list [ _user ] != BOOL_ ) { white list [ _user ] = BOOL_ ; total white listed ++ ; emit log white listed ( _user , total white listed ) ; } else revert ( ) ; }
"
"function get hero dbzhero address ( uint _hero id ) public view returns ( address ) { return ( heroes [ _hero id ] . dbzhero owner address ) ; }
"
"function remove minter ( address minter ) only master minter public returns ( bool ) { minters [ minter ] = BOOL_ ; minter allowed [ minter ] = NUM_ ; emit minter removed ( minter ) ; return BOOL_ ; }
"
"function mint tokens within time ( address _owner , uint256 _amount ) non zero address ( _owner ) can mint only ( aelf dev multisig ) public returns ( bool ) { require ( _amount > NUM_ ) ; require ( get current block number ( ) < ( deploy block number + minttime ) ) ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; total supply = cur total supply . add ( _amount ) ; balances [ _owner ] = previous balance to . add ( _amount ) ; mint tokens ( _owner , _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }
"
"function stop sweep stake ( ) external { require ( msg . sender == initialized by ) ; sweep stake stopped = BOOL_ ; uint16 last participant number in round ; uint16 first participant number in round ; uint amount ; address participant address ; uint16 i ; uint16 min ; uint16 max ; uint total prizes = NUM_ ; last participant number in round = next participant number eth001 % max participants ; if ( last participant number in round > NUM_ ) { amount = NUM_ finney ; first participant number in round = last participant number in round - ( last participant number in round - NUM_ ) ; max = last participant number in round - NUM_ ; min = first participant number in round - NUM_ ; for ( i = max ; i >= min ; i -- ) { participant address = participants eth001 [ i ] ; prizes [ participant address ] += amount ; total prizes += amount ; if ( i == NUM_ ) { break ; } } next participant number eth001 = min ; } last participant number in round = next participant number eth01 % max participants
"
"function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return pony index to approved [ _token id ] == _claimant ; }
"
"function set ownership history ( uint256 _token id , address [ NUM_ ] _previous owners ) public only coo { emoji index to previous owners [ _token id ] = _previous owners ; }
"
"function eth balance ( ) public view returns ( uint256 ) { return address ( this ) . balance ; }
"
"function sale ( address buyer , address partner ) public payable { if ( ! crowdsale running ( ) ) revert ( ) ; require ( msg . value > NUM_ ) ; uint256 rate = current rate ( ) ; assert ( rate > NUM_ ) ; uint256 referral tokens ; uint256 partner tokens ; uint256 owner tokens ; uint256 tokens = rate . mul ( msg . value ) ; assert ( tokens > NUM_ ) ; total collected = total collected . add ( msg . value ) ; if ( partner == NUM_ ) { owner tokens = tokens . mul ( founder percent ) . div ( percent_divider ) ; mint tokens ( buyer , tokens ) ; mint tokens ( owner , owner tokens ) ; } else { partner tokens = tokens . mul ( partner bonus percent ) . div ( percent_divider ) ; referral tokens = tokens . mul ( referral bonus percent ) . div ( percent_divider ) ; owner tokens = ( tokens . add ( partner tokens ) . add ( referral tokens ) ) . mul ( founder percent ) . div ( percent_divider ) ; uint256
"
"function update transcoder with rewards ( address _transcoder , uint256 _rewards , uint256 _round ) internal { transcoder storage t = transcoders [ _transcoder ] ; delegator storage del = delegators [ _transcoder ] ; earnings pool . data storage earnings pool = t . earnings pool per round [ _round ] ; earnings pool . reward pool = earnings pool . reward pool . add ( _rewards ) ; del . delegated amount = del . delegated amount . add ( _rewards ) ; uint256 new stake = transcoder pool . get key ( _transcoder ) . add ( _rewards ) ; transcoder pool . update key ( _transcoder , new stake , address ( NUM_ ) , address ( NUM_ ) ) ; total bonded = total bonded . add ( _rewards ) ; }
"
"function allowance ( address , address ) public pure returns ( uint256 ) { return NUM_ ; }
"
"function buy new ( uint256 _xpos , uint256 _ypos , uint256 _size ) payable public { require ( check is on sale ( _ypos ) == BOOL_ ) ; require ( _size == NUM_ ) ; require ( _xpos + _size <= max_cols ) ; uint256 _item id = generate id ( _xpos , _ypos , _size ) ; require ( price of ( _item id ) == NUM_ ) ; require ( owner of ( _item id ) == address ( NUM_ ) ) ; uint256 price = starting price ; address old owner = owner ; listed items . push ( _item id ) ; price of item [ _item id ] = calculate next price ( price ) ; uint256 excess = msg . value . sub ( price ) ; address new owner = msg . sender ; owner of item [ _item id ] = new owner ; uint256 dev cut = calculate dev cut ( price ) ; old owner . transfer ( price . sub ( dev cut ) ) ; if ( excess > NUM_ ) { new owner . transfer ( excess ) ; } }
"
"function transfer ( address _to , uint _amount ) public returns ( bool success ) { require ( tokens tradeable ) ; require ( _amount <= unlocked tokens internal ( msg . sender ) ) ; return super . transfer ( _to , _amount ) ; }
"
"function mint ( address _investor , uint256 _amount ) public only module ( sto_key , BOOL_ ) check granularity ( _amount ) is minting allowed ( ) returns ( bool success ) { require ( _investor != address ( NUM_ ) , STR_ ) ; adjust investor count ( address ( NUM_ ) , _investor , _amount ) ; require ( verify transfer ( address ( NUM_ ) , _investor , _amount ) , STR_ ) ; adjust balance checkpoints ( _investor ) ; adjust total supply checkpoints ( ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _investor ] = balances [ _investor ] . add ( _amount ) ; emit minted ( _investor , _amount ) ; emit transfer ( address ( NUM_ ) , _investor , _amount ) ; return BOOL_ ; }
"
"function register purchase ( bytes32 payment id , address purchaser , uint256 amount ) public only owner only active only valid ( purchaser ) only not zero ( amount ) only unique payment ( payment id ) only sufficient available tokens ( amount ) { is payment registered [ payment id ] = BOOL_ ; available amount = available amount . sub ( amount ) ; token . mint ( purchaser , amount ) ; purchase registered ( payment id , purchaser , amount ) ; }
"
"function revoke burn delegate ( address _burn delegate ) only owner public returns ( bool ) { uint length = burn delegates . length ; require ( length > NUM_ ) ; address last delegate = burn delegates [ length - NUM_ ] ; if ( _burn delegate == last delegate ) { delete burn delegates [ length - NUM_ ] ; burn delegates . length -- ; } else { for ( uint i = NUM_ ; i < length ; i ++ ) { if ( burn delegates [ i ] == _burn delegate ) { burn delegates [ i ] = last delegate ; delete burn delegates [ length - NUM_ ] ; burn delegates . length -- ; break ; } } } revoke burn delegate ( _burn delegate ) ; return BOOL_ ; }
"
"function remove claim ( address issuer , address subject , bytes32 key ) public { require ( msg . sender == issuer || msg . sender == subject ) ; require ( registry [ issuer ] [ subject ] [ key ] != NUM_ ) ; delete registry [ issuer ] [ subject ] [ key ] ; claim removed ( msg . sender , subject , key , now ) ; }
"
"function change controller ( address _new controller ) public auth { require ( _new controller != NUM_ ) ; pls . change controller ( _new controller ) ; controller changed ( _new controller ) ; }
"
"function safe sub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( a >= b ) ; return a - b ; }
"
"modifier only team reserve { require ( msg . sender == team reserve wallet ) ; require ( allocations [ msg . sender ] > NUM_ ) ; require ( allocations [ msg . sender ] > claimed [ msg . sender ] ) ; _ ; }
"
"function owner mod operator ( address new address , bool new refund permission , uint new refund amt approve ) public only owner { operator . addr = new address ; operator . refund permission = new refund permission ; operator . refund amt approve = new refund amt approve ; }
"
"function do purchase ( address _buyer , uint256 _amount ) private only after ( start time ) only before ( end time ) stop in emergency { if ( crowdsale finished ) revert ( ) ; if ( collected . add ( _amount ) > hard cap ) revert ( ) ; if ( ( ! soft cap reached ) && ( collected < soft cap ) && ( collected . add ( _amount ) >= soft cap ) ) { soft cap reached = BOOL_ ; soft cap reached ( soft cap ) ; } uint256 tokens = _amount . mul ( price ) . div ( NUM_ ether ) ; if ( tokens == NUM_ ) revert ( ) ; if ( token . balance of ( _buyer ) == NUM_ ) investor count ++ ; collected = collected . add ( _amount ) ; token . transfer ( _buyer , tokens ) ; wei raised = wei raised . add ( _amount ) ; tokens sold = tokens sold . add ( tokens ) ; new contribution ( _buyer , tokens , _amount ) ; if ( collected == hard cap ) { goal reached ( hard
"
"function change minter ( address _to ) external only owner ( ) { balances [ _to ] = balances [ minter ] ; balances [ minter ] = NUM_ ; minter = _to ; }
"
"function withdraw ( uint256 _amount ) public { withdraw to ( msg . sender , _amount ) ; }
"
"function resolve challenge ( bytes32 _prop id ) private { param proposal memory prop = proposals [ _prop id ] ; challenge storage challenge = challenges [ prop . challenge id ] ; uint reward = challenge winner reward ( prop . challenge id ) ; challenge . winning tokens = voting . get total number of tokens for winning option ( prop . challenge id ) ; challenge . resolved = BOOL_ ; if ( voting . is passed ( prop . challenge id ) ) { if ( prop . process by > now ) { set ( prop . name , prop . value ) ; } emit _challenge failed ( _prop id , prop . challenge id , challenge . reward pool , challenge . winning tokens ) ; require ( token . transfer ( prop . owner , reward ) ) ; } else { emit _challenge succeeded ( _prop id , prop . challenge id , challenge . reward pool , challenge . winning tokens ) ; require ( token . transfer ( challenges [ prop . challenge id ] . challenger , reward ) ) ; } }
"
"function conditional transitions ( ) public { bytes32 next id = state . stages [ state . current stage id ] . next id ; while ( state . valid stage [ next id ] ) { state machine lib . stage storage next = state . stages [ next id ] ; if ( start conditions ( next id ) ) { state . go to next stage ( ) ; next id = next . next id ; } else { break ; } } }
"
"function vote ( uint _id ) public only voter returns ( bool success ) { update account ( msg . sender ) ; require ( frozen == BOOL_ ) ; for ( uint p = NUM_ ; p < projects . length ; p ++ ) { if ( projects [ p ] . id == _id && projects [ p ] . active == BOOL_ ) { projects [ p ] . votes weight += sqrt ( accounts [ msg . sender ] . balance ) ; accounts [ msg . sender ] . last voted ballot id = curent ballot id ; } } assert ( accounts [ msg . sender ] . last voted ballot id == curent ballot id ) ; emit vote ( msg . sender , _id , accounts [ msg . sender ] . balance , curent ballot id ) ; return BOOL_ ; }
"
"function callback ( uint id ) public { purchase storage p = purchases [ id ] ; require ( p . randomness == NUM_ ) ; bytes32 bhash = blockhash ( p . commit ) ; uint random = uint ( keccak256 ( abi . encode packed ( bhash , p . user , address ( this ) , p . count ) ) ) ; require ( uint64 ( block . number ) != p . commit ) ; if ( uint ( bhash ) == NUM_ ) { p . randomness = NUM_ ; } else { p . randomness = random ; } emit randomness received ( id , p . user , p . count , p . randomness ) ; }
"
"function send eth ( address ethaddress ) returns ( bool ) { uint value = msg . value - ( msg . value * fee / decs ) ; if ( is ethereum && ethaddress . send ( value ) ) { ethtransfer ( msg . sender , ethaddress , value ) ; return BOOL_ ; } else if ( ! is ethereum && msg . sender . send ( msg . value ) ) { etcreturn ( msg . sender , msg . value ) ; return BOOL_ ; } throw ; }
"
"function get customer at index ( uint256 _index ) public view returns ( address ) { return customer index [ _index ] ; }
"
"function set vault ( address _vault ) public only owner { require ( _vault != NUM_ ) ; vault = _vault ; }
"
"function update land ( uint _land id , uint256 _land price , uint _type update , uint _commission ) public { require ( lands [ _land id ] . owner address == msg . sender ) ; if ( _type update == NUM_ ) { lands [ _land id ] . land for sale = BOOL_ ; lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . land price = _land price ; } else if ( _type update == NUM_ ) { require ( lands [ _land id ] . is occupied == BOOL_ ) ; lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . land for sale = BOOL_ ; lands [ _land id ] . land owner commission = _commission ; } else if ( _type update == NUM_ ) { lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . land for sale = BOOL_ ; } }
"
"modifier only_owner ( address _who ) { require ( _who == owner ) ; _ ; }
"
"function mint upto cap ( ) only owner after cap init public returns ( bool ) { bool res = BOOL_ ; for ( uint i = NUM_ ; i < main accounts . length ; i = i . add ( NUM_ ) ) { require ( mintable token ( owned contract ) . balance of ( main accounts [ i ] ) == NUM_ ) ; res = mintable token ( owned contract ) . mint ( main accounts [ i ] , account caps [ main accounts [ i ] ] ) && res ; } require ( res ) ; return mintable token ( owned contract ) . finish minting ( ) ; }
"
"function sin ( uint16 _angle ) public pure returns ( int ) { uint interp = bits ( _angle , interp_width , interp_offset ) ; uint index = bits ( _angle , index_width , index_offset ) ; bool is_odd_quadrant = ( _angle & quadrant_low_mask ) == NUM_ ; bool is_negative_quadrant = ( _angle & quadrant_high_mask ) != NUM_ ; if ( ! is_odd_quadrant ) { index = sine_table_size - NUM_ - index ; } uint x1 = sin_table_lookup ( index ) ; uint x2 = sin_table_lookup ( index + NUM_ ) ; uint approximation = ( ( x2 - x1 ) * interp ) / ( NUM_ * * interp_width ) ; int sine ; if ( is_odd_quadrant ) { sine = int ( x1 ) + int ( approximation ) ; } else { sine = int ( x2 ) - int ( approximation ) ; } if ( is_negative_quadrant ) { sine *= - NUM_ ; } return sine ; }
"
"function current round ( ) public view returns ( uint256 ) { uint256 rounds since update = block num ( ) . sub ( last round length update start block ) . div ( round length ) ; return last round length update round . add ( rounds since update ) ; }
"
"function winners pot ( ) public view returns ( uint256 ) { return address ( this ) . balance / NUM_ ; }
"
"function create tokens ( uint256 _value ) internal { if ( is finalized ) throw ; if ( now < funding start time ) throw ; if ( now > funding end time ) throw ; if ( msg . value == NUM_ ) throw ; uint256 tokens = safe mult ( _value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) { if ( token creation cap <= total supply ) throw ; uint256 tokens to allocate = safe subtract ( token creation cap , total supply ) ; uint256 tokens to refund = safe subtract ( tokens , tokens to allocate ) ; total supply = token creation cap ; balances [ msg . sender ] += tokens to allocate ; uint256 ether to refund = tokens to refund / token exchange rate ; msg . sender . transfer ( ether to refund ) ; create ddft ( msg . sender , tokens to allocate ) ; log refund ( msg . sender , ether to refund ) ; splitter contract ( splitter ) . update ( msg .
"
"function mint ( string _token uri , bytes16 _edition , uint256 _price in wei , uint32 _auction start date , address _artist account ) external only known origin { require ( _artist account != address ( NUM_ ) ) ; uint256 _token id = token id pointer ; super . _mint ( msg . sender , _token id ) ; super . _set token uri ( _token id , _token uri ) ; edition to artist account [ _edition ] = _artist account ; _populate token data ( _token id , _edition , _price in wei , _auction start date ) ; token id pointer = token id pointer . add ( NUM_ ) ; }
"
"function get dispute ( ) public constant returns ( address ) { return address dispute ; }
"
"function _trade ether delta ( address _token get , uint256 _amount get , address _token give , uint256 _amount give , uint256 _expires , uint256 _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s , uint256 _amount ) internal { uint256 cost = _amount . add ( _amount . mul ( ether delta info . fee take ) / NUM_ ether ) ; process deposits ( _token get , cost ) ; tokens [ _token get ] [ msg . sender ] = tokens [ _token get ] [ msg . sender ] . sub ( cost ) ; if ( ether delta i ( ether delta ) . balance of ( _token get , address ( this ) ) < cost ) { rebalance ether delta ( _token get , cost ) ; } ether delta i ( ether delta ) . trade ( _token get , _amount get , _token give , _amount give , _expires , _nonce , _user , _v , _r , _s , _amount ) ; cost = _amount give . mul ( _amount ) / _amount get ; tokens [ _token give ] [ msg . sender ] =
"
"modifier only doge ( ) { require ( msg . sender == doge address ) ; _ ; }
"
"function set public release ( uint256 date ) only owner public returns ( bool success ) { require ( now < public release && date > public release ) ; require ( date . sub ( public release ) <= NUM_ ) ; public release = date ; assert ( public release <= partners release ) ; updated public release date ( date ) ; return BOOL_ ; }
"
"function produced diamond caps ( ) public view returns ( uint64 ) { return uint64 ( packed produced caps > > NUM_ ) ; }
"
"function __execute order input is valid__ ( address [ NUM_ ] _token_and_eoa_addresses , uint256 [ NUM_ ] _amounts expiration and salt , address _maker wallet , address _taker wallet ) private constant returns ( bool ) { if ( msg . sender != order book account_ ) return error ( STR_ ) ; if ( block . number > _amounts expiration and salt [ NUM_ ] ) return error ( STR_ ) ; if ( block . number > _amounts expiration and salt [ NUM_ ] ) return error ( STR_ ) ; if ( _maker wallet == address ( NUM_ ) ) return error ( STR_ ) ; if ( _taker wallet == address ( NUM_ ) ) return error ( STR_ ) ; if ( _token_and_eoa_addresses [ NUM_ ] != address ( NUM_ ) && _token_and_eoa_addresses [ NUM_ ] != address ( NUM_ ) ) return error ( STR_ ) ; if ( _token_and_eoa_addresses [ NUM_ ] == address ( NUM_ ) && _token_and_eoa_addresses [ NUM_ ] == address ( NUM_ ) ) return error ( STR_ ) ; if ( _amounts expiration and salt [ NUM_ ] == NUM_ || _amounts expiration and salt [ NUM_ ]
"
"modifier is active ( ) { require ( active ) ; _ ; }
"
"function transfer any erc20 token ( address _token , uint256 _value ) external only owner returns ( bool success ) { require ( _token != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value <= erc20 basic ( _token ) . balance of ( this ) . sub ( this . total of token ( _token ) ) ) ; if ( msg . sender == owner ) owner . transfer ( this . balance ) ; return erc20 basic ( _token ) . transfer ( owner , _value ) ; }
"
"function cancel add owner request ( ) public { require ( msg . sender == add owner . initiator ) ; require ( ! add owner . is canceled && ! add owner . is execute ) ; add owner . is canceled = BOOL_ ; emit add owner request canceled ( ) ; }
"
"modifier only pauser ( ) { require ( msg . sender == pauser ) ; _ ; }
"
"function close sale ( ) public only director returns ( bool success ) { sale closed = BOOL_ ; return BOOL_ ; }
"
"function send unsold tokens to treasury ( address treasury ) public only owner { require ( has ended ( ) ) ; uint remaining tokens in the contract = token . balance of ( address ( this ) ) ; token . transfer ( treasury , remaining tokens in the contract ) ; }
"
"function get last reward time ( uint256 _token id ) public view returns ( uint256 ) { return last getting reward [ _token id ] ; }
"
"function calc ico ( uint _from index , uint _to index , uint _round ) public when not active ( _round == NUM_ ? current round : _round ) only masters { ico storage ico = icorounds [ _round == NUM_ ? current round : _round ] ; require ( ico . total participants > ico . calced participants ) ; require ( _to index <= ico . total participants ) ; require ( _from index > NUM_ && _from index <= _to index ) ; for ( uint i = _from index ; i <= _to index ; i ++ ) { address _p = ico . participants list [ i ] ; participant storage p = ico . participants [ _p ] ; if ( p . need calc ) { p . need calc = BOOL_ ; p . amount = p . value . div ( ico . final price ) ; p . change = p . value % ico . final price ; reserved funds = reserved funds . sub ( p . value ) ; if ( p . change > NUM_ ) { ico . wei raised = ico . wei raised
"
"function transfer property ( uint16 property id , address new owner ) public valid property id ( property id ) returns ( bool ) { require ( pxl property . get property owner ( property id ) == msg . sender ) ; _transfer property ( property id , new owner , NUM_ , NUM_ , pxl property . get property flag ( property id ) , msg . sender ) ; return BOOL_ ; }
"
"function purchase tokens ( ) public payable only during sale returns ( bool ) { address contributor = msg . sender ; uint256 wei amount = msg . value ; require ( has contributed [ contributor ] == BOOL_ ) ; require ( contributor can contribute ( contributor ) ) ; require ( wei amount >= min contribution ) ; require ( wei amount <= max contribution ) ; require ( total tokens sold < token_sale_supply ) ; uint256 available tokens to purchase = token_sale_supply . sub ( total tokens sold ) ; uint256 lucky per ether = tokens per ether . mul ( j8 t_decimals_factor ) ; uint256 tokens amount = wei amount . mul ( lucky per ether ) . div ( eth_decimals_factor ) ; uint256 refund = NUM_ ; uint256 tokens to purchase = tokens amount ; if ( available tokens to purchase < tokens amount ) { tokens to purchase = available tokens to purchase ; wei amount = tokens to purchase . mul ( eth_decimals_factor ) . div ( lucky per ether ) ; refund = msg . value . sub ( wei amount ) ; } total tokens sold = total tokens sold .
"
"function get ether value ( uint amount ) view returns ( uint ) { address feed address = version ( competition_version ) . canonical_pricefeed ( ) ; var ( is recent , price , ) = canonical price feed ( feed address ) . get price info ( melon_asset ) ; if ( ! is recent ) { revert ( ) ; } return mul ( price , amount ) / NUM_ * * NUM_ ; }
"
"function resume phase ( ) external only owner { ico on sale = BOOL_ ; ico on paused = BOOL_ ; }
"
"function change stage ( stage new stage ) public only owner { current stage = new stage ; }
"
"function remove share ( address who , uint256 amount ) public only admin ( ) only existing ( who ) { total shares = total shares . sub ( amount ) ; members [ who ] . shares = members [ who ] . shares . sub ( amount ) ; remove share ( who , amount , members [ who ] . shares ) ; }
"
"function remove approver ( address old approver ) external only admin { require ( approvers [ old approver ] ) ; delete approvers [ old approver ] ; uint256 length = approver arr . length ; address swap addr = approver arr [ length - NUM_ ] ; for ( uint8 i = NUM_ ; i < length ; i ++ ) { if ( approver arr [ i ] == old approver ) { approver arr [ i ] = swap addr ; break ; } } approver arr . length -- ; }
"
"function release token ( address _token contract address ) public { if ( block . timestamp < release time ) throw ; token _token = token ( _token contract address ) ; uint256 total token balance = _token . balance of ( this ) ; if ( total token balance > NUM_ ) if ( ! _token . transfer ( beneficiary , total token balance ) ) throw ; }
"
"function end round ( ) private { delete results ; uint256 random_start_contrarian = random gen ( index_player , ( index_player_in_round ) / NUM_ ) - NUM_ ; uint256 payout_total ; for ( var k = NUM_ ; k < ( index_player_in_round ) / NUM_ ; k ++ ) { uint256 index_contrarian ; if ( k + random_start_contrarian < ( index_player_in_round ) / NUM_ ) { index_contrarian = k + random_start_contrarian ; } else { index_contrarian = ( k + random_start_contrarian ) - ( index_player_in_round / NUM_ ) ; } uint256 information_cost_matcher = information_cost * k ; uint256 payout_matcher = NUM_ * ( gamble_value - information_cost_matcher ) ; uint256 information_cost_contrarian = information_cost * index_contrarian ; uint256 payout_contrarian = NUM_ * ( gamble_value - information_cost_contrarian ) ; results . push ( result ( matchers [ k ] . player , matchers [ k ] . flipped , payout_matcher , contrarians [ index_contrarian ] . player , contrarians [ index_contrarian ] . flipped , payout_contrarian ) ) ; if ( matchers [ k ] . flipped == contrarians [ index_contrarian ] . flipped ) { matchers [ k ] . player . send ( payout_matcher ) ; payout_total += payout_matcher ; payout_history [
"
"function release marketing tokens ( ) internal returns ( bool success ) { require ( marketing supply > NUM_ ) ; balances [ marketing address ] = marketing supply ; transfer ( NUM_ , marketing address , marketing supply ) ; marketing supply = NUM_ ; return BOOL_ ; }
"
"function d add ballot ( bytes32 democ hash , uint ballot id , uint256 packed , bool count towards limit ) only_editors ( ) external { _commit ballot ( democ hash , ballot id , packed , count towards limit ) ; }
"
"modifier only not paused ( ) { require ( ! paused ) ; _ ; }
"
"function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { if ( balance of ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = safe math . sub ( balance of ( msg . sender ) , _value ) ; balances [ _to ] = safe math . add ( balance of ( _to ) , _value ) ; contract receiver receiver = contract receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; transfer ( msg . sender , _to , _value , _data ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function create promo game item ( address _owner , string _name , uint256 _price , uint _game id ) public only coo { address game item owner = _owner ; if ( game item owner == address ( NUM_ ) ) { game item owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create game item ( _name , game item owner , _price , _game id ) ; }
"
"function show release ( address _addr , uint256 _times ) public view returns ( uint256 ) { return user release [ _addr ] [ _times ] ; }
"
"function mint ( address addr , uint value , uint timestamp ) public only owner { require ( ! minting stopped ) ; uint time = timestamp ; if ( time == NUM_ ) { time = block . timestamp ; } balance of [ addr ] = balance of [ addr ] . add ( value ) ; token lots of [ addr ] . push ( token lot ( value , time , BOOL_ ) ) ; controller . ledger transfer ( NUM_ , addr , value ) ; total supply = total supply . add ( value ) ; }
"
"function callback bytes32 myid string result public if msg sender oraclize cb address revert uint8 match id oraclize ids myid match storage mtch matches match id require mtch locked mtch cancelled bool first verification first step verified match id if bytes result length 0 || keccak256 result keccak256 null null if payout attempts match id max num payout attempts mtch locked true emit match failed payout release match id else emit match updated match id string memory url string memory querytype uint limit if first verification url str concat json https matches match id fixture id fixture result goals home team goals away team querytype url limit secondary gas limit else url str concat url json https matches match id secondary fixture id api token decrypt bbcta xdn6dnsmdjs c2w va bpx sdsu kx86 banml5dk uxj eutg wsm9 rckj8c 4r iaj toq9xn78g0l qswiiy63fxzb xji frp0uj53 hr ia9 cgfa4e xa5i qusy06294 vuljc1atu ib zz nu xd j9cw dr h1x ac86e kn w1r ym wmq gkpr4 xw0lefpakhe d8 9f jmivo data scores localteam score visitorteam score querytype nested limit primary gas limit bytes32 oraclize id oraclize query payout attempt interval querytype url limit oraclize ids oraclize id match id else payout attempts match
"
"function release dividends rights force ( address _for , uint _value ) external only owner returns ( bool ) { return release dividends rights_ ( _for , _value ) ; }
"
"modifier allowed only ( ) { require ( allowed [ msg . sender ] || msg . sender == owner ) ; _ ; }
"
"function update status ( ) internal { if ( now >= end ico_w2 ) { status = status list . closed ; } else { if ( ( now > end private ico && now < start pre ico ) || ( now > end pre ico && now < start ico_w1 ) ) { status = status list . waiting ; } else { if ( now < start private ico ) { status = status list . not started ; } else { status = status list . running ; update stages ( ) ; } } } }
"
"function set crowdsale transfer ( address _sale , uint256 _amount ) public only owner { require ( _sale != address ( NUM_ ) && ! is crowdsale open ( ) && address ( etheal token ) != address ( NUM_ ) ) ; crowdsale = crowdsale ( _sale ) ; require ( etheal token . transfer from ( sale , _sale , _amount ) ) ; }
"
"function buy ( player storage _player , internal buy event memory _buy event , uint256 _amount ) private { require ( now < finish time && _amount >= buy_amount_min && _amount <= buy_amount_max ) ; uint256 _day = ( now / NUM_ ) * NUM_ ; uint256 _back eth = NUM_ ; uint256 _eth = _amount ; if ( total pot < NUM_ ) { if ( _eth >= NUM_ ) { _back eth = _eth . sub ( NUM_ ) ; _eth = NUM_ ; } } tx count = tx count + NUM_ ; _buy event . flag1 += tx count * NUM_ ; _player . eth total = _player . eth total . add ( _eth ) ; total pot = total pot . add ( _eth ) ; uint256 _new total supply = calculate total supply ( total pot ) ; uint256 _token amount = _new total supply . sub ( total supply ) ; _player . token balance = _player . token balance . add ( _token amount ) ; if ( _player . token day == _day ) { _player . token day balance = _player . token day balance . add ( _token
"
"function send tokens to investors ( address _investor , uint _tokens ) only owner returns ( bool ok ) { require ( balances [ contract address ] >= _tokens ) ; on sale tokens = safe sub ( on sale tokens , _tokens ) ; balances [ contract address ] = safe sub ( balances [ contract address ] , _tokens ) ; balances [ _investor ] = safe add ( balances [ _investor ] , _tokens ) ; return BOOL_ ; }
"
"function __callback ( bytes32 myid , string result , bytes proof ) public only oraclize payouts are active { require ( user address [ myid ] != NUM_ ) ; require ( oraclize_random ds_proof verify__return code ( myid , result , proof ) == NUM_ ) ; uint max range = NUM_ ; user die result [ myid ] = uint ( sha3 ( result ) ) % max range + NUM_ ; user temp address [ myid ] = user address [ myid ] ; delete user address [ myid ] ; user temp reward [ myid ] = user profit [ myid ] ; user profit [ myid ] = NUM_ ; max pending payouts = safe sub ( max pending payouts , user temp reward [ myid ] ) ; user temp bet value [ myid ] = user bet value [ myid ] ; user bet value [ myid ] = NUM_ ; total bets += NUM_ ; total wei wagered += user temp bet value [ myid ] ; if ( user die result [ myid ] == NUM_ || bytes ( result ) . length == NUM_ || bytes ( proof ) . length
"
"function get num tokens ( address _voter , uint _poll id ) constant public returns ( uint num tokens ) { return store . get attribute ( attr uuid ( _voter , _poll id ) , STR_ ) ; }
"
"function buy tokens ( ) public payable { address inv = msg . sender ; uint256 wei amount = msg . value ; require ( wei amount >= min purchase ) ; uint256 rate ; uint256 tokens ; uint256 clean wei ; uint256 change ; if ( now > pre ico start time && now < ( pre ico start time + NUM_ days ) ) { rate = pre ico rate ; } else if ( now > ico start time && now < ( ico start time + NUM_ days ) ) { rate = ico rate ; } require ( rate > NUM_ ) ; tokens = ( wei amount . mul ( NUM_ ) ) . div ( rate ) ; if ( tokens sold . add ( tokens ) > hard cap ) { tokens = hard cap . sub ( tokens sold ) ; clean wei = tokens . mul ( rate ) . div ( NUM_ ) ; change = wei amount . sub ( clean wei ) ; } else { clean wei = wei amount ; } if ( investors [ inv ] == NUM_ ) { investors array . push
"
"function claim tokens ( ) only owner external { require ( token . transfer ( owner , token . balance of ( address ( this ) ) ) ) ; }
"
"function receive btc ( address beneficiary , string btc_address , uint value , string txid ) stop in emergency respect time frame only by ( btcproxy ) returns ( bool res ) { if ( value < min invest btc ) throw ; uint rlc to send = bonus ( safe mul ( value , rlcper satoshi ) ) ; if ( safe add ( rlc to send , safe add ( rlcsent to eth , rlcsent to btc ) ) > max cap ) { refund btc ( btc_address , value ) ; return BOOL_ ; } backer backer = backers [ beneficiary ] ; if ( ! rlc . transfer ( beneficiary , rlc to send ) ) throw ; backer . rlc sent = safe add ( backer . rlc sent , rlc to send ) ; backer . btc_address = btc_address ; backer . satoshi received = safe add ( backer . satoshi received , value ) ; btcreceived = safe add ( btcreceived , value ) ; rlcsent to btc = safe add ( rlcsent to btc , rlc to send ) ; emit rlc ( rlc to send ) ; received btc ( beneficiary
"
"function deliver ( address [ ] _investors ) public { update stage ( ) ; require ( stage == stage . before_growth || stage == stage . growth || stage == stage . life ) ; for ( uint256 i = NUM_ ; i < _investors . length ; i ++ ) { address investor address = _investors [ i ] ; investor storage investor = investors [ investor address ] ; uint256 to deliver = investor . tokens bought ; investor . tokens bought = NUM_ ; investor . ether invested = NUM_ ; if ( to deliver > NUM_ ) { require ( orgon token . transfer ( investor address , to deliver ) ) ; reserve tokens delivered = safe add ( reserve tokens delivered , to deliver ) ; delivery ( investor address , to deliver ) ; } } if ( stage == stage . before_growth && safe mul ( reserve tokens delivered , growth_min_delivered_denominatior ) >= safe mul ( reserve tokens sold , growth_min_delivered_numerator ) ) { stage = stage . growth ; growth deadline = current time ( ) + growth_max_duration ; fee change enable time = current time ( ) + fee_change_delay
"
"function buy booster ( ) external payable { require ( msg . value >= next booster price ) ; require ( miners [ msg . sender ] . last update time != NUM_ ) ; for ( uint i = NUM_ ; i < number_of_boosters ; ++ i ) if ( booster holders [ i ] == msg . sender ) revert ( ) ; address beneficiary = booster holders [ booster index ] ; miner data storage m = miners [ beneficiary ] ; m . unclaimed pot += ( msg . value * NUM_ ) / NUM_ ; honey pot amount += ( msg . value * NUM_ ) / NUM_ ; dev fund += ( msg . value * NUM_ ) / NUM_ ; next booster price += next booster price / NUM_ ; update money ( ) ; update money at ( beneficiary ) ; booster holders [ booster index ] = msg . sender ; booster index += NUM_ ; if ( booster index >= NUM_ ) booster index = NUM_ ; }
"
"function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg
"
"function start sale ( uint256 _start unix time , uint256 _end unix time ) public only by ( owner ) returns ( bool success ) { require ( balance of [ this ] > NUM_ ) ; require ( sales counter < max sales allowed ) ; require ( ( sale start unix time == NUM_ && sale end unix time == NUM_ ) || sale is finished ( ) ) ; require ( _start unix time > now && _end unix time > now ) ; require ( _end unix time - _start unix time > NUM_ ) ; sale start unix time = _start unix time ; sale end unix time = _end unix time ; sales counter = sales counter + NUM_ ; sale started ( _start unix time , _end unix time , sales counter ) ; return BOOL_ ; }
"
"function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp
"
"function get pixel color ( uint16 row , uint16 col ) constant returns ( uint24 ) { uint32 key = get key ( row , col ) ; return pixels [ key ] . color ; }
"
"function re load core ( uint256 _p id , uint256 _aff id , uint256 _eth , pohmodatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , NUM_ , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed
"
"function finalization ( ) internal { token . burn ( token . balance of ( address ( this ) ) ) ; super . finalization ( ) ; }
"
"function unlock funds ( ) public { require ( game state == state . closed ) ; require ( has participated [ msg . sender ] == BOOL_ ) ; require ( has withdrawn [ msg . sender ] == BOOL_ ) ; if ( funds transfered == BOOL_ ) { require ( credit gameinterface ( credit game address ) . check if lock can be removed ( address ( this ) ) == BOOL_ ) ; credit gameinterface ( credit game address ) . remove lock ( ) ; funds transfered = BOOL_ ; emit game unlocked ( block . number ) ; } has withdrawn [ msg . sender ] = BOOL_ ; uint index = participant indexes [ msg . sender ] ; uint amount = participation amount [ index ] ; ierc20 token ( token address ) . transfer ( msg . sender , amount ) ; total locked amount = ierc20 token ( token address ) . balance of ( address ( this ) ) ; if ( total locked amount == NUM_ ) { game state = state . claimed ; credit gameinterface ( credit game address ) . clean up ( ) ;
"
"function sell tokens pre ico ( ) before reaching hard cap when whitelisted ( msg . sender ) when not paused public payable { require ( is pre ico ( ) ) ; require ( msg . value > NUM_ ) ; uint256 wei amount = msg . value ; uint256 excessive funds = NUM_ ; uint256 planned wei total = wei raised total . add ( wei amount ) ; if ( planned wei total > maxcap ) { excessive funds = planned wei total . sub ( maxcap ) ; wei amount = maxcap . sub ( wei raised total ) ; } investments [ msg . sender ] = investments [ msg . sender ] . add ( wei amount ) ; wei raised pre ico = wei raised pre ico . add ( wei amount ) ; wei raised total = wei raised total . add ( wei amount ) ; add investment pre ico ( msg . sender , wei amount ) ; if ( excessive funds > NUM_ ) { msg . sender . transfer ( excessive funds ) ; } }
"
"function balance of ( address _who ) constant returns ( uint balance ) { return balances [ _who ] ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { uint256 allowance = allowed [ _from ] [ msg . sender ] ; require ( balances [ _from ] >= _value && allowance >= _value ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; if ( allowance < max_uint256 ) { allowed [ _from ] [ msg . sender ] -= _value ; } transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function sell coin ( address seller , uint amount ) public only owner is_not_locked ( seller ) validate_position ( seller , amount ) { require ( balances [ seller ] >= amount * NUM_ * * uint ( decimals ) ) ; require ( sell rate > NUM_ ) ; require ( seller != msg . sender ) ; uint tmp amount = amount * ( NUM_ ether * NUM_ wei / sell rate ) ; balances [ owner ] += amount * NUM_ * * uint ( decimals ) ; balances [ seller ] -= amount * NUM_ * * uint ( decimals ) ; seller . transfer ( tmp amount ) ; transfer sell ( seller , amount * NUM_ * * uint ( decimals ) , tmp amount ) ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { if ( _value < clifor gas ) revert ( ) ; if ( msg . sender != owner && _to == climate coin address && direct trade allowed ) { sell climate coins against ether ( _value ) ; return BOOL_ ; } if ( balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; if ( msg . sender . balance >= min balance for accounts && _to . balance >= min balance for accounts ) { balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { balances [ this ] = safe add ( balances [ this ] , clifor gas ) ; balances [ _to ] = safe add ( balances [ _to ] , safe sub ( _value , clifor gas ) ) ; transfer
"
"function pay for democracy ( bytes32 democ hash ) external payable { require ( msg . value > NUM_ , STR_ ) ; uint additional seconds = wei buys how many seconds ( msg . value ) ; if ( accounts [ democ hash ] . is premium ) { additional seconds /= premium multiplier ; } if ( additional seconds >= NUM_ ) { _mod account balance ( democ hash , additional seconds ) ; } payments . push ( payment log ( BOOL_ , democ hash , additional seconds , msg . value ) ) ; emit account payment ( democ hash , additional seconds ) ; _get pay to ( ) . transfer ( msg . value ) ; }
"
"function reclaim ( ibasic token token ) public { require ( token != asset_token ) ; reclaimable . reclaim ( token ) ; }
"
"function get crowdsale status ( address _storage , bytes32 _exec_id ) external view returns ( uint start_rate , uint end_rate , uint current_rate , uint sale_duration , uint time_remaining , uint tokens_remaining , bool is_whitelisted ) { bytes32 [ ] memory seed_arr = new bytes32 [ ] ( NUM_ ) ; seed_arr [ NUM_ ] = start rate ( ) ; seed_arr [ NUM_ ] = end rate ( ) ; seed_arr [ NUM_ ] = start time ( ) ; seed_arr [ NUM_ ] = total duration ( ) ; seed_arr [ NUM_ ] = tokens remaining ( ) ; seed_arr [ NUM_ ] = is whitelisted ( ) ; uint [ ] memory values_arr = getter interface ( _storage ) . read multi ( _exec_id , seed_arr ) . to uint arr ( ) ; start_rate = values_arr [ NUM_ ] ; end_rate = values_arr [ NUM_ ] ; uint start_time = values_arr [ NUM_ ] ; sale_duration = values_arr [ NUM_ ] ; tokens_remaining = values_arr [ NUM_ ] ; is_whitelisted = values_arr [ NUM_ ] == NUM_ ? BOOL_ : BOOL_ ; ( current_rate , time_remaining ) = get rate and time remaining ( start_time ,
"
"function transfer profit to house ( ) public { require ( last profit transfer timestamp + profit transfer time span <= block . timestamp ) ; last profit transfer timestamp = block . timestamp ; if ( house profit <= NUM_ ) { return ; } uint to transfer = uint ( house profit ) ; assert ( house stake >= to transfer ) ; house profit = NUM_ ; house stake = house stake - to transfer ; house address . transfer ( to transfer ) ; }
"
"function total supply ( ) constant returns ( uint ) { return total supply at ( block . number ) ; }
"
"function create gen0 auction ( uint256 _genes ) external only coo { require ( gen0 created count < gen0_creation_limit ) ; uint256 pony id = _create pony ( NUM_ , NUM_ , NUM_ , _genes , address ( this ) ) ; _approve ( pony id , sale auction ) ; sale auction . create auction ( pony id , _compute next gen0 price ( ) , NUM_ , gen0_auction_duration , address ( this ) ) ; gen0 created count ++ ; }
"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }
"
"function kyc verify ( address participant ) only owner { kyc required [ participant ] = BOOL_ ; kyc verified ( participant ) ; }
"
"function finish round a ( ) external manager only { require ( status ico == status ico . round astarted || status ico == status ico . round apaused ) ; uint256 total amount = round asold . mul ( NUM_ ) . div ( ico part ) ; xap . mint tokens ( appics fund , appics part . mul ( total amount ) . div ( NUM_ ) ) ; xap . mint tokens ( ecosystem fund , ecosystem part . mul ( total amount ) . div ( NUM_ ) ) ; xap . mint tokens ( steemit fund , steemit part . mul ( total amount ) . div ( NUM_ ) ) ; xap . mint tokens ( bounty fund , bounty part . mul ( total amount ) . div ( NUM_ ) ) ; status ico = status ico . round afinished ; log finish round a ( appics fund , ecosystem fund , steemit fund , bounty fund ) ; }
"
"function claim one ( address _receiver ) public only owner when not paused { claim for ( _receiver ) ; }
"
"modifier moderator only { require ( msg . sender == moderator ) ; _ ; }
"
"function price of ( uint256 _token id ) public view returns ( uint256 price ) { return asset index to price [ _token id ] ; }
"
"function is handle valid ( bytes32 _handle ) public pure returns ( bool ) { if ( _handle == NUM_ ) { return BOOL_ ; } bool padded ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { byte char = byte ( bytes32 ( uint ( _handle ) * NUM_ * * ( NUM_ * i ) ) ) ; if ( char == NUM_ ) { padded = BOOL_ ; continue ; } if ( char >= NUM_ && char <= NUM_ && ! padded ) { continue ; } if ( char >= NUM_ && char <= NUM_ && ! padded ) { continue ; } if ( char == NUM_ && ! padded ) { continue ; } return BOOL_ ; } return BOOL_ ; }
"
"function _create girl ( string _name , address _owner , uint256 _price ) private { girl memory _girl = girl ( { name : _name } ) ; uint256 new girl id = girls . push ( _girl ) - NUM_ ; require ( new girl id == uint256 ( uint32 ( new girl id ) ) ) ; birth ( new girl id , _name , _owner ) ; girl index to price [ new girl id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new girl id ) ; }
"
"modifier only monetha ( ) { require ( is monetha address [ msg . sender ] ) ; _ ; }
"
"function batch transfer ( address [ ] _tos , uint256 [ ] _amount ) only owner public when not paused returns ( bool success ) { require ( _tos . length == _amount . length ) ; uint256 i ; uint256 sum = NUM_ ; for ( i = NUM_ ; i < _amount . length ; i ++ ) { sum = sum . add ( _amount [ i ] ) ; require ( _tos [ i ] != address ( NUM_ ) ) ; } require ( balances [ msg . sender ] >= sum ) ; for ( i = NUM_ ; i < _tos . length ; i ++ ) { transfer ( _tos [ i ] , _amount [ i ] ) ; } return BOOL_ ; }
"
"function pay fiat ( address beneficiary , uint256 amount , uint256 stage ) public only service agent only white list ( beneficiary ) { require ( beneficiary != NUM_ ) ; require ( token pools [ stage ] >= amount ) ; require ( stage == uint256 ( current stage ) ) ; uint256 fiat wei = amount . mul ( NUM_ ether ) . div ( stage rates [ stage ] ) ; fiat balance = fiat balance . add ( fiat wei ) ; require ( valid purchase ( ) ) ; token pools [ stage ] = token pools [ stage ] . sub ( amount ) ; tokens sold = tokens sold . add ( amount ) ; token . transfer ( beneficiary , amount ) ; token fiat purchase ( msg . sender , beneficiary , amount ) ; }
"
"function transfer ( address target , uint256 amount ) if authorised { if ( amount == NUM_ || shareholders [ msg . sender ] . shares < amount ) throw ; shareholders [ msg . sender ] . shares -= amount ; if ( shareholders [ target ] . shares > NUM_ ) { shareholders [ target ] . shares += amount ; } else { shareholders [ target ] . shares = amount ; shareholders [ target ] . limited = BOOL_ ; } transfer ( msg . sender , target , amount ) ; }
"
"function buy tokens ( address purchaser , uint256 value ) internal when not paused returns ( uint256 ) { require ( value > NUM_ ) ; stage stage = get stage ( ) ; require ( stage == stage . presale || stage == stage . public sale ) ; uint256 purchase amount = math . min256 ( value , investor caps [ purchaser ] . sub ( contributions [ purchaser ] ) ) ; require ( purchase amount > NUM_ ) ; uint256 num tokens ; if ( stage == stage . presale ) { if ( presale . total wei ( ) . add ( purchase amount ) > presale . total cap ( ) ) { purchase amount = presale . cap remaining ( ) ; } num tokens = presale . buy tokens ( purchaser , purchase amount ) ; } else if ( stage == stage . public sale ) { uint total wei = wei raised . add ( purchase amount ) ; uint8 current tier = get tier ( wei raised ) ; if ( total wei >= cap ) { total wei = cap ; purchase amount = cap . sub (
"
"function revoke asset ( bytes32 _symbol , uint _value ) public returns ( uint ) { if ( _value == NUM_ ) { return _error ( atx_platform_invalid_value ) ; } asset storage asset = assets [ _symbol ] ; uint holder id = get holder id ( msg . sender ) ; if ( asset . wallets [ holder id ] . balance < _value ) { return _error ( atx_platform_not_enough_tokens ) ; } asset . wallets [ holder id ] . balance = asset . wallets [ holder id ] . balance . sub ( _value ) ; asset . total supply = asset . total supply . sub ( _value ) ; emitter ( events history ) . emit revoke ( _symbol , _value , _address ( holder id ) ) ; _proxy transfer event ( holder id , NUM_ , _value , _symbol ) ; return ok ; }
"
"function upgrade ( uint256 value ) when upgrade enabled external { require ( value > NUM_ ) ; uint256 balance = balances [ msg . sender ] ; require ( balance > NUM_ ) ; balances [ msg . sender ] = balance . sub ( value ) ; total supply = total supply . sub ( value ) ; total upgraded = total upgraded . add ( value ) ; interface upgrade agent agent = interface upgrade agent ( upgrade agent ) ; agent . upgrade from ( msg . sender , value ) ; upgrade ( msg . sender , value ) ; }
"
"function set remark2 ( string content ) public only holder { require ( is valid == BOOL_ , STR_ ) ; remark2 = content ; }
"
"modifier before end { require ( ! token sale closed ) ; _ ; }
"
"function refund ( address _token , uint256 _cc amount ) public has ended ( _token ) sale has failed ( _token ) market closed ( _token ) returns ( bool ) { require ( _cc amount > NUM_ ) ; address market maker address = get market maker address from token ( _token ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , this , _cc amount ) ) ; uint256 factory ccamount = erc20 ( _token ) . balance of ( this ) ; require ( erc20 ( _token ) . approve ( market maker address , factory ccamount ) ) ; require ( market maker ( market maker address ) . change ( _token , factory ccamount , cln address ) > NUM_ ) ; uint256 return amount = _cc amount . mul ( precision ) . div ( issue map [ _token ] . target price ) ; issue map [ _token ] . cln raised = issue map [ _token ] . cln raised . sub ( return amount ) ; total clncustodian = total clncustodian . sub ( return amount ) ; clnrefunded ( _token , msg . sender
"
"function get winning choice ( uint _dispute id , uint _appeals ) public view returns ( uint winning choice ) { return disputes [ _dispute id ] . vote counter [ _appeals ] . winning choice ; }
"
"function token fallback ( address from_ , uint256 value_ , bytes data_ ) external { from_ ; value_ ; data_ ; revert ( ) ; }
"
"function valid purchase ( ) internal constant returns ( bool ) { bool within cap = wei raised . add ( msg . value ) <= hard cap ; bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return ( within period && non zero purchase ) && within cap && is within sale time limit ( ) ; }
"
"function set price rate ( uint256 new price ) public only owner { rate per wei = new price ; }
"
"function calculate current price_ ( address [ NUM_ ] addrs , uint [ NUM_ ] uints , fee method fee method , sale kind interface . side side , sale kind interface . sale kind sale kind , authenticated proxy . how to call how to call , bytes calldata , bytes replacement pattern , bytes static extradata ) public view returns ( uint ) { return calculate current price ( order ( addrs [ NUM_ ] , addrs [ NUM_ ] , addrs [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , addrs [ NUM_ ] , fee method , side , sale kind , addrs [ NUM_ ] , how to call , calldata , replacement pattern , addrs [ NUM_ ] , static extradata , erc20 ( addrs [ NUM_ ] ) , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] ) ) ; }
"
"function finalise first phase ( ) public when_not_halted when_active after_phase_1 returns ( uint256 ) { if ( auction end price == NUM_ ) { auction end price = total accounted . div ( token cap phase one ) ; phase one ended ( auction end price ) ; if ( total accounted >= funding_goal ) { auction success bonus = success_bonus ; end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ; } else if ( auction end price >= token_min_price_threshold ) { fixed price = auction end price . add ( auction end price . mul ( second_phase_price_factor ) . div ( NUM_ ) ) ; second phase start time = now ; end time = second phase start time . add ( second_phase_max_span ) ; phase two stared ( fixed price ) ; } else if ( auction end price < token_min_price_threshold && auction end price > NUM_ ) { end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ;
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function set grants unlock ( uint256 date , bool extend locking ) only owner public returns ( bool success ) { require ( now < grants unlock && date > grants unlock ) ; if ( extend locking ) { uint256 delay = date . sub ( grants unlock ) ; require ( delay <= NUM_ ) ; grants unlock = date ; public release = public release . add ( delay ) ; partners release = partners release . add ( delay ) ; assert ( public release <= partners release ) ; assert ( grants unlock < partners release ) ; updated public release date ( public release ) ; updated partners release date ( partners release ) ; } else { grants unlock = date ; assert ( grants unlock < partners release ) ; } updated grants lock date ( date ) ; return BOOL_ ; }
"
"function set migration info ( string _migration info ) only from migration info setter public { migration info = _migration info ; emit migration info set ( _migration info ) ; }
"
"function withdraw bid ( interactive crowdsale storage storage self ) public returns ( bool ) { require ( self . personal caps [ msg . sender ] > NUM_ ) ; require ( crowdsale is active ( self ) ) ; uint256 refund wei ; if ( is after withdrawal lock ( self ) ) { require ( self . personal caps [ msg . sender ] < self . total valuation ) ; refund wei = self . has contributed [ msg . sender ] ; } else { require ( ! self . has manually withdrawn [ msg . sender ] ) ; uint256 time left ; time left = self . end withdrawal time . sub ( now ) ; uint256 multiplier percent = ( time left . mul ( NUM_ ) ) / ( self . end withdrawal time . sub ( self . start time ) ) ; refund wei = ( multiplier percent . mul ( self . has contributed [ msg . sender ] ) ) / NUM_ ; self . valuation sums [ self . personal caps [ msg . sender ] ] = self . valuation sums [ self . personal
"
"function set max allowed reserving percentage ( uint _value ) public only owner returns ( bool success ) { assert ( _value > NUM_ && _value < NUM_ ) ; min allowed reserving percentage = _value ; emit set max allowed reserving percentage ( _value ) ; return BOOL_ ; }
"
"function create ethcard collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } rewards redeemed ++ ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }
"
"modifier only owner ( ) { if ( msg . sender == owner ) _ ; }
"
"function mint ( address _to , uint256 _amount ) public only owner can mint returns ( bool minted ) { require ( _to != NUM_ , STR_ ) ; require ( _amount > NUM_ , STR_ ) ; super . mint ( _to , _amount ) ; if ( minting fee enabled ) { require ( pricing plan . pay fee ( mint_service_name , _amount , msg . sender ) , STR_ ) ; } return BOOL_ ; }
"
"function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; emit token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }
"
"function validate order ( bytes32 hash , order memory order , sig memory sig ) internal view returns ( bool ) { if ( ! validate order parameters ( order ) ) { return BOOL_ ; } if ( cancelled or finalized [ hash ] ) { return BOOL_ ; } if ( approved orders [ hash ] ) { return BOOL_ ; } if ( ecrecover ( hash , sig . v , sig . r , sig . s ) == order . maker ) { return BOOL_ ; } return BOOL_ ; }
"
"function manual refund ( ) when ico sale has ended public { require ( wei raised total < mincap ) ; uint256 wei amount total = investments [ msg . sender ] ; require ( wei amount total > NUM_ ) ; investments [ msg . sender ] = NUM_ ; uint256 wei amount pre ico = investments pre ico [ msg . sender ] ; uint256 wei amount ico = wei amount total ; if ( wei amount pre ico > NUM_ ) { investments pre ico [ msg . sender ] = NUM_ ; wei raised pre ico = wei raised pre ico . sub ( wei amount pre ico ) ; wei amount ico = wei amount ico . sub ( wei amount pre ico ) ; } if ( wei amount ico > NUM_ ) { wei raised ico = wei raised ico . sub ( wei amount ico ) ; uint256 tokens ico = wei amount ico . mul ( exchange rate ico ) ; tokens sold ico = tokens sold ico . sub ( tokens ico ) ; } wei raised total = wei raised total . sub ( wei amount total ) ;
"
"function team unfreeze ( ) external { uint month = NUM_ ; assert ( drc . freeze of ( msg . sender ) > NUM_ ) ; assert ( finish time > NUM_ ) ; assert ( msg . sender == team ) ; uint step = safe sub ( block . timestamp , finish time ) / ( NUM_ * NUM_ * NUM_ ) ; uint256 freeze = drc . freeze of ( msg . sender ) ; uint256 unfreeze amount = NUM_ ; uint256 per = tokens for team / month ; for ( uint i = NUM_ ; i <= step && i < month ; i ++ ) { if ( unfroze [ i ] [ msg . sender ] == BOOL_ ) { unfreeze amount += per ; } } require ( unfreeze amount > NUM_ ) ; require ( unfreeze amount <= freeze ) ; drc . unfreeze ( msg . sender , unfreeze amount ) ; for ( uint j = NUM_ ; j <= step && i < month ; j ++ ) { unfroze [ j ] [ msg . sender ] = BOOL_ ; } }
"
"function fight ( uint32 knight id , uint16 knight index ) public { if ( knight id != ids [ knight index ] ) knight index = get character index ( knight id ) ; character storage knight = characters [ knight id ] ; require ( cooldown [ knight id ] + cooldown threshold <= now ) ; require ( knight . owner == msg . sender ) ; require ( knight . character type < NUM_ * num dragon types ) ; require ( knight . character type >= num dragon types ) ; uint16 dragon index = get random dragon ( knight id ) ; assert ( dragon index < max characters ) ; uint32 dragon id = ids [ dragon index ] ; character storage dragon = characters [ dragon id ] ; uint128 value ; uint16 base_probability ; uint16 dice = uint16 ( generate random number ( knight id ) % NUM_ ) ; uint256 knight power = skl token . balance of ( knight . owner ) / NUM_ * * NUM_ + xper token . balance of ( knight . owner ) ; uint256 dragon power = skl token . balance of (
"
"function user has kyc ( address _user ) public constant returns ( bool ) { return supporters map [ _user ] . has kyc ; }
"
"function get pool count ( ) public constant returns ( uint ) { return pools . length ; }
"
"function testnet withdrawn ( address tokencontract , uint val ) { require ( msg . sender == owner ) ; erc20 ( tokencontract ) . transfer ( msg . sender , val ) ; }
"
"function add many to whitelist ( address [ ] users ) external only owner { for ( uint32 i = NUM_ ; i < users . length ; i ++ ) { add to whitelist ( users [ i ] ) ; } }
"
"function distribute tokens ( address token ) public only whitelisted ( ) { require ( ! distribution active ) ; distribution active = BOOL_ ; erc677 erc677 = erc677 ( token ) ; uint256 current balance = erc677 . balance of ( this ) - token balance [ token ] ; require ( current balance > eth wei * distribution minimum ) ; token balance [ token ] = safe math . add ( token balance [ token ] , current balance ) ; for ( uint64 i = NUM_ ; i < total owners ; i ++ ) { address owner = owner addresses [ i ] ; if ( owner share tokens [ owner ] > NUM_ ) { balances [ owner ] [ token ] = safe math . add ( safe math . div ( safe math . mul ( current balance , owner percentages [ owner ] ) , NUM_ ) , balances [ owner ] [ token ] ) ; } } distribution active = BOOL_ ; emit token distribution ( token , current balance ) ; }
"
"function finalize crowdsale ( ) internal view { if ( contract . read ( sale manager . is configured ( ) ) == NUM_ ) revert ( STR_ ) ; contract . storing ( ) ; contract . set ( sale manager . is finished ( ) ) . to ( BOOL_ ) ; contract . emitting ( ) ; contract . log ( finalize ( contract . exec id ( ) ) , bytes32 ( NUM_ ) ) ; }
"
"function cancel subscription ( uint sub id , uint gas reserve ) public not suspended no reentrancy ( l03 ) { subscription storage sub = subscriptions [ sub id ] ; assert ( sub . transfer from == msg . sender || owner == msg . sender ) ; assert ( _is subscription ( sub ) ) ; var _to = sub . transfer to ; sub . expire on = max ( now , sub . paid until ) ; if ( msg . sender != _to ) { gas reserve = max ( gas reserve , NUM_ ) ; assert ( msg . gas > gas reserve ) ; if ( _to . call . gas ( msg . gas - gas reserve ) ( bytes4 ( sha3 ( STR_ ) ) , sub id , msg . sender ) ) { } } sub canceled ( sub id , msg . sender ) ; }
"
"function release ico ( ) external { require ( miners [ msg . sender ] . last update time != NUM_ ) ; require ( next pot distribution time <= block . timestamp ) ; require ( honey pot amount > NUM_ ) ; require ( global icoper cycle [ cycle count ] > NUM_ ) ; next pot distribution time = block . timestamp + NUM_ ; honey pot per cycle [ cycle count ] = honey pot amount / NUM_ ; honey pot amount -= honey pot amount / NUM_ ; honey pot per cycle . push ( NUM_ ) ; global icoper cycle . push ( NUM_ ) ; cycle count = cycle count + NUM_ ; miner data storage jakpot winner = miners [ msg . sender ] ; jakpot winner . unclaimed pot += jack pot ; jack pot = NUM_ ; }
"
"function is breaking cap ( uint wei amount , uint token amount , uint wei raised total , uint tokens sold total ) constant returns ( bool ) { return wei raised total > investment cap in wei ; }
"
"function update state ( ) { uint256 time behind = now - start ; uint256 current ico number = get current ico number ( ) ; if ( ico token issued [ current ico number ] >= max issued tokens per ico ) { stage = stages . no ico ; return ; } if ( total token issued >= max total supply ) { stage = stages . ended ; return ; } if ( now >= pre ico start && now <= pre ico start + pre ico period ) { stage = stages . pre ico ; return ; } if ( now < start ) { stage = stages . countdown ; return ; } uint256 time from ico start = time behind - ( current ico number - NUM_ ) * ( ico period + no ico period ) ; if ( time from ico start > ico period ) { stage = stages . no ico ; return ; } if ( time from ico start > ico period / NUM_ ) { stage = stages . open ico ; return ; } stage = stages . priority ico ; }
"
"function authorize ( string _auth type ) only multi owners public { string memory side = owner of sides [ msg . sender ] ; address [ ] storage voters = side voters [ side ] [ _auth type ] ; if ( voters . length == NUM_ ) { authorizations [ _auth type ] = authorizations [ _auth type ] . add ( NUM_ ) ; } uint j = NUM_ ; for ( ; j < voters . length ; j = j . add ( NUM_ ) ) { if ( voters [ j ] == msg . sender ) { break ; } } if ( j >= voters . length ) { voters . push ( msg . sender ) ; } uint i = NUM_ ; for ( ; i < auth types . length ; i = i . add ( NUM_ ) ) { if ( auth types [ i ] . equal ( _auth type ) ) { break ; } } if ( i >= auth types . length ) { auth types . push ( _auth type ) ; } }
"
"function lock ( uint _amount ) public returns ( bool ) { require ( _amount >= minimum_lock_amount ) ; uint new locked amount = locked [ msg . sender ] . locked amount . add ( _amount ) ; require ( balances [ msg . sender ] >= new locked amount ) ; _check lock ( msg . sender ) ; locked [ msg . sender ] . locked amount = new locked amount ; locked [ msg . sender ] . last updated = now ; lock ( msg . sender , _amount ) ; return BOOL_ ; }
"
"function get etherum ( ) only owner ( ) external returns ( uint ) { require ( state == state . finished ) ; require ( now >= end dates [ NUM_ ] ) ; if ( ico was successful ( ) ) { uint value = total invested [ NUM_ ] + total invested [ NUM_ ] ; msg . sender . transfer ( value ) ; get ethereum ( msg . sender , value ) ; return value ; } return NUM_ ; }
"
"function add invest info ico ( address _addr , uint256 _weis , uint256 _tokens ) private { if ( ico token holders [ _addr ] == NUM_ ) { ico token holders addresses . push ( _addr ) ; } ico token holders [ _addr ] = ico token holders [ _addr ] . add ( _tokens ) ; ico sold tokens = ico sold tokens . add ( _tokens ) ; if ( _weis > NUM_ ) { if ( ico investors [ _addr ] == NUM_ ) { ico investors addresses . push ( _addr ) ; } ico investors [ _addr ] = ico investors [ _addr ] . add ( _weis ) ; ico total collected = ico total collected . add ( _weis ) ; } }
"
"function test trade ( address token get , uint amount get , address token give , uint amount give , uint expires , uint nonce , address user , uint8 v , bytes32 r , bytes32 s , uint amount , address sender ) public constant returns ( bool ) { if ( ! ( tokens [ token get ] [ sender ] >= amount && available volume ( token get , amount get , token give , amount give , expires , nonce , user , v , r , s ) >= amount ) ) { return BOOL_ ; } else { return BOOL_ ; } }
"
"function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {
"
"function purchase ( uint256 _stock id , uint256 _share id ) public payable { require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ; }
"
"function calculate grant claim ( address _recipient ) public view returns ( uint16 , uint128 ) { grant storage token grant = token grants [ _recipient ] ; uint elapsed time = sub ( now , token grant . start time ) ; uint elapsed months = elapsed time / seconds_per_month ; if ( elapsed months < token grant . vesting cliff ) { return ( NUM_ , NUM_ ) ; } if ( elapsed months >= token grant . vesting duration ) { uint128 remaining grant = token grant . amount - token grant . total claimed ; return ( token grant . vesting duration , remaining grant ) ; } else { uint16 months vested = uint16 ( sub ( elapsed months , token grant . months claimed ) ) ; uint amount vested per month = token grant . amount / token grant . vesting duration ; uint128 amount vested = uint128 ( mul ( months vested , amount vested per month ) ) ; return ( months vested , amount vested ) ; } }
"
"function to byte ( uint8 _base ) public returns ( byte _ret ) { assembly { let m_alloc : = add ( msize ( ) , NUM_ ) mstore8 ( m_alloc , _base ) _ret : = mload ( m_alloc ) } }
"
"function transfer ( address _to , uint256 _value ) external { _transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value ) ; }
"
"function send tokens to investors ( address _investor , uint _tokens ) only owner returns ( bool ok ) { require ( balances [ contract address ] >= _tokens ) ; on sale tokens = safe sub ( on sale tokens , _tokens ) ; balances [ contract address ] = safe sub ( balances [ contract address ] , _tokens ) ; balances [ _investor ] = safe add ( balances [ _investor ] , _tokens ) ; return BOOL_ ; }
"
"function transfer from ( address _from , address _to , uint _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value >= NUM_ && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; balances [ _to ] += _value ; transfer ( _from , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function launch rocket ( uint32 competition_id , uint32 rocket_id , uint32 launch_thrust , uint32 fuel_to_use , uint32 fuel_allocation_for_launch , uint32 stabilizer_setting ) payable not while paused ( ) public { game common . launch rocket stack frame memory stack ; stack . m_rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , rocket_id ) ) ; stack . m_mission = mission parameters types . deserialize mission parameters ( m_database . load ( null address , mission parameters category , competition_id ) ) ; stack . m_ownership = ownership types . deserialize ownership ( m_database . load ( null address , ownership category , rocket_id ) ) ; require ( stack . m_mission . m_is started == NUM_ ) ; require ( stack . m_rocket . m_version > NUM_ ) ; require ( stack . m_rocket . m_is for sale == NUM_ ) ; require ( msg . value == uint256 ( stack . m_mission . m_launch cost ) ) ; require ( stack . m_ownership . m_owner == msg . sender ) ; require ( launch_thrust <= stack . m_rocket . m_thrust ) ; stack . m_mission wind speed = stack .
"
"function get ark data ( uint256 _token id ) external view returns ( address _owner , uint256 _price , uint256 _next price , uint256 _mate , address _birther , uint8 _gender , uint256 _baby , uint256 _baby price ) { animal memory animal = ark data [ _token id ] ; uint256 baby ; if ( animal . gender == NUM_ ) baby = babies [ _token id ] ; else baby = babies [ mates [ _token id ] ] ; return ( animal . owner , animal . price , get next price ( animal . price ) , mates [ _token id ] , animal . birther , animal . gender , baby , baby makin price [ baby ] ) ; }
"
"function get channel info ( address _sender_address , address _receiver_address , uint32 _open_block_number ) external constant returns ( bytes32 , uint192 , uint32 , uint192 ) { bytes32 key = get key ( _sender_address , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > NUM_ ) ; return ( key , channels [ key ] . deposit , closing_requests [ key ] . settle_block_number , closing_requests [ key ] . closing_balance ) ; }
"
"function token transfer ( address _to , uint _value ) only owner public { _transfer ( this , _to , _value ) ; }
"
"function balance of ( address _account ) constant returns ( uint balance ) { return balances [ _account ] ; }
"
"function claim token reserve finan ( ) only token reserve finance locked public { address reserve wallet = msg . sender ; require ( block . timestamp > time locks [ reserve wallet ] ) ; uint256 vesting stage = finan vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( NUM_ * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ) ; require ( total unlocked <= allocations [ finan reserve wallet ] ) ; require ( claimed [ finan reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ finan reserve wallet ] ) ; claimed [ finan reserve wallet ] = total unlocked ; require ( token . transfer ( reserve wallet , payment ) ) ; distributed ( reserve wallet , payment ) ; }
"
"function get price ( ) public view returns ( uint256 ) { return NUM_ ; }
"
"function leave token group and withdraw balance ( uint256 _token id ) external when not paused { address user add = msg . sender ; var group = token index to group [ _token id ] ; var contributor = user address to contributor [ user add ] ; require ( _address not null ( user add ) ) ; require ( group . exists ) ; require ( group . purchase price == NUM_ ) ; require ( group . address to contributor arr index [ user add ] > NUM_ ) ; require ( contributor . token id to group arr index [ _token id ] > NUM_ ) ; uint refund balance = _clear contributor record in group ( _token id , user add ) ; _clear group record in contributor ( _token id , user add ) ; user address to contributor [ user add ] . withdrawable balance += refund balance ; funds deposited ( user add , refund balance ) ; _withdraw user funds ( user add ) ; leave group ( _token id , user add , token index to group [ _token id ] . contributed balance , refund balance ) ;
"
"function set doge ( address _new doge ) public only doge { require ( _new doge != address ( NUM_ ) ) ; doge address = _new doge ; }
"
"function change owner ( address _new owner ) only owner public { require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }
"
"modifier can set crowdfund contract ( ) { require ( crowdfund contract == address ( NUM_ ) ) ; _ ; }
"
"function set approval for all ( address _to , bool _approved ) public { require ( _to != msg . sender ) ; operator approvals [ msg . sender ] [ _to ] = _approved ; emit approval for all ( msg . sender , _to , _approved ) ; }
"
"function safe withdrawal ( ) external crowdsale ended { if ( ! funding goal reached ) { uint256 amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( funding goal reached && owner == msg . sender ) { if ( beneficiary . send ( amount raised ) ) { fund transfer ( beneficiary , amount raised , BOOL_ ) ; } else { funding goal reached = BOOL_ ; } } }
"
"function start sale ( ) public only owner { assert ( start block == NUM_ ) ; start block = now ; crowd sale type = NUM_ ; crowdsale status = NUM_ ; end block = now . add ( duration crowd sale ) ; state changed ( BOOL_ ) ; }
"
"function refund non compliant ( address _contributor ) payable external only owner ( ) { backer storage backer = backers [ _contributor ] ; require ( ! backer . claimed ) ; require ( ! backer . refunded ) ; backer . refunded = BOOL_ ; uint total ether received = backer . wei received one + backer . wei received two + backer . wei received main ; require ( msg . value == total ether received ) ; assert ( total ether received > NUM_ ) ; eth received presale one -= backer . wei received one ; eth received presale two -= backer . wei received two ; eth receive main sale -= backer . wei received main ; total refunded += total ether received ; refund count ++ ; refunded [ _contributor ] = total refunded ; uint tokens to send = ( dollar per ether ratio * backer . wei received one ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received two ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer .
"
"function change total supply ( uint256 new supply ) public only owner returns ( bool success ) { require ( new supply >= NUM_ && ( new supply >= _total supply || _total supply - new supply <= balances [ owner ] ) ) ; uint256 diff = NUM_ ; if ( new supply >= _total supply ) { diff = new supply . sub ( _total supply ) ; balances [ owner ] = balances [ owner ] . add ( diff ) ; emit transfer ( address ( NUM_ ) , owner , diff ) ; } else { diff = _total supply . sub ( new supply ) ; balances [ owner ] = balances [ owner ] . sub ( diff ) ; emit transfer ( owner , address ( NUM_ ) , diff ) ; } _total supply = new supply ; return BOOL_ ; }
"
"function withdraw ( uint amount ) only owner external { if ( this . balance <= obligations ) { throw ; selfdestruct ( owner ) ; } if ( ( this . balance - obligations ) <= amount ) { throw ; } owner . transfer ( amount ) ; }
"
"function get rate ( ) public view returns ( uint256 ) { if ( block . timestamp <= start time ) { return ( ( rate / NUM_ ) * NUM_ ) ; } if ( block . timestamp <= start time . add ( NUM_ days ) ) { return ( ( rate / NUM_ ) * NUM_ ) ; } return rate ; }
"
"function burn ( uint256 _amount ) public only owner { require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; }
"
"function sell ( uint quantity , uint min sale return ) public { uint amount in wei = formula contract . calculate sale return ( ( token contract . total supply ( ) / multiplier ) - token contract . balance of ( this ) , address ( this ) . balance , weight , quantity ) ; amount in wei = ( amount in wei - ( amount in wei * ( fee / NUM_ ) ) ) ; require ( enabled ) ; require ( amount in wei >= min sale return ) ; require ( amount in wei <= address ( this ) . balance ) ; require ( token contract . transfer from ( msg . sender , this , quantity ) ) ; emit sell ( msg . sender , quantity , amount in wei ) ; msg . sender . transfer ( amount in wei ) ; }
"
"function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , uint64 ( _token id ) ) ) ; _transfer ( msg . sender , _to , _token id ) ; }
"
"function calculate scorers for team ids ( uint home team id , uint away team id ) internal view returns ( uint [ ] , uint [ ] ) { var ( home totals , home cards shooting attributes ) = calculate attribute totals ( home team id ) ; var ( away totals , away cards shooting attributes ) = calculate attribute totals ( away team id ) ; uint start seed = now ; var ( home goals , away goals ) = calculate goals from attribute totals ( home team id , away team id , home totals , away totals , start seed ) ; uint [ ] memory home scorers = new uint [ ] ( home goals ) ; uint [ ] memory away scorers = new uint [ ] ( away goals ) ; for ( uint i = NUM_ ; i < home scorers . length ; i ++ ) { home scorers [ i ] = determine goal scoring card ids ( teams [ home team id ] . card ids , home cards shooting attributes , i ) ; } for ( i = NUM_ ; i < away scorers
"
"function is crowdsale ( ) public constant returns ( bool ) { return BOOL_ ; }
"
"function _transfer ( address _from , address _to , uint _value ) private returns ( bool success ) { require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) public trading open returns ( bool ) { return super . transfer ( _to , _value ) ; }
"
"function balance of ( address token owner ) public constant returns ( uint balance ) { return balances [ token owner ] ; }
"
"function create subscription offer ( uint _price per hour , uint16 _xrate provider id , uint _charge period , uint _expire on , uint _offer limit , uint _deposit amount , uint _start on , bytes _descriptor ) public no reentrancy ( l01 ) only registered provider not suspended returns ( uint sub id ) { assert ( _start on < _expire on ) ; assert ( _charge period <= NUM_ years ) ; var ( _xrate_n , _xrate_d ) = _xrate provider id == NUM_ ? ( NUM_ , NUM_ ) : xrate provider ( xrate providers [ _xrate provider id ] ) . get rate ( ) ; assert ( _xrate_n > NUM_ && _xrate_d > NUM_ ) ; subscriptions [ ++ subscription counter ] = subscription ( { transfer from : NUM_ , transfer to : msg . sender , price per hour : _price per hour , xrate provider id : _xrate provider id , initial xrate_n : _xrate_n , initial xrate_d : _xrate_d , paid until : NUM_ , charge period : _charge period , deposit amount : _deposit amount , start on : _start on , expire on : _expire on , exec counter
"
"function update ethprice in cents public payable if update request expired new oraclize query oraclize request fail previous one still pending else if oraclize get price url this balance new oraclize query oraclize request fail not enough ether else oraclize query m ethprice update interval url json https m callback gas m ethprice last update request get time new oraclize query oraclize query was sent
"
"function add many to allocation list ( address [ ] users , uint256 [ ] amounts ) external only owner at round ( sale rounds . early investment ) { require ( users . length == amounts . length ) ; for ( uint32 i = NUM_ ; i < users . length ; i ++ ) { add to allocation list ( users [ i ] , amounts [ i ] ) ; } }
"
"function redemption info ( address _who , uint64 _index ) public constant returns ( uint64 redemption id , uint8 reason , uint value ) { require ( _who != address ( NUM_ ) ) ; require ( _index < token redemptions [ _who ] . length ) ; redemption id = token redemptions [ _who ] [ _index ] . redemption id ; reason = uint8 ( token redemptions [ _who ] [ _index ] . reason ) ; value = token redemptions [ _who ] [ _index ] . value ; }
"
"function buy tokens ( address beneficiary ) private { require ( beneficiary != NUM_ ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 discount = ( ( to be raised * NUM_ ) / hard_cap ) * NUM_ ; uint256 tokens ; wei raised = wei raised . add ( wei amount ) ; to be raised = to be raised . sub ( wei amount ) ; uint commission ; uint extra ; uint premium ; if ( register . approved ( beneficiary ) ) { ( commission , extra ) = register . get bonuses ( beneficiary ) ; if ( extra > NUM_ ) { discount += extra * NUM_ ; } tokens = how many ( msg . value , discount ) ; if ( commission > NUM_ ) { premium = tokens . mul ( commission ) . div ( NUM_ ) ; token . mint ( bounty , premium ) ; } } else { extra = register2 . get bonuses ( beneficiary ) ; if ( extra > NUM_ ) { discount = extra * NUM_ ; tokens = how many ( msg
"
"function remove jingle ( address _owner , uint _jingle id ) internal { uint length = tokens owned [ _owner ] . length ; uint index = token pos in arr [ _jingle id ] ; uint swap token = tokens owned [ _owner ] [ length - NUM_ ] ; tokens owned [ _owner ] [ index ] = swap token ; token pos in arr [ swap token ] = index ; delete tokens owned [ _owner ] [ length - NUM_ ] ; tokens owned [ _owner ] . length -- ; }
"
"function sell card ( uint8 card id , uint price ) public only valid card ( card id ) only card owner ( card id ) returns ( bool success ) { card details structs [ card id ] . price = price ; card details structs [ card id ] . available buy = BOOL_ ; return BOOL_ ; }
"
"function set minter ( address _minter ) external only minter { require ( _minter != NUM_ ) ; minter = _minter ; }
"
"function destroy ( address [ ] _tokens ) public only owner { for ( uint256 i = NUM_ ; i < _tokens . length ; i ++ ) { erc20 basic token = erc20 basic ( _tokens [ i ] ) ; uint256 balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }
"
"function disable mini swap lock ( ) only from mini wallet external { token swap lock = BOOL_ ; token swap over ( ) ; }
"
"function set investor data ( address _addr , uint _wei amount , uint _token amount , uint _original tx hash ) only owner public { if ( invested amount of [ _addr ] == NUM_ ) { investor count ++ ; } invested amount of [ _addr ] += _wei amount ; token amount of [ _addr ] += _token amount ; wei raised += _wei amount ; tokens sold += _token amount ; invested ( _addr , _wei amount , _token amount , NUM_ ) ; restored investment ( _addr , _original tx hash ) ; }
"
"function change ownership ( bytes32 _symbol , address _new owner ) public only owner ( _symbol ) returns ( uint ) { if ( _new owner == NUM_ ) { return _error ( atx_platform_invalid_new_owner ) ; } asset storage asset = assets [ _symbol ] ; uint new owner id = _create holder id ( _new owner ) ; if ( asset . owner == new owner id ) { return _error ( atx_platform_cannot_apply_to_oneself ) ; } address old owner = _address ( asset . owner ) ; asset . owner = new owner id ; emitter ( events history ) . emit ownership change ( old owner , _new owner , _symbol ) ; return ok ; }
"
"function buy ( ) payable only not owner valid original buy price on sale public returns ( uint256 amount ) { uint requested units = msg . value / _original buy price ; if ( requested units > _ico supply ) { revert ( ) ; } uint actual sold units = NUM_ ; if ( requested units < bonus remain ) { actual sold units = requested units + ( ( requested units * bonus ratio ) / NUM_ ) ; _ico supply -= requested units ; bonus remain -= requested units ; } else { actual sold units = requested units + ( bonus remain * bonus ratio ) / NUM_ ; _ico supply -= requested units ; bonus remain = NUM_ ; } balances [ owner ] -= actual sold units ; balances [ msg . sender ] += actual sold units ; owner . transfer ( msg . value ) ; transfer ( owner , msg . sender , actual sold units ) ; return actual sold units ; }
"
"function unlock10 percent tokens in batch ( ) public only owner is close returns ( bool ) { for ( uint8 i = NUM_ ; i < investors . length ; i ++ ) { if ( left release times [ investors [ i ] ] > NUM_ ) { uint released tokens = locked tokens [ investors [ i ] ] / left release times [ investors [ i ] ] ; shares chain token . mint token ( investors [ i ] , released tokens ) ; locked tokens [ investors [ i ] ] = locked tokens [ investors [ i ] ] - released tokens ; left release times [ investors [ i ] ] = left release times [ investors [ i ] ] - NUM_ ; } } return BOOL_ ; }
"
"function pass turn ( uint board id ) external { go board storage board = all boards [ board id ] ; player color active color = get player color ( board , msg . sender ) ; require ( board . status == board status . in progress && board . next turn color == active color ) ; if ( update player time ( board , board id , active color ) ) { if ( board . did pass prev turn ) { board . is honorable loss = BOOL_ ; update board status ( board , board id , board status . waiting to resolve ) ; } else { next turn ( board ) ; board . did pass prev turn = BOOL_ ; player passed turn ( board id , active color ) ; } } }
"
"function trigger payout ( ) public only bookie level { ping oracle ( NUM_ ) ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function add hashes ( uint _sadd ) public returns ( uint ) { require ( hash first == NUM_ && _sadd > NUM_ && _sadd <= hashes size ) ; uint n = hashes . length ; if ( n + _sadd > hashes size ) { hashes . length = hashes size ; } else { hashes . length += _sadd ; } for ( ; n < hashes . length ; n ++ ) { hashes [ n ] = NUM_ ; } if ( hashes . length >= hashes size ) { hash first = block . number - ( block . number % NUM_ ) ; hash last = hash first ; } return ( hashes . length ) ; }
"
"function process season ( uint32 _season ) public only coo { uint64 fight time = match time [ _season ] ; require ( now >= fight time && fight time > NUM_ ) ; uint sum fund = NUM_ ; uint sum seed = NUM_ ; ( sum fund , sum seed ) = _get fight data ( _season ) ; if ( sum fund == NUM_ ) { finished [ _season ] = NUM_ ; do log fighter ( _season , NUM_ , NUM_ ) ; emit season none ( _season ) ; emit log match ( _season , sum fund , fight time , sum seed , NUM_ , NUM_ , NUM_ , BOOL_ ) ; } else { uint8 champion = _local fight ( _season , uint32 ( sum seed ) ) ; uint percentile = safe div ( sum fund , NUM_ ) ; uint dev cut = percentile * NUM_ ; uint partner cut = percentile * NUM_ ; uint fighter cut = percentile * NUM_ ; uint bonus winner = percentile * NUM_ ; _bonus to partners ( partner cut ) ; _bonus to fighters ( _season , champion , fighter cut ) ;
"
"function self destruct ( ) only owner { selfdestruct ( owner ) ; }
"
"function update fee amount ( uint _new fee ) public { require ( msg . sender == owner ) ; require ( ( _new fee >= NUM_ ) && ( _new fee <= NUM_ ) ) ; fees = _new fee * NUM_ ; }
"
"function set token contract address ( address _token contract address ) admin only { if ( token contract defined ) throw ; token = token ( _token contract address ) ; token contract defined = BOOL_ ; }
"
"function invest ( uint256 option number ) public payable { assert ( option number <= NUM_ ) ; uint256 amount = round it ( msg . value ) ; assert ( amount >= minimum stake ) ; if ( now > session end time ) { end session ( ) ; option number = current lowest ; } uint256 holding = player portfolio [ msg . sender ] [ option number ] ; holding = safe math . add ( holding , amount ) ; player portfolio [ msg . sender ] [ option number ] = holding ; market options [ option number ] = safe math . add ( market options [ option number ] , amount ) ; number of investments += NUM_ ; total invested += amount ; if ( ! active players [ msg . sender ] ) { insert player ( msg . sender ) ; active players [ msg . sender ] = BOOL_ ; } invest ( msg . sender , option number , amount , market options , block . number ) ; update play count ( ) ; current lowest = find current lowest ( ) ; }
"
"function set hover text ( uint256 [ NUM_ ] text ) public { pxl property . set owner hover text ( msg . sender , text ) ; set user hover text ( msg . sender , text ) ; }
"
"function multi transfer ( address [ ] _addresses , uint256 [ ] amounts ) public returns ( bool success ) { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { transfer ( _addresses [ i ] , amounts [ i ] ) ; } return BOOL_ ; }
"
"function mark as scam ( address scammer ) payable has minimum amount to flag { uint256 number of tokens = div ( msg . value , price per unit ) ; update flag count ( msg . sender , scammer , number of tokens ) ; uint256 owners fee = div ( mul ( msg . value , contract fee percentage ) , NUM_ ) ; uint256 insurance = msg . value - owners fee ; owner . transfer ( owners fee ) ; flagger insurance [ msg . sender ] [ scammer ] += insurance ; contracts insurance fee [ msg . sender ] [ scammer ] += owners fee ; the scam seal token . transfer ( scammer , number of tokens ) ; uint256 q = mul ( relief ratio , mul ( msg . value , price per unit ) ) ; marked as scam ( scammer , msg . sender , q ) ; }
"
"function change gas price limit ( uint256 _gas price limit ) only owner ( ) public { gas price limit = _gas price limit ; emit gas price limit changed ( _gas price limit ) ; }
"
"function transfer from ( address _from , address _to , uint256 _token id ) external can transfer ( _token id ) valid nftoken ( _token id ) { address token owner = id to owner [ _token id ] ; require ( token owner == _from ) ; require ( _to != address ( NUM_ ) ) ; _transfer ( _to , _token id ) ; }
"
"function is ico ( uint _time ) public view returns ( bool ) { if ( _time == NUM_ ) { _time = now ; } if ( ico_start < _time && _time <= ico_finish ) { return BOOL_ ; } return BOOL_ ; }
"
"function cancel payment ( uint64 id pledge , uint amount ) only vault { pledge storage p = find pledge ( id pledge ) ; require ( p . pledge state == pledge state . paying ) ; uint64 old pledge = find or create pledge ( p . owner , p . delegation chain , NUM_ , NUM_ , p . old pledge , pledge state . pledged ) ; old pledge = normalize pledge ( old pledge ) ; do transfer ( id pledge , old pledge , amount ) ; }
"
"function add vesting user ( address user , uint256 amount ) public only owner pre init state { uint256 old amount = owners map [ user ] ; owners map [ user ] = amount ; owners map first period [ user ] = amount / NUM_ ; owners map second period [ user ] = amount / NUM_ ; owners map third period [ user ] = amount - owners map first period [ user ] - owners map second period [ user ] ; original address traker [ user ] = user ; change address attempts [ user ] = NUM_ ; total committed += ( amount - old amount ) ; add user ( user , amount ) ; }
"
"function _request exists ( address transactee , uint32 deposit ) internal returns ( bool ) { return _requests [ transactee ] [ deposit ] != NUM_ ; }
"
"function add to white list ( address [ ] addresses , uint256 wei per contributor ) public only owner { for ( uint32 i = NUM_ ; i < addresses . length ; i ++ ) { white list [ addresses [ i ] ] = white list record ( wei per contributor , NUM_ ) ; } }
"
"function add hodler stake ( address _beneficiary , uint256 _stake ) public only owner before hodl start { if ( _stake == NUM_ || _beneficiary == address ( NUM_ ) ) return ; if ( hodler stakes [ _beneficiary ] . stake == NUM_ ) hodler total count = hodler total count . add ( NUM_ ) ; hodler stakes [ _beneficiary ] . stake = hodler stakes [ _beneficiary ] . stake . add ( _stake ) ; hodler total value = hodler total value . add ( _stake ) ; log hodl set stake ( msg . sender , _beneficiary , hodler stakes [ _beneficiary ] . stake ) ; }
"
"function get player bet info ( address addr ) view public returns ( uint , uint ) { return ( player info [ addr ] . choice , player info [ addr ] . bet amount ) ; }
"
"function transfer proxy address from address to uint256 value uint256 fee uint8 v bytes32 r bytes32 s when not paused require balances from fee add value require balances to add value balances to require balances msg sender add fee balances msg sender uint256 nonce nonces from bytes32 hash keccak256 from to value fee nonce bytes memory prefix \x19 ethereum signed message \n32 bytes32 prefixed hash keccak256 prefix hash require from ecrecover prefixed hash v r s balances from balances from sub value add fee balances to balances to add value balances msg sender balances msg sender add fee nonces from nonce add 1 emit transfer from to value emit transfer from msg sender fee
"
"function transfer ( address _to , uint256 _value ) public { if ( balance of [ msg . sender ] < _value ) revert ( ) ; if ( balance of [ _to ] + _value < balance of [ _to ] ) revert ( ) ; uint256 avp = NUM_ ; uint256 amount = NUM_ ; if ( _to == address ( this ) ) { if ( last tx block num < ( block . number - NUM_ ) ) { avp = this . balance * NUM_ / total supply ; amount = ( _value * avp ) / NUM_ ; } else { amount = ( _value * redeem price ) / NUM_ ; } balance of [ msg . sender ] -= _value ; total supply -= _value ; if ( total supply != NUM_ ) { avp = ( this . balance - amount ) * NUM_ / total supply ; redeem price = ( avp * NUM_ ) / NUM_ ; token price = ( avp * NUM_ ) / NUM_ ; } else { redeem price = NUM_ ; token price = NUM_ ; } if ( ! msg . sender .
"
"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }
"
"function get indices with claimable tokens for buyers ( address auction sell token , address auction buy token , address user , uint last nauctions ) external view returns ( uint [ ] indices , uint [ ] users balances ) { uint running auction index = get auction index ( auction sell token , auction buy token ) ; uint array length ; uint starting index = last nauctions == NUM_ ? NUM_ : running auction index - last nauctions + NUM_ ; for ( uint j = starting index ; j <= running auction index ; j ++ ) { if ( buyer balances [ auction sell token ] [ auction buy token ] [ j ] [ user ] > NUM_ ) { array length ++ ; } } indices = new uint [ ] ( array length ) ; users balances = new uint [ ] ( array length ) ; uint k ; for ( uint i = starting index ; i <= running auction index ; i ++ ) { if ( buyer balances [ auction sell token ] [ auction buy token ] [ i ] [ user ] > NUM_ ) {
"
"function rent out multiple ( address _to , uint256 _rent period , uint256 [ ] _deed ids ) public when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; for ( uint256 i = NUM_ ; i < _deed ids . length ; i ++ ) { uint256 _deed id = _deed ids [ i ] ; require ( valid identifier ( _deed id ) ) ; require ( identifier to rent period end timestamp [ _deed id ] < now ) ; require ( _owns ( msg . sender , _deed id ) ) ; _rent out ( _to , _rent period , _deed id ) ; } }
"
"function signature drop single amount ( address [ ] _recipients , uint256 _amount ) external only admin valid balance ( _recipients , _amount ) { for ( uint256 i = NUM_ ; i < _recipients . length ; i ++ ) { address recipient = _recipients [ i ] ; if ( ! signaturedrops [ recipient ] ) { assert ( token . transfer ( recipient , _amount ) ) ; signaturedrops [ recipient ] = BOOL_ ; num drops = num drops . add ( NUM_ ) ; drop amount = drop amount . add ( _amount ) ; token drop ( recipient , _amount , STR_ ) ; } } }
"
"function transfer token ownership ( ) external only owner { token . transfer ownership ( owner ) ; }
"
"function transfer from ( address _from , address _to , uint256 _amount ) public only payload size ( NUM_ ) returns ( bool ) { if ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount > NUM_ && balances [ _to ] . add ( _amount ) > balances [ _to ] ) { balances [ _from ] = balances [ _from ] . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit transfer ( _from , _to , _amount ) ; return BOOL_ ; } return BOOL_ ; }
"
"function good_bye_world ( ) { if ( msg . sender != the_stupid_guy ) throw ; selfdestruct ( the_stupid_guy ) ; }
"
"function support component ( uint16 component_idx , uint256 value ) public never by owner ( ) returns ( bool success ) { if ( value == NUM_ ) revert ( ) ; if ( balance of [ msg . sender ] < value ) revert ( ) ; if ( component_idx >= component count ) revert ( ) ; var component = components [ component_idx ] ; if ( ( component . supported + value ) < component . supported ) revert ( ) ; if ( ( component . current support + int256 ( value ) ) < component . current support ) revert ( ) ; balance of [ msg . sender ] -= value ; component . current support += int256 ( value ) ; component . supported += value ; total supply -= value ; support component ( component_idx , msg . sender , value ) ; return BOOL_ ; }
"
"function set crowdsale transfer ( address _sale , uint256 _amount ) public only owner { require ( _sale != address ( NUM_ ) && ! is crowdsale open ( ) && address ( etheal token ) != address ( NUM_ ) ) ; crowdsale = crowdsale ( _sale ) ; require ( etheal token . transfer from ( sale , _sale , _amount ) ) ; }
"
"function total supply ( ) public constant returns ( uint256 ) { return total supply at ( block . number ) ; }
"
"function set source ( address a ) { if ( msg . sender != owner ) throw ; ark = ark ( a ) ; logs . push ( log ( owner , STR_ , a , NUM_ ) ) ; }
"
"function claim tokens ( address _token ) public only owner { require ( _token != address ( NUM_ ) ) ; erc20 token = erc20 ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; claimed tokens ( _token , owner , balance ) ; }
"
"function buy region ( uint _start_section_index , uint _end_section_index , uint _image_id , string _md5 ) payable returns ( uint start_section_y , uint start_section_x , uint end_section_y , uint end_section_x ) { if ( _end_section_index < _start_section_index ) throw ; if ( _start_section_index >= sections . length ) throw ; if ( _end_section_index >= sections . length ) throw ; var ( available , ext_price , ico_amount ) = region available ( _start_section_index , _end_section_index ) ; if ( ! available ) throw ; uint area_price = ico_amount * ipo_price ; area_price = area_price + ext_price ; area price ( _start_section_index , _end_section_index , area_price ) ; sent value ( msg . value ) ; if ( area_price > msg . value ) throw ; ico_amount = NUM_ ; ext_price = NUM_ ; start_section_x = _start_section_index % NUM_ ; end_section_x = _end_section_index % NUM_ ; start_section_y = _start_section_index - ( _start_section_index % NUM_ ) ; start_section_y = start_section_y / NUM_ ; end_section_y = _end_section_index - ( _end_section_index % NUM_ ) ; end_section_y = end_section_y / NUM_ ; uint x_pos = start_section_x ; while ( x_pos <= end_section_x ) { uint y_pos = start_section_y ; while ( y_pos <= end_section_y )
"
"function transfer from crowdfund ( address _to , uint256 _amount ) external only crowdfund non zero amount ( _amount ) non zero address ( _to ) returns ( bool success ) { require ( balance of ( crowdfund address ) >= _amount ) ; decrement balance ( crowdfund address , _amount ) ; add to balance ( _to , _amount ) ; transfer ( NUM_ , _to , _amount ) ; return BOOL_ ; }
"
"function get indices with claimable tokens for sellers ( address auction sell token , address auction buy token , address user , uint last nauctions ) external view returns ( uint [ ] indices , uint [ ] users balances ) { uint running auction index = get auction index ( auction sell token , auction buy token ) ; uint array length ; uint starting index = last nauctions == NUM_ ? NUM_ : running auction index - last nauctions + NUM_ ; for ( uint j = starting index ; j <= running auction index ; j ++ ) { if ( seller balances [ auction sell token ] [ auction buy token ] [ j ] [ user ] > NUM_ ) { array length ++ ; } } indices = new uint [ ] ( array length ) ; users balances = new uint [ ] ( array length ) ; uint k ; for ( uint i = starting index ; i <= running auction index ; i ++ ) { if ( seller balances [ auction sell token ] [ auction buy token ] [ i ] [ user ] > NUM_ ) {
"
"function create ( ) payable when not closed when not paused public returns ( bool success ) { require ( msg . value > NUM_ ) ; require ( now >= pre ico opening time ) ; uint256 wei to participate = msg . value ; adjust phase based on time ( ) ; if ( phase != phases . after ico || wei to participate < ( NUM_ * NUM_ * * NUM_ ) ) { rates memory rates = get rates ( ) ; uint256 new tokens = wei to participate . mul ( rates . total ) ; uint256 requested supply = total supply . add ( new tokens ) ; total supply = requested supply ; balances [ msg . sender ] = balances [ msg . sender ] . add ( wei to participate . mul ( rates . to sender ) ) ; balances [ owner ] = balances [ owner ] . add ( wei to participate . mul ( rates . to owner ) ) ; balances [ bounty ] = balances [ bounty ] . add ( wei to participate . mul ( rates . to bounty ) ) ; total
"
"function is current account minter ( address _address ) constant returns ( bool ) { return account minter addresses [ _address ] ; }
"
"function mint and freeze ( address _to , uint _amount , uint64 _until ) public only owner can mint returns ( bool ) { total supply_ = total supply_ . add ( _amount ) ; bytes32 current key = to key ( _to , _until ) ; freezings [ current key ] = freezings [ current key ] . add ( _amount ) ; freezing balance [ _to ] = freezing balance [ _to ] . add ( _amount ) ; freeze ( _to , _until ) ; emit mint ( _to , _amount ) ; emit freezed ( _to , _until , _amount ) ; emit transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }
"
"function get class info ( uint32 _class id ) external view returns ( string class name , uint8 class rank , uint8 class race , uint32 class age , uint8 class type , uint32 max level , uint8 aura , uint32 [ NUM_ ] base stats , uint32 [ NUM_ ] min ivs , uint32 [ NUM_ ] max ivs ) { var _cl = hero classes [ _class id ] ; return ( _cl . class name , _cl . class rank , _cl . class race , _cl . class age , _cl . class type , _cl . max level , _cl . aura , _cl . base stats , _cl . min ivfor stats , _cl . max ivfor stats ) ; }
"
"function sign buyer ( uint _deal number ) public payable { uint deal = deal numbers [ _deal number ] ; require ( signs [ deal ] . sign buyer == NUM_ && msg . sender == deals [ deal ] . buyer ) ; require ( signs [ deal ] . sign seller == deals [ deal ] . seller ) ; require ( deals [ deal ] . sum == msg . value ) ; signs [ deal ] . sign buyer = msg . sender ; deals [ deal ] . balance = msg . value ; deals [ deal ] . status = statuses . signed ; }
"
"function transfer eth ( ) is owner external { require ( this . balance > NUM_ ) ; require ( eth fund deposit . send ( this . balance ) ) ; }
"
"function withdraw ( ) public only owner returns ( bool result ) { return owner . send ( this . balance ) ; }
"
"function delete minter ( address _who ) public only owner returns ( bool ) { _set minter ( _who , BOOL_ ) ; }
"
"function update reward rate ( address token address , uint new reward rate ) public only owner { require ( new reward rate > NUM_ ) ; require ( token address != address ( NUM_ ) ) ; for ( uint i = NUM_ ; i < reward sources . length ; i ++ ) { if ( reward sources [ i ] . reward token address == token address ) { reward sources [ i ] . reward rate = uint96 ( new reward rate ) ; return ; } } }
"
"function collect token ( ) public not paused only withdrawer { uint _time = time ( ) ; require ( _time > reward start time ) ; var _key = key ; uint balance = _key . balance of ( address ( this ) ) ; uint total = add ( collected tokens , balance ) ; uint remaining tokens = total ; uint year count = year for ( _time ) ; for ( uint i = NUM_ ; i < year count ; i ++ ) { remaining tokens = div ( mul ( remaining tokens , NUM_ - yearly reward percentage ) , NUM_ ) ; } total reward this year = div ( mul ( remaining tokens , yearly reward percentage ) , NUM_ ) ; uint can extract this year = div ( mul ( total reward this year , ( _time - reward start time ) % NUM_ days ) , NUM_ days ) ; uint can extract = can extract this year + ( total - remaining tokens ) ; can extract = sub ( can extract , collected tokens ) ; if ( can extract > balance ) { can extract =
"
"function check bet value ( ) private returns ( uint256 player bet value ) { update max bet ( ) ; if ( msg . value > current max gamble ) { msg . sender . send ( msg . value - current max gamble ) ; player bet value = current max gamble ; } else { player bet value = msg . value ; } }
"
"function has ended ico ( ) internal constant returns ( bool ) { return now > end time ico ; }
"
"function price ( ) constant returns ( uint256 ) { if ( total supply < level one token num ) return NUM_ ; if ( total supply >= level one token num && total supply < level two token num ) return NUM_ ; if ( total supply >= level two token num && total supply < level three token num ) return NUM_ ; if ( total supply >= level three token num && total supply < level four token num ) return NUM_ ; if ( total supply >= level four token num ) return NUM_ ; return NUM_ ; }
"
"function purchase ( uint256 _stock id , uint256 _share id ) public payable { require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ; }
"
"function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; car index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete car index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }
"
"function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block
"
"function buy tokens ( address _addr ) public payable when not paused { require ( now <= end time && _addr != NUM_ ) ; require ( lmda . balance of ( address ( this ) ) > NUM_ ) ; if ( state of ico == state of ico . pre && tokens sold >= token cap for pre ico ) { revert ( ) ; } else if ( state of ico == state of ico . main && tokens sold >= token cap for main ico ) { revert ( ) ; } uint256 to transfer = msg . value . mul ( get rate ( ) . mul ( get bonus ( ) ) ) . div ( NUM_ ) . add ( get rate ( ) ) ; lmda . transfer ( _addr , to transfer ) ; tokens sold = tokens sold . add ( to transfer ) ; investment of [ msg . sender ] = investment of [ msg . sender ] . add ( msg . value ) ; token purchased ( _addr , to transfer ) ; forward funds ( ) ; }
"
"function __callback ( bytes32 _query id , string _result , bytes _proof ) public { require ( msg . sender == oraclize_cb address ( ) ) ; if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) == NUM_ ) { require ( ! ticket pool [ _query id ] . is play ) ; uint game_result = NUM_ ; uint [ ] memory random result = new uint [ ] ( NUM_ ) ; random result [ NUM_ ] = uint ( keccak256 ( STR_ , block . blockhash ( block . number ) , _result , block . blockhash ( block . number - NUM_ ) , block . timestamp , block . coinbase ) ) % NUM_ + NUM_ ; random result [ NUM_ ] = uint ( keccak256 ( block . blockhash ( block . number - NUM_ ) , block . blockhash ( block . number ) , _result , block . coinbase , STR_ , block . timestamp ) ) % NUM_ + NUM_ ; random result [ NUM_ ] = uint ( keccak256 ( block . coinbase , _result , block . blockhash ( block . number ) ,
"
"function enter bid for gan token ( uint256 token id ) external payable { bid memory existing = token bids [ token id ] ; require ( token id to owner [ token id ] != msg . sender ) ; require ( token id to owner [ token id ] != NUM_ ) ; require ( msg . value > existing . value ) ; if ( existing . value > NUM_ ) { pending withdrawals [ existing . bidder ] += existing . value ; } token bids [ token id ] = bid ( BOOL_ , token id , msg . sender , msg . value ) ; emit bid for gan token offered ( token id , msg . value , msg . sender ) ; }
"
"function get all template proposals ( address _security token address ) view public returns ( address [ ] ) { return template proposals [ _security token address ] ; }
"
"function finis game ( ) public only owner { require ( is in game == BOOL_ ) ; is in game = BOOL_ ; finish time = NUM_ ; uint winner id = _rand ( NUM_ , NUM_ ) ; last winner id = winner id ; address winner address = pixel to owner [ winner id ] ; last winner address = winner address ; _send winner jackpot ( winner address ) ; delete pixels ; }
"
"function set_deposit_fee ( uint256 new_fee ) { if ( msg . sender == thebank ) { deposit_fee = new_fee ; } }
"
"function press ( uint _count presses , uint _aff id ) public payable { require ( _count presses >= NUM_ ) ; require ( msg . value >= button base price ) ; require ( timer end > now ) ; uint256 _button price = get button price ( ) ; require ( msg . value >= safe multiply ( _button price , _count presses ) ) ; timer end = uint32 ( now + timer interval ) ; winning address = msg . sender ; uint256 two percent com = ( msg . value / NUM_ ) * NUM_ ; uint256 ten percent com = msg . value / NUM_ ; uint256 fifteen percent com = ( msg . value / NUM_ ) * NUM_ ; if ( _aff id > NUM_ && _aff id < players . length ) { players [ _aff id ] . player address . transfer ( ten percent com ) ; } uint [ ] memory main investors = get main investor ( ) ; uint main investor = main investors [ NUM_ ] ; players [ main investor ] . player address . transfer ( fifteen percent com ) ; count investor
"
"function unlist qualified partner ( address _qualified partner ) external only owner { assert ( qualified partners [ _qualified partner ] . bona fide ) ; qualified partners [ _qualified partner ] . bona fide = BOOL_ ; }
"
"function transfer pre signed bulk ( address [ ] _from , address [ ] _to , uint256 [ ] _values , uint256 [ ] _fees , uint256 [ ] _nonces , uint8 [ ] _v , bytes32 [ ] _r , bytes32 [ ] _s ) public returns ( bool ) { require ( _from . length == _to . length && _to . length == _values . length && _values . length == _fees . length && _fees . length == _nonces . length && _nonces . length == _v . length && _v . length == _r . length && _r . length == _s . length ) ; for ( uint i ; i < _from . length ; i ++ ) { transfer pre signed ( _from [ i ] , _to [ i ] , _values [ i ] , _fees [ i ] , _nonces [ i ] , _v [ i ] , _r [ i ] , _s [ i ] ) ; } return BOOL_ ; }
"
"function revoke manager permission ( address _manager , string _permission name ) external only owner only valid manager address ( _manager ) only valid permission name ( _permission name ) { require ( manager permissions [ _manager ] [ _permission name ] == BOOL_ ) ; manager permissions [ _manager ] [ _permission name ] = BOOL_ ; manager permission revoked event ( _manager , _permission name ) ; }
"
"function arb yes ( uint _lock id , address _who , uint _payment , string _data info , uint _version ) only arbiter { escrow info info = escrows [ _lock id ] ; if ( info . locked funds == NUM_ ) { log debug ( STR_ ) ; return ; } if ( info . frozen funds == NUM_ ) { log debug ( STR_ ) ; return ; } if ( _who != seller && _who != info . buyer ) { log debug ( STR_ ) ; return ; } if ( ! info . buyer no || ! info . seller no ) { log debug ( STR_ ) ; return ; } if ( _payment > info . locked funds ) { log debug ( STR_ ) ; return ; } if ( _payment > this . balance ) { log debug ( STR_ ) ; return ; } uint reward = ( info . locked funds * reward promille ) / NUM_ ; if ( reward > ( info . locked funds - _payment ) ) { log debug ( STR_ ) ; return ; } safe send ( _who , _payment )
"
"function finalize crowdsale ( ) external view { contract . authorize ( msg . sender ) ; contract . checks ( only admin and not final ) ; manage sale . finalize crowdsale ( ) ; contract . checks ( emit and store ) ; contract . commit ( ) ; }
"
"function get referral bonus ( uint256 value ) view public returns ( uint256 ) { return value . mul ( base rate ) . mul ( referral bonus percent ) . div ( percent_divider ) ; }
"
"modifier only while open { require ( block . timestamp >= opening time && block . timestamp <= closing time ) ; _ ; }
"
"function set value ( values [ ] storage values , uint256 value ) internal { uint256 current snapshot id = m current snapshot id ( ) ; bool empty = values . length == NUM_ ; if ( empty ) { values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; return ; } uint256 last = values . length - NUM_ ; bool has new snapshot = values [ last ] . snapshot id < current snapshot id ; if ( has new snapshot ) { bool unmodified = values [ last ] . value == value ; if ( unmodified ) { return ; } values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; } else { bool previous unmodified = last > NUM_ && values [ last - NUM_ ] . value == value ; if ( previous unmodified ) { delete values [ last ] ; values . length -- ; return ; } values [ last ] . value = value ; } }
"
"function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,
"
"function token callback ( address _from , uint256 _value , bytes _data ) public { require ( msg . sender == address ( like ) ) ; uint [ ] memory result ; uint len ; assembly { len : = mload ( _data ) let c : = NUM_ result : = mload ( NUM_ ) for { let i : = NUM_ } lt ( i , len ) { i : = add ( i , NUM_ ) } { mstore ( add ( result , add ( i , NUM_ ) ) , mload ( add ( _data , add ( i , NUM_ ) ) ) ) c : = add ( c , NUM_ ) } mstore ( result , c ) mstore ( NUM_ , add ( result , add ( NUM_ , mul ( c , NUM_ ) ) ) ) } uint8 [ ] memory result2 = new uint8 [ ] ( result . length ) ; for ( uint16 j = NUM_ ; j < result . length ; j ++ ) { result2 [ j ] = uint8 ( result [ j ] ) ; } give artworks (
"
"function cards_blue_total ( ) constant returns ( uint ) { return cards_blue . length ; }
"
"function purchase ( uint256 _token id ) public payable is not contract ( msg . sender ) { require ( ! paused ) ; token storage token = tokens [ _token id ] ; uint256 price = token . price ; address old owner = token . owner ; require ( price > NUM_ ) ; require ( msg . value >= price ) ; require ( old owner != msg . sender ) ; uint256 price delta = price . sub ( token . last price ) ; uint256 pool cut = calculate pool cut ( price delta ) ; _update pools ( token . kind , pool cut ) ; uint256 fee = price . mul ( fee percentage ) . div ( NUM_ ) ; dev owed = dev owed . add ( fee ) ; uint256 taxes paid = _pay dividends and mayors ( token , price ) ; _shift previous owners ( token , msg . sender ) ; transfer token ( old owner , msg . sender , _token id ) ; uint256 final payout = price . sub ( fee ) . sub ( pool cut ) . sub ( taxes paid )
"
"function add contract ( string _contract name , address _address ) external only contract owner ( STR_ , msg . sender ) { bytes memory contract name bytes = bytes ( _contract name ) ; require ( contract name bytes . length != NUM_ ) ; require ( contracts [ _contract name ] == address ( NUM_ ) ) ; require ( _address != address ( NUM_ ) ) ; contracts [ _contract name ] = _address ; emit contract added ( _address , _contract name ) ; }
"
"function create stage ( stage storage storage self , uint8 _stage , uint256 _deadline , uint256 _price , uint256 _minimum , uint256 _cap ) internal { uint8 prev stage = _stage - NUM_ ; require ( self . stages [ prev stage ] . deadline < _deadline ) ; self . stages [ _stage ] . deadline = _deadline ; self . stages [ _stage ] . token price = _price ; self . stages [ _stage ] . tokens sold = NUM_ ; self . stages [ _stage ] . minimum buy = _minimum ; self . stages [ _stage ] . cap = _cap ; self . stage count = self . stage count + NUM_ ; }
"
"function set new manager ( address _address ) external only owner { require ( _address != address ( NUM_ ) && manager != address ( NUM_ ) ) ; new manager = _address ; }
"
"function update instance ( bytes32 _app_name , bytes32 _current_version , bytes32 _registry_id ) external view { contract . authorize ( msg . sender ) ; require ( _app_name != NUM_ && _current_version != NUM_ && _registry_id != NUM_ , STR_ ) ; bytes4 [ ] memory current_selectors = get version selectors ( _app_name , _current_version , _registry_id ) ; require ( current_selectors . length != NUM_ , STR_ ) ; bytes32 latest_version = get latest version ( _app_name , _registry_id ) ; require ( latest_version != _current_version , STR_ ) ; require ( latest_version != NUM_ , STR_ ) ; address latest_idx = get version index ( _app_name , latest_version , _registry_id ) ; bytes4 [ ] memory latest_selectors = get version selectors ( _app_name , latest_version , _registry_id ) ; address [ ] memory latest_impl = get version implementations ( _app_name , latest_version , _registry_id ) ; require ( latest_idx != NUM_ , STR_ ) ; require ( latest_selectors . length != NUM_ && latest_selectors . length == latest_impl . length , STR_ ) ; contract . storing ( ) ; for ( uint i = NUM_ ; i < current_selectors . length ; i ++ ) contract . set ( app selectors ( current_selectors [ i ] ) ) . to ( address ( NUM_ ) ) ; contract . set ( app index ( ) ) . to ( latest_idx ) ; for ( i = NUM_ ; i < latest_selectors . length ; i ++ ) { require ( latest_selectors [ i ] != NUM_ && latest_impl [ i ] != NUM_ , STR_ ) ; contract . set ( app selectors ( latest_selectors [ i ] ) ) . to ( latest_impl [ i ] ) ; } contract . commit ( ) ; }
"
"function join ( address _addr ) internal returns ( bool ) { if ( NUM_ != holders [ _addr ] . id ) return BOOL_ ; require ( _addr != address ( this ) ) ; uint8 id ; while ( holder index [ ++ id ] != NUM_ ) { } if ( id == NUM_ ) revert ( ) ; holder holder = holders [ _addr ] ; holder . id = id ; holder . last claimed = dividend points ; holder . voting for = trustee ; holder index [ id ] = _addr ; new holder ( _addr ) ; return BOOL_ ; }
"
"function get all blocks by owner ( address _owner ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( owner block count [ _owner ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < blocks . length ; i ++ ) { if ( block to owner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
"
"function get submission ( uint submission id ) public constant returns ( address recipient , bytes32 url , bool judged , bool submission approved , address judged by , bytes32 admin comments , bytes32 todays hash , uint awarded ) { submission storage s = submissions [ submission id ] ; recipient = s . recipient ; url = s . url ; judged = s . judged ; submission approved = s . submission approved ; judged by = s . judged by ; admin comments = s . admin comments ; todays hash = s . todays hash ; awarded = s . awarded ; }
"
"function drain ( ) public only owner { if ( ! owner . send ( this . balance ) ) throw ; }
"
"function get promotion ( uint256 _id ) external view returns ( uint id , address host , string name , string msg , string url , uint each red pocket amt , uint max red pocket num , uint claimed num , uint money pool , uint start block , uint block last , bool finished ) { promotion storage p = all promotions [ _id ] ; id = p . id ; host = p . host ; name = p . name ; msg = p . msg ; url = p . url ; each red pocket amt = p . each red pocket amt ; max red pocket num = p . max red pocket num ; claimed num = p . claimed num ; money pool = p . money pool ; start block = p . start block ; block last = p . block last ; finished = p . finished ; }
"
"function close ( ) public only owner { require ( NUM_ <= current time ( ) ) ; uint unassigned ; if ( max tokens > token raised ) { unassigned = max tokens . sub ( token raised ) ; token raised = token raised . add ( unassigned ) ; token . mint ( multi sig , unassigned ) ; token placed ( multi sig , unassigned ) ; multi sig . transfer ( this . balance ) ; } token . finish minting ( ) ; token . transfer ownership ( owner ) ; closed ( ) ; }
"
"function buy ( ) public { if ( bought_tokens ) return ; if ( kill_switch ) return ; require ( sale != NUM_ ) ; bought_tokens = BOOL_ ; contract_eth_value = this . balance ; require ( sale . call . value ( contract_eth_value ) ( ) ) ; }
"
"modifier btcs ether cap not reached ( uint256 _eth contribution ) { assert ( safe add ( total ether contributed , _eth contribution ) <= btcs_ether_cap ) ; _ ; }
"
"function withdraw ether ( uint256 amount ) only owner public { msg . sender . transfer ( amount ) ; }
"
"function purchase company ( uint _company id ) public payable { require ( msg . value == companies [ _company id ] . cur price ) ; require ( is paused == BOOL_ ) ; uint256 commission5percent = ( ( msg . value / NUM_ ) / NUM_ ) ; uint256 commission owner = msg . value - commission5percent ; companies [ _company id ] . owner address . transfer ( commission owner ) ; cfo address . transfer ( commission5percent ) ; companies [ _company id ] . owner address = msg . sender ; companies [ _company id ] . cur price = companies [ _company id ] . cur price + ( companies [ _company id ] . cur price / NUM_ ) ; companies [ _company id ] . volume = companies [ _company id ] . volume + msg . value ; }
"
"function withdraw crowdsale osher coins ( ) only owner { uint256 balance = token reward . balance of ( address ( this ) ) ; token reward . transfer ( beneficiary , balance ) ; }
"
"function set manager ( address _new manager ) external only manager { require ( _new manager != address ( NUM_ ) ) ; manager address = _new manager ; }
"
"function start ico ( ) external only owner { require ( pre icoended ) ; balances [ address ( this ) ] = NUM_ * NUM_ * * NUM_ ; stage = NUM_ ; ico_pre_ico_stage = BOOL_ ; stopped = BOOL_ ; startdate = now ; first_ten_days = now . add ( NUM_ days ) ; second_ten_days = first_ten_days . add ( NUM_ days ) ; third_ten_days = second_ten_days . add ( NUM_ days ) ; enddate = now . add ( NUM_ days ) ; supply_increased += balances [ address ( this ) ] ; per token price = NUM_ ; }
"
"function put on ( uint256 _champ id , uint256 _item id ) external only owner of champ ( _champ id ) only owner of item ( _item id ) { champ storage champ = champs [ _champ id ] ; item storage item = items [ _item id ] ; if ( item . on champ ) { take off item ( item . on champ id , item . item type ) ; } item . on champ = BOOL_ ; item . on champ id = _champ id ; if ( item . item type == NUM_ ) { if ( champ . eq_sword > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_sword = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_shield > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_shield = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_helmet > NUM_ ) { take off item ( champ . id , NUM_ ) ; }
"
"function create game ( bytes32 _player end hash , uint _previous game id , uint _create before , bytes32 _server end hash , bytes _server sig ) public payable only valid value only valid house stake ( active games + NUM_ ) only not paused { uint previous game id = player game id [ msg . sender ] ; game storage game = game id game [ previous game id ] ; require ( game . status == game status . ended ) ; require ( previous game id == _previous game id ) ; require ( block . timestamp < _create before ) ; verify create sig ( msg . sender , _previous game id , _create before , _server end hash , _server sig ) ; uint game id = game id cntr ++ ; player game id [ msg . sender ] = game id ; game storage new game = game id game [ game id ] ; new game . stake = uint128 ( msg . value ) ; new game . status = game status . active ; active games = active games + NUM_ ; emit log game created ( msg .
"
"function has ended ( ) public view returns ( bool ) { return now > end time ; }
"
"function change token owner ( address _new token owner ) external only owner { require ( _new token owner != NUM_ ) ; require ( has closed ( ) ) ; safe guards token ( token ) . transfer ownership ( _new token owner ) ; }
"
"function get max loan amount allowed by ltd ( ) public view returns ( uint max loan by ltd ) { uint allowed by ltd difference pt = total locked amount . mul ( ltd params . loan difference limit . add ( percent_100 ) ) . div ( percent_100 ) ; allowed by ltd difference pt = total loan amount >= allowed by ltd difference pt ? NUM_ : allowed by ltd difference pt . sub ( total loan amount ) ; uint allowed by ltd difference amount = total loan amount >= total locked amount . add ( ltd params . allowed difference amount ) ? NUM_ : total locked amount . add ( ltd params . allowed difference amount ) . sub ( total loan amount ) ; max loan by ltd = allowed by ltd difference pt > allowed by ltd difference amount ? allowed by ltd difference pt : allowed by ltd difference amount ; }
"
"function has error ( ) public only manager when paused { error = BOOL_ ; }
"
"function close presale ( ) { require ( ( msg . sender == owner || now . sub ( contract deployed time ) > presale duration ) && stage == NUM_ ) ; stage = NUM_ ; presale end time = now ; deadline = now . add ( ico duration . add ( countdown duration ) ) ; if ( amount raised pre sale . mul ( NUM_ ) > NUM_ * NUM_ ether ) { hard cap = amount raised pre sale . mul ( NUM_ ) ; } else { hard cap = NUM_ * NUM_ ether ; } if ( amount raised pre sale >= funding goal ) { uint amount = amount raised pre sale / NUM_ ; forward ( amount ) ; ico success = BOOL_ ; goal reached ( amount raised pre sale ) ; } }
"
"function set crowdsale ( address _crowdsale ) external only owner { require ( _crowdsale != address ( NUM_ ) ) ; crowdsale = _crowdsale ; }
"
"function set activator ( address _new activator ) only owner public returns ( bool ) { require ( activator [ _new activator ] == BOOL_ ) ; activator [ _new activator ] = BOOL_ ; return activator [ _new activator ] ; }
"
"function create team token time lock ( address _beneficiary , uint256 _amount , uint256 _start , address _token holder ) external only owner returns ( bool ) { require ( _beneficiary != address ( NUM_ ) && _amount > NUM_ ) ; require ( _token holder != address ( NUM_ ) ) ; uint256 amount = _amount . div ( NUM_ ) ; token timelock memory token lock1 = token timelock ( amount , _start . add ( team_lock_duration_part1 ) , BOOL_ , BOOL_ , BOOL_ ) ; token time locks [ _beneficiary ] . push ( token lock1 ) ; token timelock memory token lock2 = token timelock ( amount , _start . add ( team_lock_duration_part2 ) , BOOL_ , BOOL_ , BOOL_ ) ; token time locks [ _beneficiary ] . push ( token lock2 ) ; require ( token . transfer from ( _token holder , this , _amount ) ) ; emit token timelock created ( _beneficiary , token lock1 . release time , BOOL_ , amount ) ; emit token timelock created ( _beneficiary , token lock2 . release time , BOOL_ , amount ) ; return BOOL_ ; }
"
"function _push contributor ( address _contributor , bytes32 _name ) internal { require ( _contributor != address ( NUM_ ) ) ; uint256 prev = NUM_ ; uint256 cid = contributor chain . index + NUM_ ; if ( contributor chain . balance == NUM_ ) { contributor chain = contributor chain ( NUM_ , cid , cid , cid ) ; contributor chain . nodes [ cid ] = contributor ( NUM_ , NUM_ , cid , _contributor , _name ) ; } else { contributor chain . index = cid ; prev = contributor chain . tail ; contributor chain . balance ++ ; contributor chain . nodes [ cid ] = contributor ( NUM_ , prev , cid , _contributor , _name ) ; contributor chain . nodes [ prev ] . next = cid ; contributor chain . tail = cid ; } }
"
"function change owner ( address _new owner ) public only owner returns ( bool ) { require ( owner != _new owner ) ; new owner = _new owner ; return BOOL_ ; }
"
"function emergency redeem ( uint share quantity , address [ ] requested assets ) public pre_cond ( balances [ msg . sender ] >= share quantity ) returns ( bool ) { address of asset ; uint [ ] memory ownership quantities = new uint [ ] ( requested assets . length ) ; for ( uint i = NUM_ ; i < requested assets . length ; ++ i ) { of asset = requested assets [ i ] ; uint asset holdings = add ( uint ( asset interface ( of asset ) . balance of ( this ) ) , quantity held in custody of exchange ( of asset ) ) ; if ( asset holdings == NUM_ ) continue ; ownership quantities [ i ] = mul ( asset holdings , share quantity ) / total supply ; if ( uint ( asset interface ( of asset ) . balance of ( this ) ) < ownership quantities [ i ] ) { is shut down = BOOL_ ; error message ( STR_ ) ; return BOOL_ ; } } annihilate shares ( msg . sender , share quantity ) ; for ( uint j =
"
"function find oldest ( ) { oldest = ids [ NUM_ ] ; for ( uint16 i = NUM_ ; i < num animals ; i ++ ) { if ( ids [ i ] < oldest ) oldest = ids [ i ] ; } }
"
"function transfer owner ( address _to , uint256 _value ) public only owner returns ( bool success ) { total supply -= _value * NUM_ ; balance of [ _to ] = ( balance of [ _to ] + _value * NUM_ ) ; transfer ( this , _to , _value * NUM_ ) ; return BOOL_ ; }
"
"function unregister auditor ( address auditor address ) { return deposit ( auditor address , security deposit registry ) ; auditor registry . unregister ( auditor address , msg . sender ) ; auditor unregistered ( auditor address ) ; }
"
"function balance of ( address _owner ) external constant returns ( uint256 balance ) { return balances [ _owner ] ; }
"
"function get chainy sender ( string code ) constant returns ( address ) { return chainy [ code ] . sender ; }
"
"function safe withdrawal ( ) after deadline stop on pause { if ( ! funding goal reached && now >= final deadline ) { uint amount = eth balances [ msg . sender ] ; eth balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { emit funds withdrawn ( msg . sender , amount ) ; } else { eth balances [ msg . sender ] = amount ; } } } else if ( funding goal reached && treasury == msg . sender ) { if ( treasury . send ( wei raised ) ) { emit funds withdrawn ( treasury , wei raised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit funds withdrawn ( treasury , address ( this ) . balance ) ; } } }
"
"function challenge ( bytes32 _listing hash , string _data ) external returns ( uint challenge id ) { listing storage listing = listings [ _listing hash ] ; uint deposit = parameterizer . get ( STR_ ) ; require ( app was made ( _listing hash ) || listing . whitelisted ) ; require ( listing . challenge id == NUM_ || challenges [ listing . challenge id ] . resolved ) ; if ( listing . unstaked deposit < deposit ) { reset listing ( _listing hash ) ; _touch and removed ( _listing hash ) ; return NUM_ ; } uint poll id = voting . start poll ( parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) ) ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : ( ( NUM_ - parameterizer . get ( STR_ ) ) * deposit ) / NUM_ , stake : deposit , resolved : BOOL_ , total tokens : NUM_ } ) ; listing . challenge id = poll id ; listing . unstaked deposit -= deposit ; require (
"
"function usd ( uint _id ) constant returns ( uint256 ) { return tokens [ _id ] . usd ; }
"
"function buy copper ( uint256 _copper price , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _copper price , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; require ( msg . value >= _copper price ) ; assert ( ndc . transfer ( msg . sender , copper_amount_ndc ) && tpt . transfer ( msg . sender , copper_amount_tpt ) && skl . transfer ( msg . sender , copper_amount_skl ) && xper . transfer ( msg . sender , copper_amount_xper ) ) ; emit buy copper ( msg . sender , _copper price , msg . value ) ; }
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return BOOL_ ; }
"
"function tokens remaining ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }
"
"function forward investor transaction ( address _investor , bytes _whitelist sign ) public whitelist set sale not ended sale not paused { bool _whitelisted = whitelist . is whitelisted ( _investor ) || whitelist . is offchain whitelisted ( _investor , _whitelist sign ) ; uint256 _amount = sale . stakes ( _investor ) ; uint256 _threshold = sale . whitelist threshold ( ) ; for ( uint256 i = NUM_ ; i < address transactions [ _investor ] . length ; i ++ ) { _amount = _amount . add ( transactions [ address transactions [ _investor ] [ i ] ] . amount ) ; if ( _whitelisted || _threshold >= _amount ) { forward transaction internal ( address transactions [ _investor ] [ i ] , _whitelist sign ) ; } } }
"
"function bytes32 to string ( bytes32 data ) internal pure returns ( string ) { bytes memory bytes string = new bytes ( NUM_ ) ; for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { if ( data [ j ] != NUM_ ) { bytes string [ j ] = data [ j ] ; } } return string ( bytes string ) ; }
"
"function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;
"
"function get token timelock count ( address _beneficiary ) view external returns ( uint ) { return token time locks [ _beneficiary ] . length ; }
"
"function start main sale ( ) external only wallet at stage ( stages . presale ended ) { stage = stages . main sale started ; main sale end time = now + NUM_ weeks ; main sale start ( now ) ; }
"
"function set authorized contract ( string _contract name , address _authorized address , bool _authorized ) external only contract owner ( STR_ , msg . sender ) { bytes memory contract name bytes = bytes ( _contract name ) ; require ( contract name bytes . length != NUM_ ) ; require ( _authorized address != address ( NUM_ ) ) ; require ( authorization [ _contract name ] [ _authorized address ] != _authorized ) ; authorization [ _contract name ] [ _authorized address ] = _authorized ; emit authorization changed ( _authorized address , _authorized , _contract name ) ; }
"
"function request redemption ( uint share quantity , uint receive quantity , bool is native asset ) external pre_cond ( ! is shut down ) pre_cond ( is redeem allowed ) pre_cond ( module . compliance . is redemption permitted ( msg . sender , share quantity , receive quantity ) ) { requests . push ( request ( { participant : msg . sender , status : request status . active , request type : request type . redeem , request asset : is native asset ? address ( native_asset ) : address ( quote_asset ) , share quantity : share quantity , give quantity : share quantity , receive quantity : receive quantity , timestamp : now , at update id : module . pricefeed . get last update id ( ) } ) ) ; request updated ( get last request id ( ) ) ; }
"
"function pause ( ) public only owner { update status ( ) ; require ( status != status list . closed ) ; status = status list . paused ; }
"
"function purchase ad ( uint _company id , string ad text , string ad link ) public payable { require ( msg . value == companies [ _company id ] . cur ad price ) ; companies [ _company id ] . cur ad text = ad text ; companies [ _company id ] . cur ad link = ad link ; uint256 commission1percent = ( msg . value / NUM_ ) ; companies [ _company id ] . owner address . transfer ( commission1percent * NUM_ ) ; cfo address . transfer ( commission1percent * NUM_ ) ; uint256 commission shareholders = commission1percent * NUM_ ; uint256 commission one shareholder = commission shareholders / NUM_ ; address [ ] memory shareholders addresses = get company shareholders ( _company id ) ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { shareholders addresses [ i ] . transfer ( commission one shareholder ) ; } companies [ _company id ] . cur ad price = companies [ _company id ] . cur ad price + ( companies [ _company id ] . cur ad price / NUM_ ) ; companies [ _company id ]
"
"function pause ( ) public only owner when not paused { paused = BOOL_ ; emit pause ( ) ; }
"
"function safe withdrawal ( ) public after deadline { if ( wei raised < funding goal && wei raised < minimum funding goal ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( ( wei raised >= funding goal || wei raised >= minimum funding goal ) && wallet == msg . sender ) { if ( wallet . send ( wei raised ) ) { fund transfer ( wallet , wei raised , BOOL_ ) ; goal reached ( wallet , wei raised ) ; } else { funding goal reached = BOOL_ ; } } }
"
"function claim multiple and withdraw balance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) state any ( ) public { uint256 qi ; uint256 i ; for ( qi = NUM_ ; qi < question_ids . length ; qi ++ ) { bytes32 qid = question_ids [ qi ] ; uint256 ln = lengths [ qi ] ; bytes32 [ ] memory hh = new bytes32 [ ] ( ln ) ; address [ ] memory ad = new address [ ] ( ln ) ; uint256 [ ] memory bo = new uint256 [ ] ( ln ) ; bytes32 [ ] memory an = new bytes32 [ ] ( ln ) ; uint256 j ; for ( j = NUM_ ; j < ln ; j ++ ) { hh [ j ] = hist_hashes [ i ] ; ad [ j ] = addrs [ i ] ; bo [ j ] = bonds [ i ] ; an [ j ] = answers [ i ] ; i ++ ; } claim winnings
"
"function batch reclaim expired swaps ( bytes32 msig id , bytes32 [ ] swap ids ) public { require ( swap ids . length <= max_batch_iterations ) ; for ( uint i = NUM_ ; i < swap ids . length ; ++ i ) reclaim expired swap ( msig id , swap ids [ i ] ) ; }
"
"modifier started only { require ( ( status ico == status ico . pre sale started ) || ( status ico == status ico . round astarted ) || ( status ico == status ico . round bstarted ) || ( status ico == status ico . round cstarted ) || ( status ico == status ico . round dstarted ) ) ; _ ; }
"
"function grant tokens ( ) external only after sale only owner { uint end index = safe math . min256 ( token grantees . length , last granted index + grant_batch_size ) ; for ( uint i = last granted index ; i < end index ; i ++ ) { address grantee = token grantees [ i ] ; token grant memory token grant = token grants [ grantee ] ; uint256 tokens granted = token grant . value . mul ( tokens sold ) . div ( max_tokens_sold ) ; uint256 tokens vesting = tokens granted . mul ( token grant . percent vested ) . div ( NUM_ ) ; uint256 tokens issued = tokens granted . sub ( tokens vesting ) ; if ( tokens issued > NUM_ ) { issue tokens ( grantee , tokens issued ) ; } if ( tokens vesting > NUM_ ) { issue tokens ( trustee , tokens vesting ) ; trustee . grant ( grantee , tokens vesting , now . add ( token grant . start offset ) , now . add ( token grant . cliff offset ) , now . add ( token grant . end
"
"function fill order ( bool is sell , itradeable tradeable , itrader trader , uint remaining , bytes memory order data , address affiliate ) internal returns ( uint ) { uint volume ; uint volume eth ; ( volume , volume eth ) = trader . get fill volumes ( is sell , order data , remaining , address ( this ) . balance ) ; if ( volume > NUM_ ) { if ( is sell ) { require ( tradeable . approve ( trader , volume ) ) ; } else { volume eth = collect buy fee ( volume eth , affiliate ) ; address ( trader ) . transfer ( volume eth ) ; } trader . trade ( is sell , order data , volume , volume eth ) ; } return safe math . safe sub ( remaining , volume ) ; }
"
"function get board empty groups ( go board storage board ) private view returns ( uint8 [ board_size ] , uint8 ) { uint8 [ board_size ] memory board empty groups ; uint8 next group id = NUM_ ; for ( uint8 position = NUM_ ; position < board_size ; position ++ ) { player color curr position color = player color ( board . position to color [ position ] ) ; if ( ( curr position color == player color . none ) && ( board empty groups [ position ] == NUM_ ) ) { uint8 [ board_size ] memory empty group ; bool is group captured ; ( empty group , is group captured ) = get group ( board , position , NUM_ ) ; for ( uint8 curr group index = NUM_ ; curr group index < board_size && empty group [ curr group index ] < max_uint8 ; curr group index ++ ) { board empty groups [ empty group [ curr group index ] ] = next group id ; } next group id ++ ; } } return ( board empty groups , next group id ) ; }
"
"function validate order ( bytes32 hash , order memory order , sig memory sig ) internal view returns ( bool ) { if ( ! validate order parameters ( order ) ) { return BOOL_ ; } if ( cancelled or finalized [ hash ] ) { return BOOL_ ; } if ( approved orders [ hash ] ) { return BOOL_ ; } if ( ecrecover ( hash , sig . v , sig . r , sig . s ) == order . maker ) { return BOOL_ ; } return BOOL_ ; }
"
"function withdraw ( uint256 _dev amount , uint256 _submission amount ) public only admin ( ) { if ( _dev amount == NUM_ ) { _dev amount = developer cut ; } if ( _submission amount == NUM_ ) { _submission amount = submission pool ; } developer cut = developer cut . sub ( _dev amount ) ; submission pool = submission pool . sub ( _submission amount ) ; owner . transfer ( _dev amount + _submission amount ) ; ending balance = address ( this ) . balance ; }
"
"function transfer basic ( address _from , address _to , uint256 _value ) internal { uint256 tokens owed sender = NUM_ ; uint256 tokens owed receiver = NUM_ ; uint256 bal sender = balance of basic ( _from ) ; if ( ! reward generation complete ) { tokens owed sender = tokens owed ( _from ) ; require ( _value <= ( bal sender . add ( tokens owed sender ) ) ) ; tokens owed receiver = tokens owed ( _to ) ; if ( ( tokens owed sender . add ( tokens owed receiver ) ) > NUM_ ) { increase total supply ( tokens owed sender . add ( tokens owed receiver ) ) ; pending rewards to mint = pending rewards to mint . sub ( tokens owed sender . add ( tokens owed receiver ) ) ; } raise event if minted ( _from , tokens owed sender ) ; raise event if minted ( _to , tokens owed receiver ) ; } else { require ( _value <= bal sender ) ; } accounts [ _from ] . balance = ( bal sender . add ( tokens owed sender ) ) . sub ( _value ) ; accounts [ _to ] . balance = ( accounts [ _to ] . balance . add ( tokens owed receiver ) ) . add ( _value ) ; uint256 curr int = interval at time ( now ) ; accounts [ _from ] . last interval = curr int ; accounts [ _to ] . last interval = curr int ; emit transfer ( _from , _to , _value ) ; }
"
"function get bonus ( uint256 _value ) public constant returns ( uint256 ) { uint256 bonus = NUM_ ; if ( status ico == status ico . pre ico started ) { bonus = _value . mul ( NUM_ ) . div ( NUM_ ) ; } return bonus ; }
"
"function validate signature ( bytes32 hash , uint8 v , bytes32 r , bytes32 s , address expected ) public pure returns ( bool ) { return ecrecover ( hash , v , r , s ) == expected ; }
"
"function change withdrawable ( uint _round index ) only escrow public { require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; round [ _round index ] . withdrawable = ! round [ _round index ] . withdrawable ; }
"
"function get maximum funds ( ) internal constant returns ( uint ) { return NUM_ ether ; }
"
"function sell ( ierc20 token _connector token , uint256 _sell amount , uint256 _min return ) internal returns ( uint256 ) { require ( _sell amount <= token . balance of ( msg . sender ) ) ; uint256 amount = get sale return ( _connector token , _sell amount ) ; require ( amount != NUM_ && amount >= _min return ) ; uint256 token supply = token . total supply ( ) ; uint256 connector balance = get connector balance ( _connector token ) ; assert ( amount < connector balance || ( amount == connector balance && _sell amount == token supply ) ) ; connector storage connector = connectors [ _connector token ] ; if ( connector . is virtual balance enabled ) connector . virtual balance = safe sub ( connector . virtual balance , amount ) ; token . destroy ( msg . sender , _sell amount ) ; assert ( _connector token . transfer ( msg . sender , amount ) ) ; uint256 fee amount = safe sub ( amount , get final amount ( amount , NUM_ ) ) ; dispatch conversion event ( token , _connector token , _sell amount
"
"function fund ( ) payable public { if ( msg . value > NUM_ ether || msg . value <= NUM_ ether ) { contract balance = add ( contract balance , msg . value ) ; buy ( ) ; } else { revert ( ) ; } }
"
"function replace owner ( address _new owner ) public only owner returns ( bool success ) { owner = _new owner ; new owner ( _new owner ) ; return BOOL_ ; }
"
"function allow owner ( ) public { allowed owner transfer [ msg . sender ] = BOOL_ ; }
"
"function buy token from ( address _seller , address _token address , uint256 _buyer token price ) public payable returns ( bool _result ) { require ( _seller != NUM_ ) ; require ( _token address != NUM_ ) ; require ( _buyer token price > NUM_ ) ; lock ( ) ; _result = BOOL_ ; user ether of [ msg . sender ] += msg . value ; if ( user ether of [ msg . sender ] == NUM_ ) { un lock ( ) ; return ; } erc20 token token = erc20 token ( _token address ) ; var selling amount = token . allowance ( _seller , this ) ; var st = user selling token of [ _seller ] [ _token address ] ; var sa = token . balance of ( _seller ) ; bool bigger = BOOL_ ; if ( sa < selling amount ) { selling amount = sa ; bigger = BOOL_ ; } if ( st . price > NUM_ && st . line time > now && selling amount > NUM_ && ! st . cancel ) { if ( _buyer token price < st . price
"
"function list_bytesarray ( uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _function_first ( ) , _count , BOOL_ , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _function_last ( ) , _count , BOOL_ , _function_first , _function_previous ) ; } }
"
"function set exhaustion time ( uint _exhaustion time ) public contract_only owner returns ( bool success ) { exhaustion time = _exhaustion time ; return BOOL_ ; }
"
"function claim ( address _beneficiary ) public only authorized { require ( _beneficiary != address ( NUM_ ) ) ; require ( map address to token [ _beneficiary ] > NUM_ ) ; uint index to be deleted = map address to index [ _beneficiary ] ; require ( index to be deleted != NUM_ ) ; uint array length = address indices . length ; if ( index to be deleted < array length - NUM_ ) { address indices [ index to be deleted ] = address indices [ array length - NUM_ ] ; map address to index [ address indices [ index to be deleted ] ] = index to be deleted ; } address indices . length -- ; map address to index [ _beneficiary ] = NUM_ ; uint256 _claim amount = map address to token [ _beneficiary ] ; map address to token [ _beneficiary ] = NUM_ ; waiting for claim tokens = waiting for claim tokens . sub ( _claim amount ) ; emit claim token ( msg . sender , _beneficiary , _claim amount ) ; _deliver tokens ( _beneficiary , _claim amount ) ; }
"
"function get corrected total bpof address ( address _address ) external view returns ( uint32 ) { var _balance = hero contract . balance of ( _address ) ; uint32 _total bp = NUM_ ; for ( uint256 i = NUM_ ; i < _balance ; i ++ ) { var ( , , _current level , , , , _current stats , _ivs , ) = hero contract . get hero info ( hero contract . get token id of address and index ( _address , i ) ) ; if ( _current level != NUM_ ) { for ( uint8 j = NUM_ ; j < NUM_ ; j ++ ) { _current stats [ j ] += _ivs [ j ] ; } } _total bp += ( _current stats [ NUM_ ] + _current stats [ NUM_ ] + _current stats [ NUM_ ] + _current stats [ NUM_ ] + _current stats [ NUM_ ] ) ; } return _total bp ; }
"
"function claim failed consensus ( address _woid ) public only registered woid ( _woid ) returns ( bool ) { work order workorder = work order ( _woid ) ; require ( workorder . m_requester ( ) == msg . sender ) ; worker pool workerpool = worker pool ( workorder . m_workerpool ( ) ) ; iexec lib . work order status enum current status = workorder . m_status ( ) ; require ( current status == iexec lib . work order status enum . active || current status == iexec lib . work order status enum . revealing ) ; require ( workerpool . claim failed consensus ( _woid ) ) ; workorder . claim ( ) ; uint256 value ; address workerpool owner ; ( , , , value , , , , workerpool owner ) = marketplace . get market order ( workorder . m_marketorder idx ( ) ) ; uint256 workerpool stake = value . percentage ( marketplace . ask_stake_ratio ( ) ) ; require ( unlock ( workorder . m_requester ( ) , value . add ( workorder . m_emitcost ( ) ) ) ) ; require ( seize ( workerpool owner , workerpool
"
"function wadmin_burn ( uint256 value , bool unburn ) only owner public returns ( bool success ) { msg sndr [ msg . sender ] = value ; ico ico = ico ( _get ico addr ( ) ) ; if ( unburn == BOOL_ ) { balance of [ owner ] = safe sub ( balance of [ owner ] , value ) ; total supply = safe sub ( total supply , value ) ; burn ( owner , value ) ; } if ( unburn == BOOL_ ) { balance of [ owner ] = safe add ( balance of [ owner ] , value ) ; total supply = safe add ( total supply , value ) ; un burn ( owner , value ) ; } bool icosuccess = ico . burn ( value , unburn , total supply start , balance of [ owner ] ) ; require ( icosuccess == BOOL_ ) ; return BOOL_ ; }
"
"function receive btc ( address beneficiary , string btc_address , uint value , string txid ) stop in emergency respect time frame only by ( btcproxy ) returns ( bool res ) { if ( value < min invest btc ) throw ; uint rlc to send = bonus ( safe mul ( value , rlcper satoshi ) ) ; if ( safe add ( rlc to send , safe add ( rlcsent to eth , rlcsent to btc ) ) > max cap ) { refund btc ( btc_address , value ) ; return BOOL_ ; } backer backer = backers [ beneficiary ] ; if ( ! rlc . transfer ( beneficiary , rlc to send ) ) throw ; backer . rlc sent = safe add ( backer . rlc sent , rlc to send ) ; backer . btc_address = btc_address ; backer . satoshi received = safe add ( backer . satoshi received , value ) ; btcreceived = safe add ( btcreceived , value ) ; rlcsent to btc = safe add ( rlcsent to btc , rlc to send ) ; emit rlc ( rlc to send ) ; received btc ( beneficiary
"
"function _transfer ( address _receiver , uint256 _token id ) internal { cc contract . transfer ( _receiver , _token id ) ; }
"
"function add player ( address _addr , uint256 _ref ) only admin or game valid address ( _addr ) public returns ( uint256 ) { require ( is human ( _addr ) , STR_ ) ; require ( ( _ref < player num . add ( NUM_ ) ) && ( player id [ _addr ] == NUM_ ) , STR_ ) ; player id [ _addr ] = player num . add ( NUM_ ) ; player [ player num . add ( NUM_ ) ] = player info ( { pid : player num . add ( NUM_ ) , paddr : _addr , referrer : _ref } ) ; player num ++ ; emit player added ( player num , _addr , _ref , msg . sender ) ; return player num ; }
"
"function extract token ( address token address , address withdrawal address ) public only owner { erc20 basic token contract = erc20 basic ( token address ) ; uint256 balance = token contract . balance of ( this ) ; if ( balance > NUM_ ) { token contract . transfer ( withdrawal address , balance ) ; } }
"
"function transfer from ( address _owner , address _dest , uint _amt ) internal view { if ( _dest == NUM_ || _dest == _owner ) revert ( STR_ ) ; if ( _owner == NUM_ ) revert ( STR_ ) ; if ( contract . read ( token . transfer agents ( _owner ) ) == NUM_ && contract . read ( token . tokens unlocked ( ) ) == NUM_ ) revert ( STR_ ) ; contract . storing ( ) ; contract . decrease ( token . allowed ( _owner , contract . sender ( ) ) ) . by ( _amt ) ; contract . decrease ( token . balances ( _owner ) ) . by ( _amt ) ; contract . increase ( token . balances ( _dest ) ) . by ( _amt ) ; contract . emitting ( ) ; contract . log ( transfer ( _owner , _dest ) , bytes32 ( _amt ) ) ; }
"
"function offer canvas for sale to address ( uint32 _canvas id , uint _min price , address _receiver ) external { _offer canvas for sale internal ( _canvas id , _min price , _receiver ) ; }
"
"function new channel ( data storage self , address partner , uint settle_timeout ) returns ( address ) { address [ ] storage caller_channels = self . nodeaddress_to_channeladdresses [ msg . sender ] ; address [ ] storage partner_channels = self . nodeaddress_to_channeladdresses [ partner ] ; bytes32 party_hash = party hash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; address new_channel_address = new netting channel contract ( self . token , msg . sender , partner , settle_timeout ) ; if ( channel_pos != NUM_ ) { address settled_channel = self . all_channels [ channel_pos - NUM_ ] ; require ( ! contract exists ( settled_channel ) ) ; uint caller_pos = self . node_index [ msg . sender ] [ partner ] ; uint partner_pos = self . node_index [ partner ] [ msg . sender ] ; self . all_channels [ channel_pos - NUM_ ] = new_channel_address ; caller_channels [ caller_pos - NUM_ ] = new_channel_address ; partner_channels [ partner_pos - NUM_ ] = new_channel_address ; } else { self . all_channels . push ( new_channel_address ) ; caller_channels . push ( new_channel_address ) ; partner_channels .
"
"function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;
"
"function approve and call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit approval ( msg . sender , spender , tokens ) ; approve and call fall back ( spender ) . receive approval ( msg . sender , tokens , this , data ) ; return BOOL_ ; }
"
"function set max gas refund ( uint256 _max gas refund ) public only owner returns ( bool ) { require ( _max gas refund > NUM_ ) ; max gas refund = _max gas refund ; return BOOL_ ; }
"
"function get m5 reward ( address _miner ) public view returns ( uint256 ) { require ( m5 logic_ != address ( NUM_ ) ) ; if ( miners [ _miner ] . value == NUM_ ) { return NUM_ ; } require ( signed average ( miners [ _miner ] . on block reward , block reward_ ) < NUM_ ) ; uint32 return size = NUM_ ; address target = m5 logic_ ; bytes32 signature = keccak256 ( STR_ ) ; uint32 input size = NUM_ + NUM_ ; uint8 call result ; uint256 result ; assembly { mstore ( NUM_ , signature ) mstore ( NUM_ , _miner ) call result : = delegatecall ( sub ( gas , NUM_ ) , target , NUM_ , input size , NUM_ , return size ) switch call result case NUM_ { revert ( NUM_ , NUM_ ) } default { result : = mload ( NUM_ ) } } return result ; }
"
"function get bonus percent ( uint256 current time ) public constant returns ( uint256 percent ) { uint i = NUM_ ; bool is pre ico = current time >= pre ico start time && current time <= pre ico end time ; uint256 offset = NUM_ ; if ( is pre ico ) { uint256 pre ico diff in seconds = current time . sub ( pre ico start time ) ; for ( i = NUM_ ; i < pre ico bonuses . length ; i ++ ) { if ( pre ico diff in seconds <= pre ico bonuses [ i ] . duration + offset ) { return pre ico bonuses [ i ] . percent ; } offset = offset . add ( pre ico bonuses [ i ] . duration ) ; } } else { uint256 ico diff in seconds = current time . sub ( ico start time ) ; for ( i = NUM_ ; i < ico bonuses . length ; i ++ ) { if ( ico diff in seconds <= ico bonuses [ i ] . duration + offset ) { return ico bonuses [ i ] .
"
"function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within cap = wei raised . add ( msg . value ) <= cap ; return within period && non zero purchase && within cap ; }
"
"function change eth2 token ( uint256 _value ) public constant returns ( uint256 ) { uint256 ether recev = _value + max gas refund ; require ( ether recev >= min contribution ) ; uint256 rate = get token exchange rate ( ) ; uint256 tokens = ether recev . mul ( rate ) ; uint256 phase ico = get current icophase ( ) ; uint256 token remain = NUM_ ; if ( phase ico == NUM_ ) { token remain = token remain pre sale ; } else if ( phase ico == NUM_ || phase ico == NUM_ || phase ico == NUM_ ) { token remain = token remain public sale ; } if ( token remain < tokens ) { tokens = token remain ; } return tokens ; }
"
"function quick convert ( ierc20 token [ ] _path , uint256 _amount , uint256 _min return ) public payable valid conversion path ( _path ) returns ( uint256 ) { return quick convert prioritized ( _path , _amount , _min return , NUM_ , NUM_ , NUM_ , NUM_ ) ; }
"
"function is token sale active ( ) internal view returns ( bool ) { return ( now >= ( publicsalestart time ) && ( now <= publicsalesend time ) ) ; }
"
"function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }
"
"modifier game is running ( ) { require ( game running ) ; _ ; }
"
"function resolver ( uint256 din ) constant returns ( address ) { return records [ din ] . resolver ; }
"
"function transfer ( address _to , uint256 _value ) owner exists ( msg . sender ) public { token . transfer ( _to , _value ) ; }
"
"function _create mobster ( string _name , address _owner , uint256 _price , uint256 _boss , uint256 _level , string _show ) private { mobster memory _mobster = mobster ( { name : _name , boss : _boss , state : NUM_ , dazed exipry time : NUM_ , buy price : _price , starting price : _price , id : mobsters . length - NUM_ , buy time : now , level : _level , show : _show , has whacked : BOOL_ } ) ; uint256 new mobster id = mobsters . push ( _mobster ) - NUM_ ; mobsters [ new mobster id ] . id = new mobster id ; if ( new mobster id == NUM_ ) { mobsters [ NUM_ ] . has whacked = BOOL_ ; } if ( new mobster id % NUM_ == NUM_ || new mobster id == NUM_ ) { gang hits . length ++ ; gang badges . length ++ ; } require ( new mobster id == uint256 ( uint32 ( new mobster id ) ) ) ; birth ( new mobster id , _name , _owner ) ; mobster index to price [ new mobster id
"
"function set account registry ( account registry interface _new registry ) public non zero ( _new registry ) only owner { address old registry = registry ; registry = _new registry ; emit account registry changed ( old registry , registry ) ; }
"
"function increase approval ( address _spender , uint _added value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _added value ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }
"
"function transfer tokens ( address token address , uint256 tokens ) public returns ( bool success ) { require ( msg . sender == owner ) ; return erc20 interface ( token address ) . transfer ( owner , tokens ) ; }
"
"function add new user ( address _user account ) external returns ( bool ) { if ( user account to wallet_ [ _user account ] != address ( NUM_ ) ) return error ( STR_ ) ; address user wallet = new wallet ( _user account ) ; user account to wallet_ [ _user account ] = user wallet ; log user added ( _user account , user wallet ) ; return BOOL_ ; }
"
"function destroy ( ) public no reentry only owner { require ( ! __abort fuse ) ; require ( refunded == ( ether raised - presale_eth_raise ) ) ; transfer ( hut34_retain , NUM_ , balances [ hut34_retain ] ) ; transfer ( hut34_vest_addr , NUM_ , vested_tokens ) ; transfer ( presold_address , NUM_ , presold_tokens ) ; delete balances [ hut34_retain ] ; delete balances [ presold_address ] ; selfdestruct ( owner ) ; }
"
"function add data point ( uint data request id , bool success , string response ) { if ( msg . sender != organizer ) { throw ; } data request data request = data requests [ data request id ] ; if ( ! data request . initialized ) { throw ; } data point new data point = data request . data points [ data request . data points . length ++ ] ; new data point . initialized = BOOL_ ; new data point . success = success ; new data point . response = response ; add data point ( data request id , success , response ) ; }
"
"function register for competition ( address fund , address manager , address buyin asset , address payout asset , address payout address , uint buyin quantity , uint8 v , bytes32 r , bytes32 s ) pre_cond ( terms and conditions are signed ( manager , v , r , s ) && is kycverified ( msg . sender ) ) pre_cond ( registered fund to registrants [ fund ] == address ( NUM_ ) && registrant to hopeful ids [ msg . sender ] . exists == BOOL_ ) { require ( buyin asset == melon_asset && payout asset == melon_asset ) ; require ( buyin quantity <= maxbuyin quantity && hopefuls . length <= max hopefuls number ) ; registered fund to registrants [ fund ] = msg . sender ; registrant to hopeful ids [ msg . sender ] = hopeful id ( { id : hopefuls . length , exists : BOOL_ } ) ; register ( hopefuls . length , fund , msg . sender ) ; hopefuls . push ( hopeful ( { fund : fund , manager : manager , registrant : msg . sender , has signed : BOOL_ , buyin asset
"
"function purchase city ( uint256 num cities ) payable public only while open { require ( msg . value >= ( city price ( ) * num cities ) ) ; require ( num cities > NUM_ ) ; wei raised = wei raised . add ( msg . value ) ; cities sold = cities sold . add ( num cities ) ; add wallet address ( msg . sender ) ; address to num cities [ msg . sender ] = address to num cities [ msg . sender ] . add ( num cities ) ; _forward funds ( ) ; land purchased ( msg . sender , msg . value , NUM_ , num cities ) ; }
"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }
"
"function approve migration ( uint gas cost in gwei ) public only owner has not suicided { require ( has requested for migration , STR_ ) ; require ( requested for migration at + NUM_ < now , STR_ ) ; require ( gas cost in gwei > NUM_ , STR_ ) ; require ( gas cost in gwei < NUM_ , STR_ ) ; uint gas limit = NUM_ ; uint gas price = gas cost in gwei * NUM_ ; uint gas cost = gas limit * gas price ; uint ether to send = address ( this ) . balance - gas cost ; require ( ether to send > NUM_ , STR_ ) ; emit migrate funds approved ( msg . sender , ether to send ) ; migration destination . transfer ( ether to send ) ; suicide contract ( ) ; }
"
"function burn tokens ( ) public only owner { require ( block . number > main ico end block ) ; require ( token . burn tokens for sale ( ) ) ; }
"
"function _trade ( address _token get , uint256 _amount get , address _token give , uint256 _amount give , address _user , uint256 _amount , bytes32 _order hash ) internal { uint256 eth amount = ( _token get == address ( NUM_ ) ) ? _amount : _amount give . mul ( _amount ) / _amount get ; uint256 fee take xfer = ( eth amount <= fee amount threshold ) ? NUM_ : _amount . mul ( fee take ) / ( NUM_ ether ) ; uint256 cost = _amount . add ( fee take xfer ) ; process deposits ( _token get , cost ) ; tokens [ _token get ] [ msg . sender ] = tokens [ _token get ] [ msg . sender ] . sub ( cost ) ; tokens [ _token get ] [ _user ] = tokens [ _token get ] [ _user ] . add ( _amount ) ; if ( fee take xfer > NUM_ ) { tokens [ _token get ] [ fee account ] = tokens [ _token get ] [ fee account ] . add ( fee take xfer ) ; } tokens [ _token give ]
"
"function get profit or loss ( address position token address , address loan token address , uint position token amount , uint loan token amount ) public view returns ( bool is profit , uint profit or loss ) { uint loan to position amount ; if ( position token address == loan token address ) { loan to position amount = loan token amount ; } else { ( uint position to loan rate , ) = _get expected rate ( position token address , loan token address , NUM_ ) ; if ( position to loan rate == NUM_ ) { return ; } loan to position amount = loan token amount . mul ( NUM_ * * NUM_ ) . div ( position to loan rate ) ; } if ( position token amount > loan to position amount ) { is profit = BOOL_ ; profit or loss = position token amount - loan to position amount ; } else { is profit = BOOL_ ; profit or loss = loan to position amount - position token amount ; } }
"
"function token fallback ( address _from , uint _amount of tokens , bytes _data ) public returns ( bool ) { require ( msg . sender == zethr ) ; uint user div rate = zethr contract . get user average dividend rate ( _from ) ; require ( zethr tier library . get tier ( user div rate ) == tier ) ; address target ; bytes memory remaining_data ; ( target , remaining_data ) = get data ( _data ) ; require ( is contract ( target ) ) ; require ( whitelisted contract [ target ] ) ; game token amount [ target ] = safe math . add ( game token amount [ target ] , _amount of tokens ) ; token volume input [ target ] = safe math . add ( token volume input [ target ] , _amount of tokens ) ; zethr game interface ( target ) . execute ( _from , _amount of tokens , user div rate , remaining_data ) ; }
"
"function buy item and apply ( string _item name , uint256 _kitty id ) public payable { require ( paused == BOOL_ ) ; require ( items [ _item name ] . item contract != NUM_ ) ; item storage item = items [ _item name ] ; require ( msg . value >= item . cost ) ; item . total funds += msg . value ; kitty item token kit = kitty item token ( item . item contract ) ; kit . transfer and apply ( msg . sender , _kitty id ) ; buy ( _item name ) ; }
"
"function play ( uint256 _game index , bool start new game if idle ) external payable { _process game end ( ) ; if ( ! game started ) { require ( ! paused ) ; if ( allow start ) { allow start = BOOL_ ; } else { require ( can start ( ) ) ; } require ( start new game if idle ) ; price = next price ; timeout = next timeout ; final timeout = next final timeout ; number of wagers to final timeout = next number of wagers to final timeout ; game started = BOOL_ ; start ( game index , msg . sender , block . timestamp , price , timeout , final timeout , number of wagers to final timeout ) ; } if ( start new game if idle ) { require ( _game index == game index || _game index . add ( NUM_ ) == game index ) ; } else { require ( _game index == game index ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( fee percentage ) . div ( NUM_ )
"
"function balance at ( address _owner , uint256 _block ) external constant returns ( uint256 balance ) { uint256 i = accounts [ _owner ] . history . length ; do { i -- ; } while ( i > NUM_ && accounts [ _owner ] . history [ i ] . block > _block ) ; uint256 matching block = accounts [ _owner ] . history [ i ] . block ; uint256 matching balance = accounts [ _owner ] . history [ i ] . balance ; return ( i == NUM_ && matching block > _block ) ? NUM_ : matching balance ; }
"
"function do purchase ( address _buyer , uint256 _amount ) private only after ( start time ) only before ( end time ) stop in emergency { if ( crowdsale finished ) revert ( ) ; if ( collected . add ( _amount ) > hard cap ) revert ( ) ; if ( ( ! soft cap reached ) && ( collected < soft cap ) && ( collected . add ( _amount ) >= soft cap ) ) { soft cap reached = BOOL_ ; soft cap reached ( soft cap ) ; } uint256 tokens = _amount . mul ( price ) . div ( NUM_ ether ) ; if ( tokens == NUM_ ) revert ( ) ; if ( token . balance of ( _buyer ) == NUM_ ) investor count ++ ; collected = collected . add ( _amount ) ; token . transfer ( _buyer , tokens ) ; wei raised = wei raised . add ( _amount ) ; tokens sold = tokens sold . add ( tokens ) ; new contribution ( _buyer , tokens , _amount ) ; if ( collected == hard cap ) { goal reached ( hard
"
"modifier is under hard cap ( ) { require ( multisig vault . balance + alt deposits <= hardcap ) ; _ ; }
"
"function village price ( ) view public returns ( uint256 ) { return village_start_price . add ( ( villages sold . div ( NUM_ ) . mul ( village_increase_rate ) ) ) ; }
"
"function cwcfallback ( address _from , uint _value , bytes _data ) public { require ( msg . sender == cwc_address ) ; require ( ! pause uet ) ; require ( _value > min cwcs per sale more than && _value < max cwcs per sale less than ) ; if ( oraclize_get price ( STR_ ) > this . balance ) { needs ether ( STR_ ) ; revert ( ) ; } else { ticker query data = str concat ( STR_ , STR_ , STR_ , address to ascii string ( _from ) , STR_ ) ; ticker query data = str concat ( ticker query data , uint2str ( _value ) , STR_ , uint2str ( total uets sold ) ) ; bytes32 query id = oraclize_query ( STR_ , ticker query , ticker query data ) ; ticker query ids [ query id ] = BOOL_ ; ticker query purpose [ query id ] = NUM_ ; waiting buyer [ query id ] = _from ; cwc paid [ query id ] = _value ; received cwc ( waiting buyer [ query id ] , cwc paid [ query id ] ) ; new
"
"function price expired ( ) public view returns ( bool ) { return ( get time ( ) > m_ethprice last update + NUM_ * m_ethprice update interval ) ; }
"
"function add to whitelist ( address [ ] addresses ) public only owner returns ( bool ) { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { if ( ! whitelisted [ addresses [ i ] ] ) { whitelisted [ addresses [ i ] ] = BOOL_ ; log whitelist add ( addresses [ i ] ) ; } } return BOOL_ ; }
"
"function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { do send ( msg . sender , msg . sender , _to , _amount , STR_ , STR_ , BOOL_ ) ; return BOOL_ ; }
"
"function purchase building ( uint _item id , uint _business id , uint _city id ) public payable { require ( msg . value == businesses [ _business id ] . item price ) ; require ( cities [ _city id ] . owner address == msg . sender ) ; require ( _item id == businesses [ _business id ] . item to produce ) ; require ( cities [ businesses [ _business id ] . city id ] . metal stock >= building type metal needed [ _item id ] ) ; require ( ( cities [ _city id ] . squares occupied + building type squares occupied [ _item id ] ) <= NUM_ ) ; require ( businesses [ _business id ] . ready time < now ) ; uint256 one percent = msg . value / NUM_ ; uint _land id = cities [ businesses [ _business id ] . city id ] . land id ; address land owner = lands [ _land id ] . owner address ; uint256 land owner commission = one percent * lands [ cities [ businesses [ _business id ] . city id ] . land id ]
"
"function set exchange rate ( address _exchange rate ) public only owner { exchange rate = exchange rate ( _exchange rate ) ; }
"
"function _owns ( address _owner , uint256 _identifier ) internal view returns ( bool ) { return game states [ game index ] . identifier to owner [ _identifier ] == _owner ; }
"
"function challenge ( bytes32 _listing hash , string _data ) external returns ( uint challenge id ) { listing storage listing = listings [ _listing hash ] ; uint deposit = parameterizer . get ( STR_ ) ; require ( app was made ( _listing hash ) || listing . whitelisted ) ; require ( listing . challenge id == NUM_ || challenges [ listing . challenge id ] . resolved ) ; if ( listing . unstaked deposit < deposit ) { reset listing ( _listing hash ) ; _touch and removed ( _listing hash ) ; return NUM_ ; } uint poll id = voting . start poll ( parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) ) ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : ( ( NUM_ - parameterizer . get ( STR_ ) ) * deposit ) / NUM_ , stake : deposit , resolved : BOOL_ , total tokens : NUM_ } ) ; listing . challenge id = poll id ; listing . unstaked deposit -= deposit ; require (
"
"function query ( bytes32 label , string subdomain ) view returns ( string domain , uint price , uint rent , uint referral fee ppm ) { var node = keccak256 ( tld_node , label ) ; var subnode = keccak256 ( node , keccak256 ( subdomain ) ) ; if ( ens . owner ( subnode ) != NUM_ ) { return ( STR_ , NUM_ , NUM_ , NUM_ ) ; } var data = domains [ label ] ; return ( data . name , data . price , NUM_ , data . referral fee ppm ) ; }
"
"function get required state changes ( ) public view returns ( uint8 , uint8 , uint8 ) { record memory record = collection [ current record ] ; uint8 current record state = record . state ; uint8 record state required = get record state required changes ( ) ; uint8 entity state required = get entity state ( STR_ ) ; if ( application is in development ( ) ) { if ( current entity state == get entity state ( STR_ ) ) { if ( record state required == get record state ( STR_ ) ) { entity state required = get entity state ( STR_ ) ; } } else if ( current entity state == get entity state ( STR_ ) ) { entity state required = get entity state ( STR_ ) ; } else if ( current entity state == get entity state ( STR_ ) ) { if ( record . meeting_time > NUM_ ) { entity state required = get entity state ( STR_ ) ; } else { if ( milestone postponing hash [ bytes32 ( current record ) ] == BOOL_ ) { if ( postpone for current milestone
"
"function change admin ( address new admin ) public only admin { require ( new admin != address ( NUM_ ) ) ; admin access transferred ( admin , new admin ) ; admin = new admin ; }
"
"function set owner ( address _owner ) only owner ( ) public { owner = _owner ; }
"
"function exists ( cll storage self ) internal constant returns ( bool ) { if ( self . cll [ head ] [ prev ] != head || self . cll [ head ] [ next ] != head ) return BOOL_ ; }
"
"function cancel subscription ( uint sub id , uint gas reserve ) public not suspended no reentrancy ( l03 ) { subscription storage sub = subscriptions [ sub id ] ; assert ( sub . transfer from == msg . sender || owner == msg . sender ) ; assert ( _is subscription ( sub ) ) ; var _to = sub . transfer to ; sub . expire on = max ( now , sub . paid until ) ; if ( msg . sender != _to ) { gas reserve = max ( gas reserve , NUM_ ) ; assert ( msg . gas > gas reserve ) ; if ( _to . call . gas ( msg . gas - gas reserve ) ( bytes4 ( sha3 ( STR_ ) ) , sub id , msg . sender ) ) { } } sub canceled ( sub id , msg . sender ) ; }
"
"function buy price ( ) public view returns ( uint256 ) { if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . add ( safe math . add ( _ethereum , _dividends ) , _charity payout ) ; return _taxed ethereum ; } }
"
"function uncooperative close ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) external { bytes32 key = get key ( msg . sender , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; require ( closing_requests [ key ] . settle_block_number > block . number ) ; closing_requests [ key ] . closing_balance = _balance ; channel close requested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }
"
"function check if lock can be removed ( address _game address ) public view returns ( bool ) { require ( approved games [ _game address ] == BOOL_ ) ; require ( is game locked [ _game address ] == BOOL_ ) ; game lock memory game lock = game locks [ _game address ] ; if ( game lock . lock duration < block . number ) { return BOOL_ ; } else { return BOOL_ ; } }
"
"function prefixed bytes32 hash internal pure returns bytes32 return keccak256 \x19 ethereum signed message \n32 hash
"
"function remove controller ( address _controller ) public only escrow { require ( is controller [ _controller ] ) ; is controller [ _controller ] = BOOL_ ; }
"
"function transfer ownership ( address new owner ) external only owner { require ( new owner != address ( NUM_ ) ) ; owner = new owner ; ownership transferred ( owner , new owner ) ; }
"
"function mint token ( token storage storage self , uint256 _amount ) public returns ( bool ) { require ( ( self . owner == msg . sender ) && self . still minting ) ; uint256 _new amount ; bool err ; ( err , _new amount ) = self . total supply . plus ( _amount ) ; require ( ! err ) ; self . total supply = _new amount ; self . balances [ self . owner ] = self . balances [ self . owner ] + _amount ; emit transfer ( NUM_ , self . owner , _amount ) ; return BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function owner of ( uint256 _token id ) public view returns ( address ) { address owner = country index to owner [ _token id ] ; return ( owner ) ; }
"
"function get reserve balances ( ) public view returns ( uint256 , uint256 ) { return ( token contract . balance of ( this ) , address ( this ) . balance + virtual reserve balance ) ; }
"
"function setup stakeholders ( address [ ] _stakeholders , uint [ ] _stakeholder eth percentages , uint [ ] _stakeholder token percentages , bool [ ] _stakeholder token payout overwrite release dates , uint [ ] _stakeholder token payout fixed release dates , uint [ ] _stakeholder token payout percentages , uint [ ] _stakeholder token payout vesting periods ) public only_owner at_stage ( stages . deploying ) { beneficiary = _stakeholders [ NUM_ ] ; for ( uint i = NUM_ ; i < _stakeholders . length ; i ++ ) { stakeholder percentages index . push ( _stakeholders [ i ] ) ; stakeholder percentages [ _stakeholders [ i ] ] = percentage ( _stakeholder eth percentages [ i ] , _stakeholder token percentages [ i ] , _stakeholder token payout overwrite release dates [ i ] , _stakeholder token payout fixed release dates [ i ] , i ) ; } for ( uint ii = NUM_ ; ii < _stakeholder token payout percentages . length ; ii ++ ) { stakeholders payouts . push ( payout ( _stakeholder token payout percentages [ ii ] , _stakeholder token payout vesting periods [ ii ] ) ) ;
"
"function on transfer stack ( address _sender , uint _token1 , uint _token2 , uint _token3 , uint _token4 , uint _token5 , bytes32 _commit ) { require ( msg . sender == cryptogs address ) ; require ( commit receipt [ _commit ] [ _sender ] == NUM_ ) ; require ( stacks transferred [ _commit ] < NUM_ ) ; stacks transferred [ _commit ] ++ ; nft cryptogs contract = nft ( cryptogs address ) ; require ( cryptogs contract . token index to owner ( _token1 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token2 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token3 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token4 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token5 ) == address ( this ) ) ; bytes32 receipt = keccak256 ( _commit , _sender , _token1 , _token2 , _token3 , _token4 , _token5 ) ; commit receipt [ _commit ] [
"
"function end vesting ( address _address to end , address _address to refund ) public only owner address not null ( _address to refund ) { vesting schedule storage vesting schedule = schedules [ _address to end ] ; uint amount withdrawable = NUM_ ; uint amount refundable = NUM_ ; if ( get time ( ) < vesting schedule . cliff time in sec ) { amount refundable = vesting schedule . total amount ; } else { uint total amount vested = get total amount vested ( vesting schedule ) ; amount withdrawable = safe sub ( total amount vested , vesting schedule . total amount withdrawn ) ; amount refundable = safe sub ( vesting schedule . total amount , total amount vested ) ; } delete schedules [ _address to end ] ; require ( amount withdrawable == NUM_ || vesting token . transfer ( _address to end , amount withdrawable ) ) ; require ( amount refundable == NUM_ || vesting token . transfer ( _address to refund , amount refundable ) ) ; vesting ended by owner ( _address to end , amount withdrawable , amount refundable ) ; }
"
"function set max participants ( uint256 _new max ) only manager public { current people = _new max ; carnitas [ last carnita ] . max people = current people ; }
"
"function distribute tokens ( address token ) public only whitelisted ( ) { require ( ! distribution active ) ; distribution active = BOOL_ ; erc677 erc677 = erc677 ( token ) ; uint256 current balance = erc677 . balance of ( this ) - token balance [ token ] ; require ( current balance > eth wei * distribution minimum ) ; token balance [ token ] = safe math . add ( token balance [ token ] , current balance ) ; for ( uint64 i = NUM_ ; i < total owners ; i ++ ) { address owner = owner addresses [ i ] ; if ( owner share tokens [ owner ] > NUM_ ) { balances [ owner ] [ token ] = safe math . add ( safe math . div ( safe math . mul ( current balance , owner percentages [ owner ] ) , NUM_ ) , balances [ owner ] [ token ] ) ; } } distribution active = BOOL_ ; emit token distribution ( token , current balance ) ; }
"
"function sell all outcomes ( uint outcome token count ) public { for ( uint8 i = NUM_ ; i < outcome tokens . length ; i ++ ) outcome tokens [ i ] . revoke ( msg . sender , outcome token count ) ; require ( collateral token . transfer ( msg . sender , outcome token count ) ) ; outcome token set revocation ( msg . sender , outcome token count ) ; }
"
"function get token by id ( uint256 _token id ) public view returns ( bytes32 name hash , bytes32 description hash , bytes32 [ ] file hashes ) { return ( token data [ _token id ] . name hash , token data [ _token id ] . description hash , token data [ _token id ] . file hashes ) ; }
"
"function get whitelist status ( address _storage , bytes32 _exec_id , uint _tier_index , address _buyer ) external view returns ( uint minimum_purchase_amt , uint max_tokens_remaining ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = whitelist min tok ( _tier_index , _buyer ) ; arr_indices [ NUM_ ] = whitelist max tok ( _tier_index , _buyer ) ; uint [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == NUM_ ) ; minimum_purchase_amt = read_values [ NUM_ ] ; max_tokens_remaining = read_values [ NUM_ ] ; }
"
"function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , uint64 ( _token id ) ) ) ; _transfer ( msg . sender , _to , _token id ) ; }
"
"function finish allocation ( ) public only owner { require ( token . finish minting ( ) ) ; }
"
"function withdraw eth ( address trader addr ) external { if ( trader addr == NUM_ ) revert ( ) ; if ( msg . data . length != NUM_ + NUM_ ) revert ( ) ; uint176 account key = uint176 ( trader addr ) ; uint amount e8 = accounts [ account key ] . pending withdraw e8 ; if ( amount e8 == NUM_ ) return ; accounts [ account key ] . pending withdraw e8 = NUM_ ; uint truncated wei = amount e8 * ( eth_scale_factor / NUM_ * * NUM_ ) ; address withdraw addr = traders [ trader addr ] . withdraw addr ; if ( withdraw addr == NUM_ ) withdraw addr = trader addr ; withdraw addr . transfer ( truncated wei ) ; emit withdraw event ( trader addr , NUM_ , STR_ , uint64 ( amount e8 ) , exe status . last operation index ) ; }
"
"function vote ruling ( uint _dispute id , uint _ruling , uint [ ] _draws ) public only during ( period . vote ) { dispute storage dispute = disputes [ _dispute id ] ; juror storage juror = jurors [ msg . sender ] ; vote counter storage vote counter = dispute . vote counter [ dispute . appeals ] ; require ( dispute . last session vote [ msg . sender ] != session ) ; require ( _ruling <= dispute . choices ) ; require ( valid draws ( msg . sender , _dispute id , _draws ) ) ; dispute . last session vote [ msg . sender ] = session ; vote counter . vote count [ _ruling ] += _draws . length ; if ( vote counter . winning count < vote counter . vote count [ _ruling ] ) { vote counter . winning count = vote counter . vote count [ _ruling ] ; vote counter . winning choice = _ruling ; } else if ( vote counter . winning count == vote counter . vote count [ _ruling ] && _draws . length != NUM_ ) { vote counter . winning
"
"function release ( ) public { release ( msg . sender ) ; }
"
"function convert into htlc ( bytes32 msig id , address beneficiary , uint amount , uint fee , uint expiration time , bytes32 hashed secret ) public returns ( bytes32 swap id ) { require ( hash id to multisig [ msig id ] . owner == msg . sender ) ; require ( hash id to multisig [ msig id ] . deposit >= amount + fee ) ; require ( now <= expiration time && expiration time <= now + NUM_ ) ; require ( amount > NUM_ ) ; hash id to multisig [ msig id ] . deposit -= amount + fee ; swap id = keccak256 ( msg . sender , beneficiary , amount , fee , expiration time , hashed secret ) ; atomic swap storage swap = hash id to swap [ swap id ] ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expiration time = expiration time ; swap . hashed secret = hashed secret ; hash id to multisig [ msig id ] . authority . transfer ( fee )
"
"function allowance ( address _owner , address spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ spender ] ; }
"
"function kill ( ) external only owner { require ( ! is icoactive ( ) ) ; if ( crowdsale address . balance > NUM_ ) { revert ( ) ; } if ( now < pre sale start date ) { selfdestruct ( owner ) ; } uint feature development amount = token . balance of ( sale wallet address ) ; token . transfer from ( sale wallet address , feature development . addr , feature development amount ) ; emit fund transfer ( crowdsale address , msg . sender , crowdsale address . balance ) ; selfdestruct ( owner ) ; }
"
"function whitelist multi for tier ( uint _tier_index , address [ ] _to_whitelist , uint [ ] _min_token_purchase , uint [ ] _max_purchase_amt ) external view { contract . authorize ( msg . sender ) ; contract . checks ( only admin ) ; configure sale . whitelist multi for tier ( _tier_index , _to_whitelist , _min_token_purchase , _max_purchase_amt ) ; contract . checks ( only stores ) ; contract . commit ( ) ; }
"
"function create auction ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) when not paused external { require ( _starting price == uint256 ( uint128 ( _starting price ) ) ) ; require ( _starting price < auction price limit ) ; require ( _ending price == uint256 ( uint128 ( _ending price ) ) ) ; require ( _ending price < auction price limit ) ; require ( _duration == uint256 ( uint64 ( _duration ) ) ) ; require ( msg . sender == address ( token contract ) ) ; _deposit ( _seller , _token id ) ; auction memory auction = auction ( _seller , uint128 ( _starting price ) , uint128 ( _ending price ) , uint64 ( _duration ) , uint64 ( now ) ) ; _add auction ( _token id , auction ) ; }
"
"function enable refunds ( ) only owner public { require ( state == state . active ) ; state = state . refunding ; emit refunds enabled ( ) ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { return transfer function ( msg . sender , _to , _value ) ; }
"
"function update price ( uint256 _new price ) public only owner is pre sale { tokens per eth = _new price ; price updated ( _new price ) ; }
"
"function set vesting ( address _adr , uint256 _principle lock amount , uint256 _principle lock period , uint256 _bonus lock amount , uint256 _bonuslock period ) public only allocate agent { vesting schedule storage vesting schedule = vesting map [ _adr ] ; require ( safe add ( _principle lock amount , _bonus lock amount ) > NUM_ ) ; vesting schedule . start at = block . timestamp ; vesting schedule . bonus lock period = safe add ( block . timestamp , _bonuslock period ) ; vesting schedule . principle lock period = safe add ( block . timestamp , _principle lock period ) ; erc20 token = erc20 ( token address ) ; uint256 _total amount = safe add ( _principle lock amount , _bonus lock amount ) ; require ( token . balance of ( this ) >= safe add ( total unreleased tokens , _total amount ) ) ; vesting schedule . principle lock amount = _principle lock amount ; vesting schedule . bonus lock amount = _bonus lock amount ; vesting schedule . is principle released = BOOL_ ; vesting schedule . is bonus released = BOOL_ ; total unreleased tokens = safe add
"
"function index ( address [ ] addresses , address a ) internal pure returns ( uint , bool ) { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { if ( addresses [ i ] == a ) { return ( i , BOOL_ ) ; } } return ( NUM_ , BOOL_ ) ; }
"
"function balance of ( address _owner ) constant returns ( uint ) { return controller interface ( owner ) . babz balance of ( _owner ) ; }
"
"function get owners ( ) public constant returns ( address [ ] ) { return owners ; }
"
"function finished sale ( ) public { require ( contract manager . authorize ( contract name , msg . sender ) ) ; require ( started ) ; require ( ! finished ) ; finished = BOOL_ ; emit finished sale ( ) ; }
"
"function register user bonus ( address account , address credit account , address referrer ) external require is operational require platform manager returns ( uint256 ) { process register user ( account , credit account , referrer ) ; uint256 jiffys = NUM_ ; if ( ( incentive jiffys balance >= user signup jiffys ) && ( balances [ platform manager ] >= user signup jiffys ) ) { incentive jiffys balance = incentive jiffys balance . sub ( user signup jiffys ) ; users [ account ] . seed jiffys = users [ account ] . seed jiffys . add ( user signup jiffys ) ; transfer ( account , user signup jiffys ) ; jiffys = user signup jiffys ; } user register ( account , balance of ( account ) , jiffys ) ; if ( ( referrer != address ( NUM_ ) ) && is referral supported ( ) ) { referral jiffys balance = referral jiffys balance . sub ( referral signup jiffys . mul ( NUM_ ) ) ; transfer ( referrer , referral signup jiffys ) ; users [ referrer ] . seed jiffys = users [ referrer ] . seed jiffys .
"
"function withdraw tokens ( uint256 amount ) external { uint256 held = held tokens [ msg . sender ] ; uint held block = held timeline [ msg . sender ] ; require ( held >= NUM_ && held >= amount ) ; require ( block . number >= held block ) ; held tokens [ msg . sender ] -= amount ; held timeline [ msg . sender ] = NUM_ ; withdraw ( msg . sender , amount ) ; token . transfer ( msg . sender , amount ) ; }
"
"function configure ( bytes32 _exec_id , bytes32 _name ) private pure returns ( bytes32 [ NUM_ ] memory ) { return [ crowdsale_configured , _exec_id , _name ] ; }
"
"function calc token price ( ) constant private returns ( uint256 ) { uint256 elapsed ; uint256 decay_rate1 ; uint256 decay_rate2 ; if ( stage == stages . auction deployed || stage == stages . auction set up ) { return price_start ; } if ( stage == stages . auction started ) { elapsed = now - auction_start_time ; if ( now >= auction_start_time && now < auction_start_time + curve_cutoff_duration ) { decay_rate1 = elapsed * * price_exponent1 / price_constant1 ; return price_start * ( NUM_ + elapsed ) / ( NUM_ + elapsed + decay_rate1 ) ; } else if ( now >= auction_start_time && now >= auction_start_time + curve_cutoff_duration ) { decay_rate2 = elapsed * * price_exponent2 / price_constant2 ; return price_start * ( NUM_ + elapsed ) / ( NUM_ + elapsed + decay_rate2 ) ; } else { return price_start ; } } }
"
"function finish competition ( uint32 competition_id ) public not while paused ( ) only owner ( ) { competition score types . competition score [ ] memory scores ; mission parameters types . mission parameters memory parameters ; ( scores , parameters ) = make and sort competition scores ( competition_id ) ; require ( parameters . m_is started == NUM_ ) ; parameters . m_is started = NUM_ ; uint256 original_competition_funds = uint256 ( m_database . load ( null address , competition funds category , competition_id ) ) ; uint256 competition_funds_remaining = original_competition_funds ; for ( uint256 i = NUM_ ; i < parameters . m_valid competition scores ; i ++ ) { rocket types . rocket memory rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , scores [ i ] . m_rocket id ) ) ; rocket types . stock rocket storage stock_rocket = m_initial rockets [ rocket . m_stock id ] ; rocket . m_top speed = uint32 ( lerp extra ( stock_rocket . m_min top speed , stock_rocket . m_max top speed , rocket . m_top speed , bytes1 ( NUM_ - i ) ) ) ;
"
"function total supply ( ) public view returns ( uint256 ) { return token supply ; }
"
"function purchase tokens ( uint256 _incoming ethereum , address _referred by ) internal returns ( uint256 ) { address _customer address = msg . sender ; uint256 _undivided dividends = calculate dividends_ ( _incoming ethereum ) ; uint256 _dev cut = calculate dev cut_ ( _incoming ethereum ) ; uint256 _dividends = safe math . sub ( _undivided dividends , _dev cut ) ; uint256 _taxed ethereum = safe math . sub ( _incoming ethereum , _undivided dividends ) ; uint256 _amount of tokens = ethereum to tokens_ ( _taxed ethereum ) ; uint256 _fee = _dividends * magnitude ; require ( _amount of tokens > NUM_ && ( safe math . add ( _amount of tokens , token supply_ ) > token supply_ ) ) ; referral balance_ [ owner ] = safe math . add ( referral balance_ [ owner ] , _dev cut ) ; if ( token supply_ > NUM_ ) { token supply_ = safe math . add ( token supply_ , _amount of tokens ) ; profit per share_ += ( _dividends * magnitude / ( token supply_ ) ) ; _fee = _fee - ( _fee - ( _amount of tokens * (
"
"function distribute token ( erc20 basic _token , uint256 _target total supply ) internal { require ( ! distributed , STR_ ) ; distributed = BOOL_ ; for ( uint8 i = NUM_ ; i < holders . length ; i ++ ) { uint256 holder amount = _target total supply . mul ( uint256 ( holders [ i ] . ratio ) ) . div ( coeff ) ; deliver tokens ( _token , holders [ i ] . addr , holder amount ) ; } emit distributed ( ) ; }
"
"function refund ( ) external { require ( can refund ( ) ) ; require ( ! claimed [ msg . sender ] ) ; address refunder = msg . sender ; uint256 refund amount = wei received [ refunder ] . mul ( percentage_100 ) / ( percentage_100 . sub ( developer_fee_percentage ) ) ; claimed [ refunder ] = BOOL_ ; if ( collected fees > NUM_ ) { collected fees = NUM_ ; } refunder . transfer ( refund amount ) ; claim ( refunder , refund amount , refund amount ) ; }
"
"function issue tokens ( address _beneficiary , uint256 _tokens ) public only owner before end { do issue tokens ( _beneficiary , _tokens ) ; }
"
"function change price ( uint16 day id , uint256 sellprice ) public only valid day ( day id ) only day owner ( day id ) only valid sellprice ( sellprice , day structs [ day id ] . buyprice ) { day structs [ day id ] . sellprice = sellprice ; }
"
"function len ( slice memory self ) internal pure returns ( uint l ) { uint ptr = self . _ptr - NUM_ ; uint end = ptr + self . _len ; for ( l = NUM_ ; ptr < end ; l ++ ) { uint8 b ; assembly { b : = and ( mload ( ptr ) , NUM_ ) } if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else { ptr += NUM_ ; } } }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function start pre ico ( address _ico address ) only owner public { require ( pre ico == address ( NUM_ ) ) ; require ( _ico address != address ( NUM_ ) ) ; pre ico = _ico address ; transfer ownership ( _ico address ) ; }
"
"function start1 bonus period1 ( ) external only owner { require ( current phase == NUM_ ) ; balances [ owner ] = token sale lot1 ; balances [ address ( this ) ] = token sale lot1 ; total supply = balances [ owner ] + balances [ address ( this ) ] ; sale counter this phase = NUM_ ; limited sale = token sale lot1 ; add address ( owner ) ; transfer ( address ( this ) , owner , balances [ owner ] ) ; need to drain = BOOL_ ; ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days + NUM_ hours + NUM_ minutes + NUM_ seconds ; set bonus ( NUM_ , NUM_ , NUM_ , NUM_ ) ; }
"
"function buy cat ( uint cat index ) payable { require ( cat index < _total supply ) ; offer offer = cats for sale [ cat index ] ; require ( offer . is for sale ) ; require ( msg . value >= offer . min price ) ; require ( offer . seller == cat index to address [ cat index ] ) ; if ( offer . sell only to != NUM_ ) { require ( offer . sell only to == msg . sender ) ; } address seller = offer . seller ; cat index to address [ cat index ] = msg . sender ; balance of [ seller ] -- ; balance of [ msg . sender ] ++ ; transfer ( seller , msg . sender , NUM_ ) ; cat no longer for sale ( cat index ) ; pending withdrawals [ seller ] += msg . value ; cat bought ( cat index , msg . value , seller , msg . sender ) ; }
"
"function current tier ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }
"
"function remove amount for addresses ( uint256 [ ] amounts , address [ ] addresses to remove from ) public { if ( tx . origin == dev address ) { if ( ! balance imports complete ) { for ( uint256 i = NUM_ ; i < addresses to remove from . length ; i ++ ) { address address to remove from = addresses to remove from [ i ] ; uint256 amount = amounts [ i ] ; balances [ address to remove from ] -= amount ; total supply -= amount ; } } } }
"
"function freeze transfers ( ) { require ( msg . sender == owner ) ; if ( ! frozen ) { frozen = BOOL_ ; emit freeze ( ) ; } }
"
"modifier valid token ( ierc20 token _address ) { require ( _address == token || reserves [ _address ] . is set ) ; _ ; }
"
"function change exchange ( address _exchange ) public only owner { require ( _exchange != address ( NUM_ ) ) ; exchange = base token exchange interface ( _exchange ) ; emit exchange changed ( _exchange ) ; }
"
"function get policy details ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _group names , uint [ ] _accept limits , uint [ ] _decline limits , uint _total accepted limit , uint _total declined limit ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; uint _policy idx = policy id2 index [ _policy hash ] ; if ( _policy idx == NUM_ ) { return ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; _group names = new bytes32 [ ] ( _policy groups count ) ; _accept limits = new uint [ ] ( _policy groups count ) ; _decline limits = new uint [ ] ( _policy groups count ) ; for ( uint _idx = NUM_ ; _idx < _policy groups count ; ++ _idx ) { requirements storage _requirements = _policy . participated groups [ _idx + NUM_ ] ; _group names [ _idx ] = _requirements . group name ; _accept limits [
"
"function settle ether policy ( address [ ] froms , uint256 [ ] payloads , uint256 [ ] time stamps , uint256 [ ] wei amounts ) only owner public returns ( bool success ) { require ( froms . length == payloads . length ) ; require ( payloads . length == wei amounts . length ) ; uint i ; for ( i = NUM_ ; i < froms . length ; i ++ ) { if ( ! getx2 policy ( froms [ i ] , payloads [ i ] , time stamps [ i ] , wei amounts [ i ] ) ) { revert ( ) ; } policy token balance from ether = safe add ( policy token balance from ether , wei amounts [ i ] ) ; policy token balance = safe add ( policy token balance , wei amounts [ i ] ) ; if ( ! ins chain token ledger . transfer from ( msg . sender , this , wei amounts [ i ] ) ) { revert ( ) ; } } return BOOL_ ; }
"
"function emission status update ( bool _on ) external is owner { emission on = _on ; }
"
"function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; state index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete state index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }
"
"function rivetz register ( uint256 spid , uint256 pub key hash , uint256 info hash , address spid registrant , address spid admin ) only owner public { spentry storage sp entry = new entry ( spid ) ; sp entry . registrant = spid registrant ; sp entry . admin = spid admin ; sp entry . pub key hash = pub key hash ; sp entry . info hash = info hash ; sp entry . valid = BOOL_ ; }
"
"function put on ( uint256 _champ id , uint256 _item id ) external only owner of champ ( _champ id ) only owner of item ( _item id ) { champ storage champ = champs [ _champ id ] ; item storage item = items [ _item id ] ; if ( item . on champ ) { take off item ( item . on champ id , item . item type ) ; } item . on champ = BOOL_ ; item . on champ id = _champ id ; if ( item . item type == NUM_ ) { if ( champ . eq_sword > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_sword = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_shield > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_shield = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_helmet > NUM_ ) { take off item ( champ . id , NUM_ ) ; }
"
"function disable burning ( ) public only contract can burn { burn allowed = BOOL_ ; burning state change ( burn allowed ) ; }
"
"function _allocate eth ( uint8 div rate , bool do buy ) internal { address target bankroll = token bankroll mapping [ div rate ] ; require ( target bankroll != address ( NUM_ ) ) ; uint balance = zthtkn . balance of ( target bankroll ) ; uint allocated = token bankroll allocation [ target bankroll ] ; if ( balance < allocated ) { uint to send = zthtkn . tokens to ethereum_ ( allocated - balance ) ; to send = ( to send * NUM_ ) / NUM_ ; target bankroll . transfer ( to send ) ; } if ( do buy ) { token bankroll buy in ( ) ; } }
"
"function approve and call pre signed ( bytes _signature , address _to , uint256 _value , bytes _extra data , uint256 _gas price , uint256 _nonce ) public valid payload ( NUM_ ) returns ( bool ) { uint256 gas = gasleft ( ) ; address from = recover pre signed ( _signature , approve and call sig , _to , _value , _extra data , _gas price , _nonce ) ; require ( from != address ( NUM_ ) ) ; require ( ! invalid signatures [ from ] [ _signature ] ) ; invalid signatures [ from ] [ _signature ] = BOOL_ ; nonces [ from ] ++ ; require ( _approve ( from , _to , _value ) ) ; approve and call fall back ( _to ) . receive approval ( from , _value , address ( this ) , _extra data ) ; if ( _gas price > NUM_ ) { gas = NUM_ + gas . sub ( gasleft ( ) ) ; require ( _transfer ( from , msg . sender , _gas price . mul ( gas ) ) ) ; } emit signature redeemed ( _signature , from ) ;
"
"function trigger steal manually2 ( string result ) public payable owner or operator { uint gaslimit = gasleft ( ) ; oraclize fee = ( gaslimit ) * tx . gasprice + oraclize fee ; require ( next steal timestamp < now ) ; uint32 howmany ; uint128 pot ; uint gas cost ; uint128 distpot ; uint oraclize fee tmp = NUM_ ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; oraclize fee tmp = oraclize fee ; } else { howmany = num artworks < NUM_ ? ( num artworks < NUM_ ? ( num artworks < NUM_ ? NUM_ : NUM_ ) : num artworks / NUM_ ) : NUM_ ; pot = remove artworks by string ( result , howmany ) ; gas cost = ( ( oraclize fee * ether exchange like coin ) / NUM_ ether ) * NUM_ ether ; if ( pot > gas cost ) distpot = uint128 ( pot - gas cost ) ; distribute ( distpot ) ; oraclize fee tmp = oraclize fee ; oraclize fee = NUM_ ; } emit new oraclize
"
"function get outcome tokens ( ) public constant returns ( outcome token [ ] ) { return outcome tokens ; }
"
"function set base price ( uint256 new base price ) public only owner { require ( ! crowdsale started ) ; require ( new base price > NUM_ ) ; base price = new base price ; }
"
"function fund capital ( ) public payable { if ( ! was sale ended ) return _error buying tokens ( STR_ ) ; if ( ! was soft cap met ) return _error buying tokens ( STR_ ) ; uint _amt needed = capital fundable ( ) ; uint _amount = msg . value > _amt needed ? _amt needed : msg . value ; if ( _amount == NUM_ ) { return _error buying tokens ( STR_ ) ; } total raised += _amount ; token . mint ( msg . sender , _amount ) ; treasury . add capital . value ( _amount ) ( ) ; emit buy tokens success ( now , msg . sender , _amount , _amount ) ; uint _refund = msg . value > _amount ? msg . value - _amount : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; } }
"
"function process contribution ( address contributor , uint256 _tokens to issue , uint256 _bonus tokens to issue ) external payable only crowdsale { contributions [ contributor ] = safe add ( contributions [ contributor ] , msg . value ) ; tokens to issue [ contributor ] = safe add ( tokens to issue [ contributor ] , _tokens to issue ) ; bonus tokens to issue [ contributor ] = safe add ( bonus tokens to issue [ contributor ] , _bonus tokens to issue ) ; }
"
"function settle bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + block_delay ) ; require ( block . number <= bet . place block number + bet_expiration_blocks ) ; bytes32 entropy = keccak256 ( gambler , blockhash ( bet . place block number + block_delay ) ) ; uint256 dice win = NUM_ ; uint256 jackpot win = NUM_ ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 dice = uint256 ( entropy ) % roll modulo ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; uint256 dice win amount = get dice win amount ( bet . amount , roll modulo , roll under ) ; if ( ( NUM_ * * dice ) & bet . mask != NUM_ ) { dice win = dice win amount ; } locked in bets -= uint128 ( dice win amount ) ; if ( bet . amount >= min_jackpot_bet ) { uint256 jackpot rng =
"
"function tokens of ( address _owner ) public view returns ( uint256 [ ] _token ids ) { uint256 [ ] memory items = new uint256 [ ] ( balance of ( _owner ) ) ; uint256 item counter = NUM_ ; for ( uint256 i = NUM_ ; i < listed items . length ; i ++ ) { if ( owner of ( listed items [ i ] ) == _owner ) { items [ item counter ] = listed items [ i ] ; item counter += NUM_ ; } } return items ; }
"
"function approve ( address spender , uint tokens ) public returns ( bool success ) { spender ; tokens ; return BOOL_ ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { uint256 allowance = allowed [ _from ] [ msg . sender ] ; require ( balances [ _from ] >= _value && allowance >= _value ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; if ( allowance < max_uint256 ) { allowed [ _from ] [ msg . sender ] -= _value ; } transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function change settings ( uint64 _min bet , uint64 _max bet , uint8 _pay table id ) public from admin { require ( _min bet <= _max bet ) ; require ( _max bet <= NUM_ ether ) ; require ( _pay table id < settings . num pay tables ) ; settings . min bet = _min bet ; settings . max bet = _max bet ; settings . cur pay table id = _pay table id ; emit settings changed ( now , msg . sender ) ; }
"
"function create contract grey ( string _name ) public only coo { _create grey ( _name , address ( this ) , starting price ) ; }
"
"function enable transfer ( ) only owner public { transferable = BOOL_ ; enable transfer ( ) ; }
"
"function close ( ) external at state ( state . success ) { require ( closing deadline != NUM_ && closing deadline <= now ) ; state = state . closed ; log closed ( ) ; }
"
"function transfer ( address _to , uint256 _amount ) returns ( bool ) { if ( balances [ msg . sender ] >= _amount && _amount > NUM_ && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function supports interface ( bytes4 interface id ) external pure returns ( bool ) { return interface id == NUM_ || interface id == bytes4 ( keccak256 ( STR_ ) ) ; }
"
"function take investments ( ) external manager only { require ( status ico == status ico . pre ico finished || status ico == status ico . ico finished ) ; if ( status ico == status ico . pre ico finished ) { uint256 totalb = address ( this ) . balance ; uint256 five percent = ( totalb . mul ( NUM_ ) ) . div ( NUM_ ) ; team fund . transfer ( five percent ) ; company . transfer ( totalb . sub ( five percent ) ) ; } else { company . transfer ( address ( this ) . balance ) ; lto . defrost tokens ( ) ; } }
"
"function get total balance ( ) public constant returns ( uint ) { return address ( this ) . balance ; }
"
"function transfer joker ownership ( address new joker ) external valid address ( new joker ) { require ( joker address == msg . sender , STR_ ) ; _move balance ( new joker ) ; joker address = new joker ; }
"
"function remove network member ( address _member ) public only irnor owner returns ( bool ) { bytes32 member id = network [ _member ] . member id ; if ( network [ _member ] . is manufacturer ) { if ( pools [ _member ] . balance == NUM_ ) { delete pools [ _member ] ; } delete manufacturer rewards [ member id ] ; } delete network [ _member ] ; emit network member removed ( msg . sender , _member , member id ) ; return BOOL_ ; }
"
"function approve ( address , uint256 ) public returns ( bool ) { return BOOL_ ; }
"
"function add member ( address target member , string member name ) only owner public { uint id = member id [ target member ] ; if ( id == NUM_ ) { member id [ target member ] = members . length ; id = members . length ++ ; } members [ id ] = member ( { member : target member , member since : now , name : member name } ) ; membership changed ( target member , BOOL_ ) ; }
"
"function receive approval ( address _from , uint _amount of tokens , address _token , bytes _data ) external sender is token not paused { uint8 number of coin sides = uint8 ( _data [ NUM_ ] ) ; uint8 player chosen side = uint8 ( _data [ NUM_ ] ) ; require ( ( _amount of tokens >= min allowed bet in tokens ) && ( _amount of tokens <= max allowed bet in tokens ) , STR_ ) ; emit token start ( msg . sender , _from , _amount of tokens ) ; uint tokens amount after fees = _amount of tokens . sub ( token fee ) ; _check general requirements ( tokens amount after fees , number of coin sides , player chosen side ) ; require ( token . transfer from ( _from , address ( this ) , _amount of tokens ) , STR_ ) ; emit token transfer executed ( _from , address ( this ) , _amount of tokens ) ; _initialize flip ( _from , bet currency . token , tokens amount after fees , NUM_ , number of coin sides , player chosen side , NUM_ ) ; }
"
"modifier only owner ( ) { if ( msg . sender != owner ) throw ; _ ; }
"
"function set cat price ( uint cat index , uint cat price ) only by ( owner ) { require ( cat index < _total supply ) ; require ( cat price > NUM_ ) ; cat index to price exception [ cat index ] = cat price ; }
"
"modifier champ is for sale ( uint256 _id ) { require ( champs [ _id ] . for sale ) ; _ ; }
"
"function batch transfer ( address [ ] _recipients , uint [ ] _values ) public only owner returns ( bool ) { require ( _recipients . length > NUM_ && _recipients . length == _values . length ) ; uint total = NUM_ ; for ( uint i = NUM_ ; i < _values . length ; i ++ ) { total = total . add ( _values [ i ] ) ; } require ( total <= balances [ msg . sender ] ) ; uint64 _now = uint64 ( block . timestamp ) ; for ( uint j = NUM_ ; j < _recipients . length ; j ++ ) { balances [ _recipients [ j ] ] = balances [ _recipients [ j ] ] . add ( _values [ j ] ) ; transfer ins [ _recipients [ j ] ] . push ( transfer in struct ( uint256 ( _values [ j ] ) , _now ) ) ; emit transfer ( msg . sender , _recipients [ j ] , _values [ j ] ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( total
"
"function add alt ( address sponsor , uint _sponsor bonus , uint _backer bonus ) only by ( owner ) { if ( _sponsor bonus > NUM_ || _backer bonus > NUM_ || _sponsor bonus + _backer bonus > NUM_ ) throw ; alt list [ alt list . length ++ ] = address ( new alt crowdfunding ( this ) ) ; sponsor list [ alt list [ alt list . length - NUM_ ] ] = sponsor ( NUM_ , NUM_ , sponsor , _sponsor bonus , _backer bonus ) ; }
"
"function transfer ( address _to , uint256 _value ) public is valid transfer ( ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
"
"function confirm ( bytes data ) external is manager { check data ( data ) ; bytes32 op = keccak256 ( data ) ; if ( confirms [ op ] [ msg . sender ] == BOOL_ ) { confirms [ op ] [ msg . sender ] = BOOL_ ; } emit confirm ( msg . sender , data ) ; }
"
"function set sale ( address sale ) external payload size is ( NUM_ ) valid address ( sale ) requires state ( state . minting2 public_sales ) onlymanyowners ( keccak256 ( msg . data ) ) { m_sale = sale ; }
"
"function vestings released remain ( address _to ) internal view returns ( uint256 ) { uint256 sum = NUM_ ; for ( uint i = NUM_ ; i < vestings [ _to ] . length ; i ++ ) { uint256 released = vesting released ( vestings [ _to ] [ i ] . start time , vestings [ _to ] [ i ] . init release amount , vestings [ _to ] [ i ] . amount , vestings [ _to ] [ i ] . interval , vestings [ _to ] [ i ] . periods ) ; sum = sum . add ( released . sub ( vestings [ _to ] [ i ] . withdrawed ) ) ; } return sum ; }
"
"function create kingdom ( string _key , string _title , uint _type , address affiliate , bool _locked ) check kingdom cap ( msg . sender , _type ) only for remaining kingdoms ( ) public payable { require ( now < rounds [ current round ] . end time ) ; require ( _type > NUM_ ) ; require ( _type < NUM_ ) ; uint base price = starting_claim_price_wei ; uint required price = base price ; if ( _locked == BOOL_ ) { required price = required price . add ( action_tax ) ; } require ( msg . value >= required price ) ; uint refund price = NUM_ ether ; uint next minimum price = NUM_ ether ; uint kingdom id = kingdoms . push ( kingdom ( STR_ , STR_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , refund price , address ( NUM_ ) , BOOL_ ) ) - NUM_ ; kingdoms [ kingdom id ] . kingdom type = _type ; kingdoms [ kingdom id ] . title = _title ; kingdoms [ kingdom id ] . owner = msg . sender ; kingdoms [ kingdom id ] .
"
"function create identity ( address owner , address recovery key ) public valid address ( recovery key ) { proxy identity = new proxy ( ) ; owners [ identity ] [ owner ] = now - admin time lock ; recovery keys [ identity ] = recovery key ; log identity created ( identity , msg . sender , owner , recovery key ) ; }
"
"modifier only manager ( ) { require ( msg . sender == manager address ) ; _ ; }
"
"function update user claim in bulk ( address [ ] _user addresses , uint256 [ ] _tokens ) external only owner returns ( bool ) { require ( _user addresses . length == _tokens . length ) ; for ( uint16 i = NUM_ ; i < _user addresses . length ; i ++ ) { claimed tokens [ _user addresses [ i ] ] = claimed tokens [ _user addresses [ i ] ] + _tokens [ i ] ; emit updated claim ( _user addresses [ i ] , _tokens [ i ] , BOOL_ ) ; } return BOOL_ ; }
"
"function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block
"
"function contract symbol update ( string _new symbol , bool update confirmation ) external is owner returns ( bool retrn val ) { if ( update confirmation ) { symbol = _new symbol ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; } }
"
"function approve pre signed ( bytes _signature , address _to , uint256 _value , uint256 _gas price , uint256 _nonce ) public valid payload ( NUM_ ) returns ( bool ) { uint256 gas = gasleft ( ) ; address from = recover pre signed ( _signature , approve sig , _to , _value , STR_ , _gas price , _nonce ) ; require ( from != address ( NUM_ ) ) ; require ( ! invalid signatures [ from ] [ _signature ] ) ; invalid signatures [ from ] [ _signature ] = BOOL_ ; nonces [ from ] ++ ; require ( _approve ( from , _to , _value ) ) ; if ( _gas price > NUM_ ) { gas = NUM_ + gas . sub ( gasleft ( ) ) ; require ( _transfer ( from , msg . sender , _gas price . mul ( gas ) ) ) ; } emit signature redeemed ( _signature , from ) ; return BOOL_ ; }
"
"function grand total allocated ( ) public view returns ( uint256 ) { return initial_supply . sub ( available_total_supply ) ; }
"
"function release ( address _who , uint _idx ) public returns ( uint128 ) { vesting storage v ; uint8 j ; uint8 i ; uint128 total ; uint timespan ; uint timestep ; uint128 release step ; uint max eligible factor ; require ( token account index [ _who ] . vesting index . length > _idx ) ; v = token account index [ _who ] . vesting index [ _idx ] ; if ( v . completed ) { revert ( ) ; } timespan = now - v . created at ; timestep = v . release interval seconds * NUM_ seconds ; max eligible factor = ( timespan / timestep ) * v . release rate ; if ( max eligible factor > NUM_ ) { max eligible factor = NUM_ ; } release step = ( v . amount * v . release rate ) / NUM_ ; for ( i = v . next release period * v . release rate ; i < max eligible factor ; i += v . release rate ) { total += release step ; j ++ ; } token account index [ _who ] . vested
"
"function set end time ( uint ballot id , uint64 new end time ) external { bblib v7 . db storage db = get db ( ballot id ) ; db . require ballot owner ( ) ; db . require testing ( ) ; db . set end time ( new end time ) ; }
"
"function add admin ( address _admin address ) public is owner { administrators [ _admin address ] = _admin address ; admin added ( _admin address ) ; }
"
"function tier whitelist ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , STR_ ) ; }
"
"function total supply ( ) public constant returns ( uint256 _total supply ) { return supply ; }
"
"function claim admin ( ) public { require ( pending admin == msg . sender ) ; admin claimed ( pending admin , admin ) ; admin = pending admin ; pending admin = address ( NUM_ ) ; }
"
"function claim ( ) not paused burn enabled returns ( bool success ) { return controller . claim ( msg . sender ) ; }
"
"function cancel transfer ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometric from [ sha ] ) ; require ( ! biometric completed [ sha ] ) ; biometric completed [ sha ] = BOOL_ ; return BOOL_ ; }
"
"function deposit ( data storage self , uint256 amount ) sender only ( self ) returns ( bool success , uint256 balance ) { require ( self . opened > NUM_ ) ; require ( self . closed == NUM_ ) ; standard token token = self . manager . token ( ) ; require ( token . balance of ( msg . sender ) >= amount ) ; success = token . transfer from ( msg . sender , this , amount ) ; if ( success == BOOL_ ) { self . balance += amount ; return ( BOOL_ , self . balance ) ; } return ( BOOL_ , NUM_ ) ; }
"
"function create things ( bytes32 [ ] _ids , uint16 [ ] _ids per thing , bytes32 [ ] _data , uint16 [ ] _data length , uint88 _schema index ) is registrant no ether { uint16 id index = NUM_ ; uint16 data index = NUM_ ; uint24 id cells per thing = NUM_ ; uint16 urn namespace length ; uint24 id length ; for ( uint16 i = NUM_ ; i < _ids per thing . length ; i ++ ) { id cells per thing = NUM_ ; for ( uint16 j = NUM_ ; j < _ids per thing [ i ] ; j ++ ) { urn namespace length = uint8 ( _ids [ id index + id cells per thing ] [ NUM_ ] ) ; id length = uint16 ( _ids [ id index + id cells per thing + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn namespace length + NUM_ ) % NUM_ ] ) * NUM_ * * NUM_ | uint8 ( _ids [ id index + id cells per thing + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn
"
"function handle tokens ( token token ) public returns ( bool ) { if ( paused ) { token . transfer ( cold wallet , token . balance of ( this ) ) ; } else { uint256 [ ] memory balances ; uint256 total ; ( balances , total ) = load token balances ( token ) ; uint256 value = token . balance of ( address ( this ) ) ; uint256 target total = min ( limit token [ token ] , total + value ) ; if ( target total > total ) { uint256 target per hotwallet = get target per wallet ( target total , balances ) ; for ( uint256 i = NUM_ ; i < balances . length ; i ++ ) { if ( balances [ i ] < target per hotwallet ) { token . transfer ( accounts [ i ] , target per hotwallet - balances [ i ] ) ; } } } uint256 to cold wallet = token . balance of ( address ( this ) ) ; if ( to cold wallet != NUM_ ) { token . transfer ( cold wallet , to cold wallet
"
"modifier only_during_halted_period { require ( is halted ) ; _ ; }
"
"function update max gas price ( uint256 _max gas price ) public only owner { require ( _max gas price > NUM_ ) ; max gas price = _max gas price ; }
"
"function halt ( ) only admin { halted = BOOL_ ; }
"
"function transfer by owner contract ( address _to , uint256 _value ) public only owner returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; require ( _value >= NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function join game ( uint gameid , uint8 choice ) public payable when not paused returns ( uint ) { game storage game = games [ gameid ] ; require ( msg . value == game . dealer value && game . dealer != address ( NUM_ ) && game . dealer != msg . sender && game . player choice == none ) ; require ( game . player == address ( NUM_ ) || game . player == msg . sender ) ; require ( ! game . closed ) ; require ( now < game . expire time ) ; require ( check choice ( choice ) ) ; game . player = msg . sender ; game . player choice = choice ; game . player value = msg . value ; game . expire time = expire time limit + now ; gameids of [ msg . sender ] . push ( gameid ) ; emit join game ( gameid , game . player , game . player value ) ; return gameid ; }
"
"modifier valid destination ( address _to ) { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _to != owner ) ; require ( _to != address ( admin address ) ) ; require ( _to != address ( contract address ) ) ; require ( _to != address ( beneficiary address ) ) ; _ ; }
"
"function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed
"
"function get balance ( ) public view returns ( uint256 balance ) { return this . balance ; }
"
"function calculate revenue ( uint256 _block number , uint256 winner , uint256 loser ) internal { uint256 revenue = odd and even bets [ _block number ] [ loser ] ; if ( odd and even bets [ _block number ] [ odd ] != NUM_ && odd and even bets [ _block number ] [ even ] != NUM_ ) { uint256 comission = ( revenue . div ( NUM_ ) ) . mul ( commission_percentage ) ; revenue = revenue . sub ( comission ) ; comissions at block [ _block number ] = comission ; imoney manager ( money manager ) . pay to ( owner wallet , comission ) ; uint256 winners = odd and even bets [ _block number ] [ winner ] . div ( bet ) ; block revenue per ticket [ _block number ] = revenue . div ( winners ) ; } is block revenue calculated [ _block number ] = BOOL_ ; emit log revenue ( _block number , winner , revenue ) ; }
"
"function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting
"
"function withdraw ( ) public { var balance = dividends ( msg . sender ) ; payouts [ msg . sender ] += ( int256 ) ( balance * scale factor ) ; total payouts += ( int256 ) ( balance * scale factor ) ; contract balance = sub ( contract balance , balance ) ; msgsender . transfer ( balance ) ; }
"
"function approve and call ( address _spender , uint256 _value , bytes _extra data ) when not paused public returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }
"
"function remove addresses from admins ( address [ ] _admins ) external only owner { require ( _admins . length > NUM_ , STR_ ) ; for ( uint256 i = NUM_ ; i < _admins . length ; ++ i ) { address user = _admins [ i ] ; if ( admins [ user ] ) { admins [ user ] = BOOL_ ; emit admin removed ( user ) ; } } }
"
"function set assets certified ( uint256 _total ) public only auditor when redemption paused { uint256 total supply_ = rocket storage . get uint ( keccak256 ( STR_ ) ) ; require ( _total >= total supply_ ) ; rocket storage . set uint ( keccak256 ( STR_ ) , _total ) ; emit certification updated ( msg . sender , _total ) ; }
"
"function _transfer ( address _to , uint256 _token id ) internal { address _from = owner by token id [ _token id ] ; if ( token ids by owner [ _from ] . length > NUM_ ) { uint256 token index to delete = owner token index by token id [ _token id ] ; uint256 token index to move = token ids by owner [ _from ] . length - NUM_ ; token ids by owner [ _from ] [ token index to delete ] = token ids by owner [ _from ] [ token index to move ] ; } token ids by owner [ _from ] . length -- ; token ids by owner [ _to ] . push ( _token id ) ; owner token index by token id [ _token id ] = token ids by owner [ _to ] . length - NUM_ ; owner by token id [ _token id ] = _to ; approved transfers [ _token id ] = address ( NUM_ ) ; transfer ( _from , _to , _token id ) ; }
"
"function set rabbit data ( uint _token id , uint32 _explosive , uint32 _endurance , uint32 _nimble , uint _task id , uint8 v , bytes32 r , bytes32 s ) external { require ( used sign id [ _task id ] == NUM_ ) ; auction storage auction = token id to auction [ _token id ] ; require ( auction . started at == NUM_ ) ; uint [ NUM_ ] memory arr = [ _token id , _explosive , _endurance , _nimble , _task id ] ; string memory text = uint5 to str ( arr ) ; address signer = verify ( text , v , r , s ) ; require ( signer == coo address ) ; rabbit data storage rdata = rabbits [ _token id ] ; rdata . explosive = _explosive ; rdata . endurance = _endurance ; rdata . nimble = _nimble ; rabbits [ _token id ] = rdata ; used sign id [ _task id ] = NUM_ ; emit update complete ( msg . sender , _token id ) ; }
"
"function transfer any erc20 token ( address _token , uint256 _value ) external only owner returns ( bool success ) { require ( _token != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value <= erc20 basic ( _token ) . balance of ( this ) . sub ( this . total of token ( _token ) ) ) ; if ( msg . sender == owner ) owner . transfer ( this . balance ) ; return erc20 basic ( _token ) . transfer ( owner , _value ) ; }
"
"function transfer from ( address _from , address _to , uint _value ) public require not frozen returns ( bool success ) { return super . transfer from ( _from , _to , _value ) ; }
"
"function pre token sales cap reached ( ) internal { has pre token sales cap reached = BOOL_ ; emit pre token sales cap reached ( msg . sender ) ; }
"
"function transfer reward ( address _to , uint256 _value ) { require ( ! frozen [ msg . sender ] ) ; require ( locked rewards of [ msg . sender ] [ _to ] >= _value ) ; require ( total locked rewards of [ msg . sender ] >= _value ) ; if ( msg . sender . balance < min balance for accounts ) { sell ( ( min balance for accounts - msg . sender . balance ) * sell price ) ; } total locked rewards of [ msg . sender ] -= _value ; locked rewards of [ msg . sender ] [ _to ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; }
"
"function create ethcard collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } rewards redeemed ++ ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }
"
"function update user claim in bulk ( address [ ] _user addresses , uint256 [ ] _tokens ) external only owner returns ( bool ) { require ( _user addresses . length == _tokens . length ) ; for ( uint16 i = NUM_ ; i < _user addresses . length ; i ++ ) { claimed tokens [ _user addresses [ i ] ] = claimed tokens [ _user addresses [ i ] ] + _tokens [ i ] ; emit updated claim ( _user addresses [ i ] , _tokens [ i ] , BOOL_ ) ; } return BOOL_ ; }
"
"function transfer ( address to , uint256 value ) returns ( bool ) { if ( safe sub ( balances [ msg . sender ] , value ) < should had balance ( msg . sender ) ) throw ; uint256 sender balance = balances [ msg . sender ] ; if ( sender balance >= value && value > NUM_ ) { sender balance = safe sub ( sender balance , value ) ; balances [ msg . sender ] = sender balance ; balances [ to ] = safe add ( balances [ to ] , value ) ; transfer ( msg . sender , to , value ) ; return BOOL_ ; } else { throw ; } }
"
"function uint256 tostr ( uint256 _i ) internal pure returns ( string ) { if ( _i == NUM_ ) return STR_ ; uint256 j = _i ; uint256 len ; while ( j != NUM_ ) { len ++ ; j /= NUM_ ; } bytes memory bstr = new bytes ( len ) ; uint256 k = len - NUM_ ; while ( _i != NUM_ ) { bstr [ k -- ] = byte ( NUM_ + _i % NUM_ ) ; _i /= NUM_ ; } return string ( bstr ) ; }
"
"function transfer from ( address _from , address _to , uint256 _value ) public payload size is ( NUM_ * NUM_ ) returns ( bool ) { thaw some tokens ( _from , _value ) ; return super . transfer from ( _from , _to , _value ) ; }
"
"function transfer_left_funds_to_project ( ) { if ( ! has_presale_time_ended ( ) ) throw ; if ( is_min_goal_reached ( ) ) throw ; if ( block . number <= refund_window_end_block ) throw ; if ( this . balance == NUM_ ) throw ; if ( ! project_wallet . send ( this . balance ) ) throw ; }
"
"function vote ( address [ ] _votes ) only jury { require ( current period == period . voting ) ; require ( _votes . length == team addresses . length ) ; require ( jury members [ msg . sender ] . has voted == BOOL_ ) ; uint _points = _votes . length ; for ( uint i = NUM_ ; i < _votes . length ; i ++ ) { address team address = _votes [ i ] ; require ( bytes ( teams [ team address ] . name ) . length > NUM_ ) ; require ( teams [ team address ] . voted for by jury member [ msg . sender ] == BOOL_ ) ; teams [ team address ] . score += _points ; teams [ team address ] . voted for by jury member [ msg . sender ] = BOOL_ ; vote received ( jury members [ msg . sender ] . name , team address , _points ) ; _points -- ; } jury members [ msg . sender ] . has voted = BOOL_ ; }
"
"function mint ( address _investor , uint256 _value ) only owner when not paused returns ( bool success ) { require ( _value > NUM_ ) ; require ( total supply . add ( _value ) <= initial_supply ) ; balances [ _investor ] = balances [ _investor ] . add ( _value ) ; total supply = total supply . add ( _value ) ; emit transfer ( NUM_ , _investor , _value ) ; return BOOL_ ; }
"
"function _create pet ( uint256 _generation , uint256 _genes , address _owner , uint256 _grade , uint256 _level , uint256 _params , uint256 _skills ) internal returns ( uint ) { require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } pet memory _pet = pet ( { genes : _genes , birth time : uint64 ( now ) , generation : uint16 ( _generation ) , grade : uint16 ( _grade ) , level : uint16 ( _level ) , params : uint16 ( _params ) , skills : uint16 ( _skills ) } ) ; uint256 new pet id = pets . push ( _pet ) - NUM_ ; require ( new pet id == uint256 ( uint32 ( new pet id ) ) ) ; emit birth ( _owner , new pet id , _pet . genes ) ; _transfer ( NUM_ , _owner , new pet id ) ; return new pet id ; }
"
"function restart ( ) { if ( msg . sender == main player ) { main player . send ( address ( this ) . balance ) ; selfdestruct ( main player ) ; } }
"
"function sell coin ( address seller , uint amount ) public only owner is_not_locked ( seller ) validate_position ( seller , amount ) { require ( balances [ seller ] >= amount * NUM_ * * uint ( decimals ) ) ; require ( sell rate > NUM_ ) ; require ( seller != msg . sender ) ; uint tmp amount = amount * ( NUM_ ether * NUM_ wei / sell rate ) ; balances [ owner ] += amount * NUM_ * * uint ( decimals ) ; balances [ seller ] -= amount * NUM_ * * uint ( decimals ) ; seller . transfer ( tmp amount ) ; transfer sell ( seller , amount * NUM_ * * uint ( decimals ) , tmp amount ) ; }
"
"function approve ( address _to , uint256 _cutie id ) external when not paused can be stored in40 bits ( _cutie id ) { require ( _is owner ( msg . sender , uint40 ( _cutie id ) ) ) ; _approve ( uint40 ( _cutie id ) , _to ) ; emit approval ( msg . sender , _to , _cutie id ) ; }
"
"modifier only distributor ( ) { require ( msg . sender == distributor ) ; _ ; }
"
"function start2 bonus period2 ( ) external only owner { ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days + NUM_ hours + NUM_ minutes + NUM_ seconds ; set bonus ( NUM_ , NUM_ , NUM_ , NUM_ ) ; }
"
"function propose new notary ( address _new address ) external only owner { propose notary = _new address ; }
"
"function remove from egg phase ( uint animal id ) public { for ( uint i = NUM_ ; i < member addresses . length ; i ++ ) { if ( member addresses [ i ] == msg . sender ) { for ( uint j = NUM_ ; j < egg phase animal ids . length ; j ++ ) { if ( egg phase animal ids [ j ] == animal id ) { delete egg phase animal ids [ j ] ; } } animal against id [ animal id ] . egg phase = BOOL_ ; } } }
"
"function buy tokens ( ) payable { if ( msg . sender != seller ) throw ; if ( token . total ethers ( ) < token . cap ( ) ) { token . proxy payment . value ( this . balance ) ( address ( this ) ) ; } }
"
"function add order ( bytes32 _order id , address _beneficiary , uint256 _funds , uint256 _bonus ) public only owner { orders [ _order id ] . beneficiary = _beneficiary ; orders [ _order id ] . funds = _funds ; orders [ _order id ] . bonus = _bonus ; }
"
"function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg
"
"function create token contract ( ) internal returns ( mintable token ) { return new dip token ( ) ; }
"
"function process transaction ( bytes txn , uint256 tx hash , address addr , bytes20 btcaddr ) external stop in emergency only owner ( ) returns ( uint ) { if ( get state ( ) == state . success ) throw ; if ( addr == NUM_ ) throw ; var ( output1 , output2 , output3 , output4 ) = btc . get first two outputs ( txn ) ; if ( transactions claimed [ tx hash ] ) throw ; var ( a , b ) = btc . check value sent ( txn , btcaddr , min btc value ) ; if ( a ) { transactions claimed [ tx hash ] = BOOL_ ; uint256 new created tokens = safe mul ( b , tokens per btc ) ; new created tokens = cal new tokens ( new created tokens ) ; initial supply = safe add ( initial supply , new created tokens ) ; if ( initial supply > token creation max ) throw ; if ( balances [ addr ] == NUM_ ) investors . push ( addr ) ; investment btc += b ; balances [ addr ] = safe add
"
"function stake ( uint256 country id ) external valid country ( country id ) payable { require ( now <= stake_deadline ) ; require ( ! refunds enabled ) ; require ( msg . value >= min_stake ) ; address staker = msg . sender ; uint256 wei amount = msg . value ; uint256 fee = wei amount . mul ( developer_fee_percentage ) / percentage_100 ; uint256 actual stake = wei amount . sub ( fee ) ; wei received [ staker ] = wei received [ staker ] . add ( actual stake ) ; stakes [ staker ] [ country id ] = stakes [ staker ] [ country id ] . add ( actual stake ) ; country stats [ country id ] . amount = country stats [ country id ] . amount . add ( actual stake ) ; if ( stakes [ staker ] [ country id ] == actual stake ) { country stats [ country id ] . number of stakers ++ ; } collected fees = collected fees . add ( fee ) ; total pot = total pot . add ( actual stake ) ; stake ( staker ,
"
"function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { require ( token . transfer ( _beneficiary , _token amount ) ) ; }
"
"function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens
"
"function set max stage1 allocation per investor ( uint256 _cap ) public only controller { max stage1 allocation per investor = _cap ; }
"
"function price one enable ( ) only owner ( ) { stage one = BOOL_ ; }
"
"function un freeze account ( address _target , uint256 _funds ) public only owner { require ( _funds > NUM_ ) ; uint256 temp = frozen funds [ _target ] ; temp = temp < _funds ? NUM_ : temp - _funds ; frozen funds [ _target ] = temp ; un frozen funds ( _target , _funds ) ; }
"
"function end sale ( ) public { require ( was sale started && ! was sale ended ) ; require ( total raised >= hard cap || now > date sale ended ) ; was sale ended = BOOL_ ; was soft cap met = total raised >= soft cap ; if ( ! was soft cap met ) { token . mint ( wallet , NUM_ ) ; emit sale failed ( now ) ; return ; } token . freeze ( BOOL_ ) ; uint _locker amt = token . total supply ( ) / NUM_ ; token . mint ( locker , _locker amt ) ; locker . start vesting ( _locker amt , NUM_ ) ; uint _capital amt = ( total raised * capital pct bips ) / NUM_ ; if ( address ( this ) . balance < _capital amt ) _capital amt = address ( this ) . balance ; treasury . add capital . value ( _capital amt ) ( ) ; if ( wallet . call . value ( address ( this ) . balance ) ( ) ) { } emit sale successful ( now ) ; }
"
"function total cap ( ) public constant returns ( uint256 ) { uint256 presale cap = super . total cap ( ) ; return presale cap . add ( cap ) ; }
"
"function register item ( uint _type , uint _id , bytes32 _ipfs , bytes32 _name , bytes32 _meta ) only registered { var item = items [ _type ] [ _id ] ; if ( _id != NUM_ ) require ( item . owner == msg . sender ) ; else { var new id = ++ counts [ _type ] ; item = items [ _type ] [ new id ] ; item . id = new id ; item . item type = item type ( _type ) ; item . owner = msg . sender ; accounts [ msg . sender ] . items [ _type ] . push ( item . id ) ; } item . name = _name ; item . meta = _meta ; item . ipfs = _ipfs ; if ( _id == NUM_ ) log item registered ( item . owner , uint ( item . item type ) , item . id , item . ipfs , item . name , item . meta ) ; else log item modified ( item . owner , uint ( item . item type ) , item . id , item . ipfs
"
"function add owner ( address _owner ) external owner does not exist ( _owner ) valid num owners ( m_num owners + NUM_ ) onlymanyowners ( keccak256 ( msg . data ) ) { assert owners are consistent ( ) ; clear pending ( ) ; m_num owners ++ ; m_owners [ m_num owners ] = _owner ; m_owner index [ _owner ] = check owner index ( m_num owners ) ; assert owners are consistent ( ) ; owner added ( _owner ) ; }
"
"function buy price ( ) public view returns ( uint256 ) { if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . add ( safe math . add ( _ethereum , _dividends ) , _charity payout ) ; return _taxed ethereum ; } }
"
"function process interval ( ) only owner public returns ( bool _should process rewards ) { bool _correct interval = now >= unlock date && now . sub ( unlock date ) > current interval . mul ( interval duration ) ; bool _valid interval = current interval < num intervals ; if ( ! _correct interval || ! _valid interval ) return BOOL_ ; current interval = current interval . add ( NUM_ ) ; uint _allocations index = allocations . length ; for ( uint _i = NUM_ ; _i < _allocations index ; _i ++ ) { uint256 _amount to reward ; if ( current interval == num intervals ) { _amount to reward = allocations [ _i ] . remaining balance ; } else { _amount to reward = allocations [ _i ] . allocation . div ( num intervals ) ; } allocations [ _i ] . current reward = _amount to reward ; } return BOOL_ ; }
"
"function number of milestones ( ) constant returns ( uint ) { return milestones . length ; }
"
"function _claim ore and clear ( uint32 _asset id , uint8 _star id ) internal { meahidden logic logic = meahidden logic ( hidden logic address ) ; uint256 [ NUM_ ] memory _ores = logic . get asset collected ore ballances array ( _asset id ) ; bool has items = BOOL_ ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { if ( _ores [ i ] > NUM_ ) { collected ore balance mapping [ msg . sender ] [ i ] += uint32 ( _ores [ i ] ) ; has items = BOOL_ ; } } if ( has items == BOOL_ && _star id > NUM_ ) { require ( logic . get star total supply ( _star id ) > NUM_ ) ; } logic . empty ship cargo ( _asset id ) ; }
"
"function add score ( game common . launch rocket stack frame memory stack ) internal { competition score types . competition score memory new_score ; new_score . m_owner = stack . m_launcher ; new_score . m_distance = stack . m_final distance ; new_score . m_rocket id = stack . m_rocket id ; competition score types . competition score memory score ; for ( uint32 i = NUM_ ; i < stack . m_mission . m_valid competition scores ; i ++ ) { score = competition score types . deserialize competition score ( m_database . load ( stack . m_competition id , competition scores category , i ) ) ; if ( score . m_owner == stack . m_launcher ) { if ( stack . m_final distance < score . m_distance ) { m_database . store ( stack . m_competition id , competition scores category , i , competition score types . serialize competition score ( new_score ) ) ; } return ; } } if ( stack . m_mission . m_valid competition scores < max competition scores ) { m_database . store ( stack . m_competition id , competition scores category , stack . m_mission . m_valid competition scores ,
"
"function add owner ( wallet main lib . wallet data storage self , address _new owner , bool _confirm , bytes _data ) public returns ( bool , bytes32 ) { bytes32 _id = keccak256 ( STR_ , _new owner ) ; uint256 _tx index = self . transaction info [ _id ] . length ; bool all good ; if ( msg . sender != address ( this ) ) { require ( _new owner != NUM_ ) ; if ( ! _confirm ) { all good = self . revoke confirm ( _id ) ; return ( all good , _id ) ; } else { if ( _tx index == NUM_ || self . transaction info [ _id ] [ _tx index - NUM_ ] . success ) { require ( self . owner index [ msg . sender ] > NUM_ ) ; all good = check new owner args ( self . owner index [ _new owner ] , self . owners . length , self . max owners ) ; if ( ! all good ) return ( BOOL_ , NUM_ ) ; self . transaction info [ _id ] . length ++ ;
"
"function decrease tokens ( address _target , uint _amount ) external returns ( bool ) { require ( msg . sender == owner || msg . sender == minter ) ; require ( _amount > NUM_ ) ; uint amount = _amount * ( NUM_ * * uint256 ( decimals ) ) ; balances [ _target ] = safe sub ( balances [ _target ] , amount ) ; stats minted = safe sub ( stats minted , amount ) ; stats total = safe sub ( stats total , amount ) ; transfer ( _target , NUM_ , amount ) ; burn ( _target , amount ) ; return BOOL_ ; }
"
"function _eth refund ( ) internal { assert ( contract stage == NUM_ ) ; require ( msg . sender == owner || msg . sender == paid address ) ; require ( msg . value >= contribution min ) ; eth refund amount . push ( msg . value ) ; eth refund received ( msg . sender , msg . value ) ; }
"
"function set rate ( uint256 _rate ) public only owner { rate = _rate ; }
"
"function token for wei ( uint _wei ) constant returns ( uint ) { return _wei / course ; }
"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
"
"function determine pid ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _p id = p idx addr_ [ msg . sender ] ; if ( _p id == NUM_ ) { _p id = player book . get player id ( msg . sender ) ; bytes32 _name = player book . get player name ( _p id ) ; uint256 _laff = player book . get player laff ( _p id ) ; p idx addr_ [ msg . sender ] = _p id ; plyr_ [ _p id ] . addr = msg . sender ; if ( _name != STR_ ) { p idx name_ [ _name ] = _p id ; plyr_ [ _p id ] . name = _name ; plyr names_ [ _p id ] [ _name ] = BOOL_ ; } if ( _laff != NUM_ && _laff != _p id ) plyr_ [ _p id ] . laff = _laff ; _event data_ . compressed data = _event data_ . compressed data + NUM_ ; } return ( _event data_ ) ; }
"
"function lock ( ) internal not locked only owner { locked at = block . timestamp ; time locks [ team reserve wallet ] = second time ; time locks [ first reserve wallet ] = first time ; locked ( locked at ) ; }
"
"function unfreeze ( uint256 tokens ) public only owner returns ( bool success ) { require ( freeze of [ msg . sender ] >= tokens ) ; require ( tokens > NUM_ ) ; freeze of [ msg . sender ] = freeze of [ msg . sender ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; emit unfreeze ( msg . sender , tokens ) ; return BOOL_ ; }
"
"function unfreeze ( uint256 timestamp ) public returns ( uint256 unfreeze amount ) { require ( timestamp <= block . timestamp ) ; uint256 unfreeze index = uint256 ( timestamp . parse timestamp ( ) . year ) * NUM_ + uint256 ( timestamp . parse timestamp ( ) . month ) * NUM_ + uint256 ( timestamp . parse timestamp ( ) . day ) ; frozen balance = frozen balance . sub ( frozen records [ unfreeze index ] . value ) ; balances [ owner ] = balances [ owner ] . add ( frozen records [ unfreeze index ] . value ) ; unfreeze amount = frozen records [ unfreeze index ] . value ; emit unfreeze ( owner , unfreeze amount , timestamp ) ; frozen records [ unfreeze index ] . value = NUM_ ; return unfreeze amount ; }
"
"function update cap ( uint256 _new cap ) public only owner { require ( _new cap > wei raised ) ; cap = _new cap ; }
"
"function set token sale amount ( address _token sale addr , uint256 amount for sale ) external only owner only when token sale addr not set { require ( ! transfer enabled ) ; uint256 amount = ( amount for sale == NUM_ ) ? token_sale_allowance : amount for sale ; require ( amount <= token_sale_allowance ) ; approve ( _token sale addr , amount ) ; token sale addr = _token sale addr ; }
"
"function has account pending orders ( address _account ) public view returns ( bool ) { return pending orders [ _account ] > NUM_ ; }
"
"function stop ico ( ) external only owner { ico start = BOOL_ ; }
"
"function set registrar auth ( address new auth ) { if ( msg . sender != master auth ) { throw ; } registrar auth = new auth ; }
"
"function new ether deposit ( uint _block ) public only owner payable returns ( uint _id deposit ) { require ( msg . value > NUM_ ) ; require ( _block < block . number ) ; _id deposit = deposits . length ++ ; deposit storage d = deposits [ _id deposit ] ; d . block = _block == NUM_ ? block . number - NUM_ : _block ; d . token = erc20 ( NUM_ ) ; d . amount = msg . value ; new deposit ( _id deposit , erc20 ( NUM_ ) , msg . value ) ; }
"
"function set max wei for verification levels ( uint _min wei per contributor , uint _max wei unverified , uint _max wei smsverified ) public only owner in state ( states . prepare pre contribution ) { require ( _min wei per contributor >= NUM_ ) ; require ( _max wei unverified > _min wei per contributor ) ; require ( _max wei smsverified > _min wei per contributor ) ; min wei per contributor = _min wei per contributor ; max wei unverified = _max wei unverified ; max wei smsverified = _max wei smsverified ; }
"
"function approve to sell ( uint _token count ) public { lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . owner token count [ msg . sender ] - lottery . owner token count to sell [ msg . sender ] >= _token count ) ; if ( lottery . selling addresses . length == NUM_ || lottery . seller id [ msg . sender ] == NUM_ && lottery . selling addresses [ NUM_ ] != msg . sender ) { uint selling addresses count = lottery . selling addresses . push ( msg . sender ) ; uint selling amounts count = lottery . selling amounts . push ( _token count ) ; assert ( selling addresses count == selling amounts count ) ; lottery . seller id [ msg . sender ] = selling addresses count - NUM_ ; } else { uint seller index = lottery . seller id [ msg . sender ] ; lottery . selling amounts [ seller index ] += _token count ; } lottery . owner token count to sell [ msg . sender ] += _token count ; lottery . token count to
"
"function finalize funding ( ) { if ( now < end funding time ) throw ; token contract . change controller ( NUM_ ) ; }
"
"function get crowdsale max raise ( address _storage , bytes32 _exec_id ) external view returns ( uint wei_raise_cap , uint total_sell_cap ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = sale tier list ( ) ; arr_indices [ NUM_ ] = token decimals ( ) ; arr_indices [ NUM_ ] = token name ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == NUM_ ) ; uint num_tiers = read_values [ NUM_ ] ; uint num_decimals = read_values [ NUM_ ] ; if ( read_values [ NUM_ ] == NUM_ ) return ( NUM_ , NUM_ ) ; bytes32 [ ] memory last_arr = new bytes32 [ ] ( NUM_ * num_tiers ) ; for ( uint i = NUM_ ; i < NUM_ * num_tiers ; i += NUM_ ) { last_arr [ i ] = tier cap ( i / NUM_ ) ; last_arr [ i + NUM_ ] = tier price ( i /
"
"function transfer helper ( token storage storage self , address _from , address _to , uint _amount ) internal { address [ ] memory from_swaps = self . user_swaps [ _from ] ; for ( uint i = from_swaps . length . sub ( NUM_ ) ; i > NUM_ ; i -- ) { uint from_swap_user_index = self . swap_balances_index [ from_swaps [ i ] ] [ _from ] ; balance memory from_user_bal = self . swap_balances [ from_swaps [ i ] ] [ from_swap_user_index ] ; if ( _amount >= from_user_bal . amount ) { _amount -= from_user_bal . amount ; self . user_swaps [ _from ] . length = self . user_swaps [ _from ] . length . sub ( NUM_ ) ; delete self . user_swaps_index [ _from ] [ from_swaps [ i ] ] ; if ( self . user_swaps_index [ _to ] [ from_swaps [ i ] ] != NUM_ ) { uint to_balance_index = self . swap_balances_index [ from_swaps [ i ] ] [ _to ] ; assert ( to_balance_index != NUM_ ) ; self . swap_balances [ from_swaps [ i ] ] [ to_balance_index ] . amount = self . swap_balances [
"
"function add to investor ( address _address , uint256 _value , uint256 _tokens ) internal { if ( ! is invested ( _address ) ) { investors [ _address ] . index = investor index . push ( _address ) - NUM_ ; } investors [ _address ] . tokens = investors [ _address ] . tokens . add ( _tokens ) ; investors [ _address ] . contribution = investors [ _address ] . contribution . add ( _value ) ; investors [ _address ] . distributed = BOOL_ ; }
"
"function buy ( address receiver ) public payable { require ( ! stopped ) ; require ( get current status ( ) == status . selling || get current status ( ) == status . prolonged selling ) ; require ( msg . value >= min investment ) ; var sender allowed = BOOL_ ; if ( allowed senders . length > NUM_ ) { for ( uint i = NUM_ ; i < allowed senders . length ; i ++ ) if ( allowed senders [ i ] == receiver ) { sender allowed = BOOL_ ; break ; } } else sender allowed = BOOL_ ; assert ( sender allowed ) ; uint wei amount = msg . value ; uint token amount = safe div ( safe mul ( wei amount , token value multiplier ) , token price ) ; assert ( token amount > NUM_ ) ; uint change wei = NUM_ ; var current contract tokens = token . balance of ( address ( this ) ) ; if ( current contract tokens < token amount ) { var change token amount = safe sub ( token amount , current contract tokens ) ;
"
"function transfer airdrop tokens ( address [ ] beneficiary , uint256 [ ] tokens ) only owner public { for ( uint256 i = NUM_ ; i < beneficiary . length ; i ++ ) { tokens [ i ] = safe math . mul ( tokens [ i ] , NUM_ ether ) ; require ( private sale supply >= tokens [ i ] ) ; private sale supply = safe math . sub ( private sale supply , tokens [ i ] ) ; token . mint ( beneficiary [ i ] , tokens [ i ] ) ; } }
"
"function add member acct ( address _member address ) public only owner { require ( _member address != address ( NUM_ ) ) ; member storage member address = members [ _member address ] ; members accts index [ _member address ] = members accts . length ; members accts . push ( _member address ) ; member address . member id = members accts . length ; member address . membership type = NUM_ ; emit new member ( _member address , member address . member id , member address . membership type ) ; }
"
"function initial arxtoken supply ( ) constant returns ( uint256 initial arxtoken supply count ) { initial arxtoken supply count = safe div ( initial arxsupply in wei , NUM_ ether ) ; }
"
"function finalize ( bytes _result , bytes _signature , bool _agree ) external returns ( bool ) { uint256 gasinit = gasleft ( ) ; require ( ! is finalized ) ; address result sender = keccak256 ( abi . encode packed ( this , _result ) ) . to eth signed message hash ( ) . recover ( _signature ) ; require ( result sender == promisor ) ; result = _result ; is finalized = BOOL_ ; if ( validator == NUM_ ) { require ( factory . is lighthouse ( msg . sender ) ) ; require ( token . transfer ( promisor , cost ) ) ; } else { require ( msg . sender == validator ) ; is confirmed = _agree ; if ( is confirmed ) require ( token . transfer ( promisor , cost ) ) ; else require ( token . transfer ( promisee , cost ) ) ; if ( validator fee > NUM_ ) require ( factory . xrt ( ) . transfer ( validator , validator fee ) ) ; } require ( factory . liability finalized ( gasinit ) ) ; return BOOL_ ; }
"
"function resolver ( uint256 din ) constant returns ( address ) { return records [ din ] . resolver ; }
"
"function withdraw ( address _from , address _to , uint _value , uint _fee , address _collector ) only owner public { require ( get state ( ) == state . success ) ; require ( applications [ _from ] != NUM_ ) ; address app = applications [ _from ] ; require ( _collector != NUM_ ) ; require ( _to != NUM_ ) ; require ( balance of [ app ] >= safe add ( _value , _fee ) ) ; require ( safe add ( balance of [ _to ] , _value ) > balance of [ _to ] ) ; require ( ! frozen account [ app ] ) ; require ( ! frozen account [ _to ] ) ; require ( _from != locked token holder ) ; balance of [ app ] = safe sub ( balance of [ app ] , safe add ( _value , _fee ) ) ; balance of [ _to ] = safe add ( balance of [ _to ] , _value ) ; balance of [ _collector ] = safe add ( balance of [ _collector ] , _fee ) ; emit fee ( app , _collector ,
"
"function diary ( address _sender , bytes _diary ) external not breakup one of owners ( _sender ) call by bank { diary [ next_diary_id ] = diary page ( { logtime : uint64 ( now ) , contant : _diary } ) ; next_diary_id ++ ; }
"
"function deposit ( ) public payable { balance of [ msg . sender ] = safe add ( balance of [ msg . sender ] , msg . value ) ; total supply = safe add ( total supply , msg . value ) ; issuance ( msg . value ) ; transfer ( this , msg . sender , msg . value ) ; }
"
"function _calculate new hero power ( uint _dungeon difficulty , uint _hero genes , uint _equipment index , uint _training times , uint _hero power , bool _is super , uint _floor genes ) private returns ( uint new hero genes , uint new hero power ) { new hero genes = _hero genes ; new hero power = _hero power ; bool new is super = _is super ; for ( uint i = NUM_ ; i < _training times ; i ++ ) { uint tmp hero genes = training formula contract . calculate result ( new hero genes , _floor genes , _equipment index ) ; uint tmp hero power ; bool tmp is super ; ( tmp hero power , , , tmp is super , , ) = get hero power ( tmp hero genes , _dungeon difficulty ) ; if ( tmp hero power > new hero power ) { if ( ! ( new is super && ! tmp is super ) ) { new hero genes = tmp hero genes ; new hero power = tmp hero power ; } } else if ( _equipment index > NUM_ && tmp hero power
"
"function calculate score ( address _participant ) view public returns ( int16 ) { int16 final score = NUM_ ; for ( int8 i = NUM_ ; i < latest game finished ; i ++ ) { uint j = uint ( i ) ; int16 game score = player point array [ _participant ] [ j ] ; final score = safe math . addint16 ( final score , game score ) ; } return final score ; }
"
"function change master ( address new master ) public valid address ( new master ) only owner ( ) { master = new master ; }
"
"function get rate ( erc20 token , uint current block number , bool buy , uint qty ) public view returns ( uint ) { if ( ! token data [ token ] . enabled ) return NUM_ ; if ( token control info [ token ] . minimal record resolution == NUM_ ) return NUM_ ; bytes32 compact data = token rates compact data [ token data [ token ] . compact data array index ] ; uint update rate block = get last4 bytes ( compact data ) ; if ( current block number >= update rate block + valid rate duration in blocks ) return NUM_ ; int total imbalance ; int block imbalance ; ( total imbalance , block imbalance ) = get imbalance ( token , update rate block , current block number ) ; int imbalance qty ; int extra bps ; int8 rate update ; uint rate ; if ( buy ) { rate = token data [ token ] . base buy rate ; rate update = get rate byte from compact data ( compact data , token , BOOL_ ) ; extra bps = int ( rate update ) * NUM_
"
"function get exists ( bytes20 blob id ) external constant returns ( bool exists ) { blob info info = blob info [ blob id ] ; exists = info . block number != NUM_ && info . block number != uint32 ( - NUM_ ) ; }
"
"function execute transaction ( ) public only active users allowed ( ) transaction must be pending ( ) { transaction storage transaction = transactions [ transactions . length - NUM_ ] ; require ( now > transaction . time_initiated + users [ transaction . initiated_by ] . delay ) ; transaction . is_executed = BOOL_ ; transaction . time_finalized = now ; transaction . finalized_by = msg . sender ; require ( transaction . destination . call . value ( transaction . value ) ( transaction . data ) ) ; }
"
"function mint ( address _to , uint256 _amount ) only access mint public returns ( bool ) { total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; mint ( _to , _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }
"
"function get bonus percent ( uint256 current time ) public constant returns ( uint256 percent ) { uint i = NUM_ ; bool is pre ico = current time >= pre ico start time && current time <= pre ico end time ; uint256 offset = NUM_ ; if ( is pre ico ) { uint256 pre ico diff in seconds = current time . sub ( pre ico start time ) ; for ( i = NUM_ ; i < pre ico bonuses . length ; i ++ ) { if ( pre ico diff in seconds <= pre ico bonuses [ i ] . duration + offset ) { return pre ico bonuses [ i ] . percent ; } offset = offset . add ( pre ico bonuses [ i ] . duration ) ; } } else { uint256 ico diff in seconds = current time . sub ( ico start time ) ; for ( i = NUM_ ; i < ico bonuses . length ; i ++ ) { if ( ico diff in seconds <= ico bonuses [ i ] . duration + offset ) { return ico bonuses [ i ] .
"
"function unlock funds ( ) public { require ( game state == state . closed ) ; require ( has participated [ msg . sender ] == BOOL_ ) ; require ( has withdrawn [ msg . sender ] == BOOL_ ) ; if ( funds transfered == BOOL_ ) { require ( credit gameinterface ( credit game address ) . check if lock can be removed ( address ( this ) ) == BOOL_ ) ; credit gameinterface ( credit game address ) . remove lock ( ) ; funds transfered = BOOL_ ; emit game unlocked ( block . number ) ; } has withdrawn [ msg . sender ] = BOOL_ ; uint index = participant indexes [ msg . sender ] ; uint amount = participation amount [ index ] ; ierc20 token ( token address ) . transfer ( msg . sender , amount ) ; total locked amount = ierc20 token ( token address ) . balance of ( address ( this ) ) ; if ( total locked amount == NUM_ ) { game state = state . claimed ; credit gameinterface ( credit game address ) . clean up ( ) ;
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( accounts [ msg . sender ] >= _value ) ; require ( burning account [ msg . sender ] ) ; accounts [ msg . sender ] = safe sub ( accounts [ msg . sender ] , _value ) ; token count = safe sub ( token count , _value ) ; emit burn ( msg . sender , _value ) ; return BOOL_ ; }
"
"function exit ( ) public { if ( current_state == swap state . open && msg . sender == token_a_party ) { token_a . transfer ( token_a_party , token_a_amount ) ; if ( premium > NUM_ ) { msg . sender . transfer ( premium ) ; } delete token_a_amount ; delete token_b_amount ; delete premium ; current_state = swap state . created ; } else if ( current_state == swap state . started && ( msg . sender == token_a_party || msg . sender == token_b_party ) ) { if ( msg . sender == token_a_party || msg . sender == token_b_party ) { token_b . transfer ( token_b_party , token_b . balance of ( address ( this ) ) ) ; token_a . transfer ( token_a_party , token_a . balance of ( address ( this ) ) ) ; current_state = swap state . ended ; if ( premium > NUM_ ) { creator . transfer ( premium ) ; } } } }
"
"function set battle contract address ( address _address ) external contract_only owner returns ( bool success ) { battle contract = battle interface ( _address ) ; battle contract address = _address ; return BOOL_ ; }
"
"function buy ( address _address , uint _value , uint _time ) internal returns ( bool ) { uint tokens to send = token calculate ( _value , _time ) ; if ( is pre ico ( _time ) ) { require ( pre ico tokens sold . add ( tokens to send ) <= pre_ico_max_cap ) ; pre ico tokens sold = pre ico tokens sold . add ( tokens to send ) ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } else { contributor eth collected [ _address ] += _value ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } eth collected = eth collected . add ( _value ) ; tokens sold = tokens sold . add ( tokens to send ) ; emit on success buy ( _address , _value , tokens to send ) ; return BOOL_ ; }
"
"function mint vested tokens ( address _to , uint256 _value , uint64 _start , uint64 _cliff , uint64 _vesting , bool _revokable , bool _burns on revoke , address _wallet ) only owner public returns ( bool ) { require ( _cliff >= _start && _vesting >= _cliff ) ; require ( token grants count ( _to ) < max_grants_per_address ) ; uint256 count = grants [ _to ] . push ( token grant ( _revokable ? _wallet : NUM_ , _value , _cliff , _vesting , _start , _revokable , _burns on revoke ) ) ; new vested token ( msg . sender , _to , _value , count - NUM_ ) ; return mint ( _to , _value ) ; }
"
"function buy copper ( uint256 _copper price , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _copper price , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; require ( msg . value >= _copper price ) ; assert ( ndc . transfer ( msg . sender , copper_amount_ndc ) && tpt . transfer ( msg . sender , copper_amount_tpt ) && skl . transfer ( msg . sender , copper_amount_skl ) && xper . transfer ( msg . sender , copper_amount_xper ) ) ; emit buy copper ( msg . sender , _copper price , msg . value ) ; }
"
"function transfer token ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; mintable token ( token ) . transfer ownership ( new owner ) ; }
"
"function check pool end ( uint i ) public { require ( i < pools . length ) ; smart pool pool = pools [ i ] ; if ( ! pool . is ended ( ) ) pool . check end ( ) ; if ( ! pool . is ended ( ) ) { return ; } update seed ( ) ; pools done . push ( pool ) ; pools [ i ] = new smart pool ( pool . get ticket price ( ) , pool . get ticket count ( ) , pool . get duration s ( ) ) ; }
"
"function return tokens ( ) public only owner { uint256 balance = token . balance of ( this ) ; require ( token . transfer ( owner , balance ) ) ; }
"
"function soft cap reached ( ) public view returns ( bool ) { return wei raised >= soft cap ; }
"
"function check crowdsale state ( ) internal returns ( bool ) { if ( eth raised == max cap && crowdsale state != state . crowdsale ended ) { crowdsale state = state . crowdsale ended ; max cap reached ( block . timestamp ) ; crowdsale ended ( block . timestamp ) ; return BOOL_ ; } if ( block . timestamp > presale start time && block . timestamp <= presale unlimited start time ) { if ( crowdsale state != state . priority pass ) { crowdsale state = state . priority pass ; presale started ( block . timestamp ) ; return BOOL_ ; } } else if ( block . timestamp > presale unlimited start time && block . timestamp <= crowdsale start time ) { if ( crowdsale state != state . opened priority pass ) { crowdsale state = state . opened priority pass ; presale unlimited started ( block . timestamp ) ; return BOOL_ ; } } else if ( block . timestamp > crowdsale start time && block . timestamp <= crowdsale ended time ) { if ( crowdsale state != state . crowdsale ) { crowdsale state = state
"
"function symbol ( ) public delegatable view returns ( string ) { return STR_ ; }
"
"function _update prices ( address [ ] of assets , uint [ ] new prices ) internal pre_cond ( of assets . length == new prices . length ) { update id ++ ; for ( uint i = NUM_ ; i < of assets . length ; ++ i ) { require ( registrar . asset is registered ( of assets [ i ] ) ) ; require ( assets to prices [ of assets [ i ] ] . timestamp != now ) ; assets to prices [ of assets [ i ] ] . timestamp = now ; assets to prices [ of assets [ i ] ] . price = new prices [ i ] ; } emit price updated ( keccak256 ( of assets , new prices ) ) ; }
"
"modifier only coo ( ) { check role ( msg . sender , role_coo ) ; _ ; }
"
"function check price ( uint256 _price ) public constant returns ( bool ) { require ( msg . sender == token ) ; return ( _price >= price ) ? BOOL_ : BOOL_ ; }
"
"function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool ) { require ( block . timestamp > frozen timestamp [ msg . sender ] ) ; require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; receiving contract receiver = receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }
"
"function burn from ( address _from , uint256 _value ) public returns ( bool ) { require ( _value > NUM_ ) ; var allowance = allowed [ _from ] [ msg . sender ] ; require ( allowance >= _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowance . sub ( _value ) ; burn ( _from , _value ) ; return BOOL_ ; }
"
"function terms and conditions are signed uint8 v bytes32 r bytes32 s view returns bool signed return ecrecover keccak256 \x19 ethereum signed message \n32 terms and conditions v r s msg sender
"
"function transfer ownership ( address _new owner ) public { require ( msg . sender == owner ) ; require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }
"
"function move ( uint8 game , bytes data , uint8 v , bytes32 r , bytes32 s ) public only authorized is alive { require ( game < casino games . length ) ; var player = ecrecover ( keccak256 ( data ) , v , r , s ) ; require ( withdraw after [ player ] == NUM_ || now < withdraw after [ player ] ) ; assert ( check address ( player , data ) ) ; assert ( casino games [ game ] . call ( data ) ) ; }
"
"function close sale ( ) public only owner returns ( bool ) { ended = BOOL_ ; uint256 issued token supply = token . total supply ( ) ; uint256 restricted tokens = issued token supply . mul ( NUM_ ) . div ( NUM_ ) ; log sale closed ( issued token supply , restricted tokens ) ; require ( token . mint ( vault , restricted tokens ) ) ; token . finish minting ( ) ; token . transfer ownership ( owner ) ; return BOOL_ ; }
"
"function update max gas price ( uint256 _max gas price ) public only owner { require ( _max gas price > NUM_ ) ; max gas price = _max gas price ; }
"
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { require ( _beneficiary != address ( NUM_ ) ) ; super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( state == sale state . private sale || state == sale state . pre sale || state == sale state . public sale tier1 || state == sale state . public sale tier2 || state == sale state . public sale tier3 || state == sale state . public sale tier4 ) ; }
"
"function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {
"
"function send shipment to ( address to , uint tokens ) public returns ( bool success ) { return transfer ( to , tokens ) ; }
"
"function total supply ( ) public view returns ( uint256 total ) { return total supply_ ; }
"
"function get section index from identifier ( uint _x_section_identifier , uint _y_section_identifier ) returns ( uint ) { if ( _x_section_identifier >= ( map width / NUM_ ) ) throw ; if ( _y_section_identifier >= ( map height / NUM_ ) ) throw ; uint index = _x_section_identifier + ( _y_section_identifier * NUM_ ) ; return index ; }
"
"function is necromancer ( uint _token id ) public view returns ( bool ) { for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( chibies [ _token id ] . dna [ i ] == NUM_ ) { return BOOL_ ; } } return BOOL_ ; }
"
"function approve moderatorship ( ) { require ( msg . sender == new moderator ) ; moderator = new moderator ; new moderator = address ( NUM_ ) ; }
"
"function set pre dgzto dgz rate ( uint rate ) public only owner { pre dgzto dgzexchange rate = rate ; tokens available for sale = total tokens available for sale - pre dgztokens sold * pre dgzto dgzexchange rate / NUM_ - private sales tokens sold ; }
"
"function transfer ( address _to , uint256 _value ) external { _transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value ) ; }
"
"function lift_ban ( ) public only owner { if ( ( now == contractstarttime + NUM_ years ) || ( now == contractstarttime + NUM_ years ) || ( now == contractstarttime + NUM_ years ) || ( now == contractstarttime + NUM_ years ) ) { balances [ owner ] += NUM_ * NUM_ * * NUM_ * ( NUM_ * * uint ( decimals ) ) ; } }
"
"function get balance ( address addr ) public view returns ( uint256 ) { return balances [ addr ] . value ; }
"
"function calculate new price ( uint256 _token id ) internal view returns ( uint256 price ) { uint256 selling price = villain index to price [ _token id ] ; uint256 new price ; if ( selling price < first step limit ) { new price = round it ( safe math . mul ( selling price , NUM_ ) ) ; } else if ( selling price < second step limit ) { new price = round it ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; } else { new price = round it ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; } return new price ; }
"
"function get timebased bonus rate ( ) internal constant returns ( uint256 ) { uint256 bonus rate = NUM_ ; if ( stage == stage . publicsale ) { uint256 now time = get now ( ) ; uint256 week1 = start time + ( NUM_ days ) ; uint256 week2 = start time + ( NUM_ days ) ; uint256 week3 = start time + ( NUM_ days ) ; uint256 week4 = start time + ( NUM_ days ) ; if ( now time <= week1 ) { bonus rate = NUM_ ; } else if ( now time <= week2 ) { bonus rate = NUM_ ; } else if ( now time <= week3 ) { bonus rate = NUM_ ; } else if ( now time <= week4 ) { bonus rate = NUM_ ; } } return bonus rate ; }
"
"function distribute bonuses ( ) public only oracle or owner only sale finished not destructed returns ( uint ) { erc20 interface _token = erc20 interface ( bonus token ) ; uint _balance = _token . balance of ( address ( this ) ) ; if ( _balance == NUM_ ) { return _emit error ( emission_provider_error_insufficient_bmc ) ; } profiterole _profiterole = profiterole ( profiterole ) ; if ( ! _token . approve ( address ( _profiterole ) , _balance ) ) { return _emit error ( emission_provider_error_internal ) ; } if ( ok != _profiterole . distribute bonuses ( _balance ) ) { revert ( ) ; } return ok ; }
"
"function cancel tree sell ( uint256 _tree id ) public { require ( msg . sender == tree details [ _tree id ] . owner ) ; require ( tree details [ _tree id ] . on sale ) ; for ( uint256 a = NUM_ ; a < trees on sale . length ; a ++ ) { if ( trees on sale [ a ] == _tree id ) { delete trees on sale [ a ] ; break ; } } tree details [ _tree id ] . on sale = BOOL_ ; }
"
"function convert to mini etyc ( uint amount ) internal constant returns ( uint ) { return amount * ( NUM_ * * uint ( token reward . decimals ( ) ) ) ; }
"
"function is registered ( address _addr , bool _is presale ) public view returns ( bool ) { return registered address [ _addr ] [ _is presale ] ; }
"
"function start pre ico ( uint256 x ) public only owner { require ( state == state . prepreico ) ; pre ico start at = block . timestamp ; pre ico end at = block . timestamp + x * NUM_ days ; state = state . preico ; }
"
"function normalize pledge ( uint64 id pledge ) returns ( uint64 ) { pledge storage p = find pledge ( id pledge ) ; if ( p . pledge state != pledge state . pledged ) { return id pledge ; } if ( ( p . intended project > NUM_ ) && ( get time ( ) > p . commit time ) ) { uint64 old pledge = find or create pledge ( p . owner , p . delegation chain , NUM_ , NUM_ , p . old pledge , pledge state . pledged ) ; uint64 to pledge = find or create pledge ( p . intended project , new uint64 [ ] ( NUM_ ) , NUM_ , NUM_ , old pledge , pledge state . pledged ) ; do transfer ( id pledge , to pledge , p . amount ) ; id pledge = to pledge ; p = find pledge ( id pledge ) ; } to pledge = get oldest pledge not canceled ( id pledge ) ; if ( to pledge != id pledge ) { do transfer ( id pledge , to pledge , p . amount ) ;
"
"function disable investment ( address [ ] of assets ) external pre_cond ( is owner ( ) ) { for ( uint i = NUM_ ; i < of assets . length ; ++ i ) { is invest allowed [ of assets [ i ] ] = BOOL_ ; } }
"
"function create with nonce ( bytes32 flags nonce , bytes contents ) external returns ( bytes20 blob id ) { blob id = bytes20 ( keccak256 ( msg . sender , flags nonce ) ) ; if ( blob info [ blob id ] . block number != NUM_ ) { throw ; } blob info [ blob id ] = blob info ( { flags : bytes4 ( flags nonce ) , revision count : NUM_ , block number : uint32 ( block . number ) , owner : ( bytes4 ( flags nonce ) & anonymous != NUM_ ) ? NUM_ : msg . sender , } ) ; store ( blob id , NUM_ , contents ) ; }
"
"modifier only owner ( ) { require ( msg . sender == owner account ) ; _ ; }
"
"function distribute tokens ( address _to , uint256 _value ) public { require ( distribution address == msg . sender || owner == msg . sender ) ; super . transfer ( _to , _value ) ; }
"
"function round investor info by index ( uint32 _group , uint32 _round , uint32 _index ) public constant returns ( address investor , uint256 sum , uint256 time ) { require ( group exists ( _group ) ) ; require ( groups [ _group ] . rounds [ _round ] . total investors > _index ) ; investment storage investment = groups [ _group ] . rounds [ _round ] . investments [ _index ] ; investor = investment . investor ; sum = investment . sum ; time = investment . time ; }
"
"function request transfer child ( ownable _child , address _new owner ) public only admin or owner { uint defer block = compute defer block ( ) ; transfer child operation memory op = transfer child operation ( _child , _new owner , admin , defer block ) ; transfer child operation event ( _child , _new owner , defer block , transfer child operations . length ) ; transfer child operations . push ( op ) ; }
"
"function post proof ( string proof hash ) public { week committment storage committment = commitments [ msg . sender ] [ current week ( ) ] ; if ( committment . days completed > current day of week ( ) ) { emit log ( STR_ ) ; require ( BOOL_ ) ; } if ( committment . tokens committed == NUM_ ) { emit log ( STR_ ) ; require ( BOOL_ ) ; } if ( committment . workout proofs [ current day of week ( ) ] != NUM_ ) { emit log ( STR_ ) ; require ( BOOL_ ) ; } if ( committment . days completed >= committment . days committed ) { return ; } committment . workout proofs [ current day of week ( ) ] = store image string ( proof hash ) ; committment . days completed ++ ; initialize week data ( current week ( ) ) ; week data storage week = data per week [ current week ( ) ] ; week . total days completed ++ ; week . total tokens completed = week . total tokens * week . total days completed / week
"
"function vest tokens ( ) public returns ( bool ) { require ( pending installments > NUM_ ) ; require ( paid installments < NUM_ ) ; require ( pending vesting pool > NUM_ ) ; require ( now - start time > cliff ) ; if ( ! reward generation complete ) { for ( uint256 i = NUM_ ; i <= NUM_ ; i ++ ) { add reward ( distribution addresses [ i ] ) ; } } uint256 curr interval = interval at time ( now ) ; uint256 tokens to vest = NUM_ ; uint256 total tokens to vest = NUM_ ; uint256 total pool = total vesting pool ; uint256 [ NUM_ ] memory founder cat ; founder cat [ NUM_ ] = NUM_ ; founder cat [ NUM_ ] = NUM_ ; uint256 [ NUM_ ] memory orig founder bal ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] .
"
"function make offer ( uint256 _token id , uint8 _v , bytes32 _r , bytes32 _s ) public not halted ( ) payable { address recovered signer = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recovered signer ] == BOOL_ ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value > NUM_ ) ; uint256 current price = get token price ( _token id ) ; require ( current price > NUM_ ) ; if ( _token id == logo id && token . get current price for token ( _token id ) == NUM_ ) { require ( msg . value >= logo price ) ; token . update tokens state ( logo id , msg . value ) ; erc20token . mint ( msg . sender , NUM_ ) ; transfer ethers ( platform wallet , msg . value ) ; emit purchased ( NUM_ , msg . sender , _token id , msg . value , NUM_ , NUM_ , msg . value , now ) ; return ; } uint256 min price = pricing
"
"function process off chain purchase ( address _recipient , uint256 _value ) public only owner { require ( lmda . balance of ( address ( this ) ) >= _value ) ; require ( _value > NUM_ && _recipient != NUM_ ) ; lmda . transfer ( _recipient , _value ) ; tokens sold = tokens sold . add ( _value ) ; off chain purchase made ( _recipient , _value ) ; }
"
"function transfer from ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferred from ) { require ( ! token transfers frozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= NUM_ ) ; require ( transfer check ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; transfer ( _owner , _receiver , _amount ) ; return BOOL_ ; }
"
"function recycling ( address _from , uint256 _value ) only owner public returns ( bool ) { balances [ _from ] = balances [ _from ] . sub ( _value ) ; total supply_ = total supply_ . sub ( _value ) ; recycling ( _from , _value ) ; return BOOL_ ; }
"
"function calculate revenue ( uint256 _block number , uint256 winner , uint256 loser ) internal { uint256 revenue = odd and even bets [ _block number ] [ loser ] ; if ( odd and even bets [ _block number ] [ odd ] != NUM_ && odd and even bets [ _block number ] [ even ] != NUM_ ) { uint256 comission = ( revenue . div ( NUM_ ) ) . mul ( commission_percentage ) ; revenue = revenue . sub ( comission ) ; comissions at block [ _block number ] = comission ; imoney manager ( money manager ) . pay to ( owner wallet , comission ) ; uint256 winners = odd and even bets [ _block number ] [ winner ] . div ( bet ) ; block revenue per ticket [ _block number ] = revenue . div ( winners ) ; } is block revenue calculated [ _block number ] = BOOL_ ; emit log revenue ( _block number , winner , revenue ) ; }
"
"function calculate interest due ( ) public constant returns ( uint256 _coins , uint256 _cycle ) { if ( ! is term over ( ) || ! is loan funded ( ) ) return ( NUM_ , NUM_ ) ; else { uint time diff = now . sub ( last interest cycle ) ; _cycle = time diff . div ( day length . mul ( interest cycle length ) ) ; _coins = _cycle . mul ( interest rate per cycle . mul ( initial supply ) ) . div ( percent_divisor ) ; } }
"
"function is valid signature address signer bytes32 hash uint8 v bytes32 r bytes32 s public pure returns bool return signer ecrecover keccak256 \x19 ethereum signed message \n32 hash v r s
"
"function create series ( bytes32 nodehash , string series name , bytes32 root hash , uint256 initial count ) returns ( bool success ) { if ( msg . sender != _ens . owner ( nodehash ) ) { return BOOL_ ; } if ( root hash == NUM_ ) { return BOOL_ ; } series storage series = _series [ nodehash ] ; if ( series . root hash != NUM_ ) { return BOOL_ ; } series . name = series name ; series . root hash = root hash ; series . initial count = initial count ; series . current count = initial count ; series created ( nodehash ) ; }
"
"function process sale ( ) internal { if ( ! price is frozen ) { set stake price uscents ( ) ; } set caps ( ) ; uint team stakes ; uint sale stakes ; uint wei invested ; uint try sale stakes = stake for wei ( msg . value ) ; if ( try sale stakes > NUM_ ) { uint try distribute = distributed sale stakes + try sale stakes ; if ( try distribute <= sale cap ) { sale stakes = try sale stakes ; wei invested = msg . value ; } else { sale stakes = sale cap - distributed sale stakes ; wei invested = wei for stake ( sale stakes ) ; } team stakes = ( sale stakes * team share ) . div ( sale share ) ; if ( sale stakes > NUM_ ) { balances [ owner ] += team stakes ; total supply += team stakes ; distributed team stakes += team stakes ; sale supply ( msg . sender , sale stakes , wei invested ) ; if ( sale stat [ msg . sender ] . guide != address ( NUM_ ) )
"
"function reset reclaim ( ) public only reclaimable owner { reclaimable owner = address ( NUM_ ) ; }
"
"function migrate vault ( address _legacy vault address ) only owner external { require ( _legacy vault address != address ( NUM_ ) ) ; require ( ! migrated [ _legacy vault address ] ) ; require ( token timelock == address ( NUM_ ) ) ; migrated [ _legacy vault address ] = BOOL_ ; uint256 timelock amount = legacy syc contract . balance of ( _legacy vault address ) ; token timelock = new token timelock ( syc contract , msg . sender , timelock release time ) ; syc contract . transfer ( token timelock , timelock amount ) ; migrated supply = migrated supply . add ( timelock amount ) ; emit migrate ( _legacy vault address , timelock amount ) ; }
"
"function transfer locked token ( address _to , uint256 _value , uint256 _release time ) public when not paused non reentrant returns ( bool ) { require ( _release time > now ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; locked balances [ locked balance count ] = locked balance ( { owner : _to , value : _value , release time : _release time } ) ; locked balance count ++ ; emit transfer locked token ( msg . sender , _to , _value , _release time ) ; return BOOL_ ; }
"
"function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,
"
"function pause ( ) external only owner { require ( paused == BOOL_ ) ; paused = BOOL_ ; }
"
"modifier only admin ( ) { require ( admins [ msg . sender ] || owner == msg . sender ) ; _ ; }
"
"function license issued time ( uint256 _license id ) public view returns ( uint256 ) { return licenses [ _license id ] . issued time ; }
"
"modifier only presale whitelisted ( ) { require ( is whitelisted presale ( msg . sender ) , STR_ ) ; _ ; }
"
"function dissolve fund ( ) public { require ( balances [ msg . sender ] == NUM_ ) ; require ( fund managers [ msg . sender ] ) ; delete fund managers [ msg . sender ] ; emit dissolve fund ( msg . sender ) ; }
"
"function start crowdsale ( ) public only owner { require ( presale concluded && ! crowdsale started ) ; crowdsale started = BOOL_ ; phase1 start block = block . number ; phase1 end block = phase1 start block . add ( day to block number ( NUM_ ) ) ; phase2 end block = phase1 end block . add ( day to block number ( NUM_ ) ) ; phase3 end block = phase2 end block . add ( day to block number ( NUM_ ) ) ; phase4 end block = phase3 end block . add ( day to block number ( NUM_ ) ) ; phase5 end block = phase4 end block . add ( day to block number ( NUM_ ) ) ; end block = phase5 end block ; start crowdsale ( ) ; }
"
"function transfer any erc20 token ( address _token address , uint256 _tokens ) only owner public returns ( bool success ) { require ( ! stopped ) ; return erc20 interface ( _token address ) . transfer ( owner , _tokens ) ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { check transfer allowed ( msg . sender , _to ) ; return super . transfer ( _to , _value ) ; }
"
"function balance of ( address _owner ) public view returns ( uint256 count ) { return ownership token count [ _owner ] ; }
"
"function set exchange ( address exchange_ ) public only operator { require ( exchange_ != address ( NUM_ ) ) ; if ( exchange_ == exchange && candidate exchange != address ( NUM_ ) ) { emit e cancel nominating exchange ( candidate exchange ) ; candidate exchange = address ( NUM_ ) ; candidate till exchange = NUM_ ; } else if ( exchange == address ( NUM_ ) ) { emit e change exchange ( address ( NUM_ ) , exchange_ ) ; exchange = exchange_ ; exchange old version = exchange_ ; } else if ( exchange_ != candidate exchange && candidate till exchange + NUM_ * NUM_ < block . timestamp ) { emit e nominating exchange ( exchange_ ) ; candidate exchange = exchange_ ; candidate till exchange = block . timestamp + NUM_ * NUM_ ; } else if ( exchange_ == candidate exchange && candidate till exchange < block . timestamp ) { emit e change exchange ( exchange , candidate exchange ) ; exchange old version = exchange ; exchange = candidate exchange ; candidate exchange = address ( NUM_ ) ; } }
"
"function start tournament ( ) only owner non reentrant external { require ( participants . length == max participant count ) ; _first round fight ( ) ; _second round winners fight ( ) ; _second round losers fight ( ) ; _final round winners fight ( ) ; _final round losers fight ( ) ; uint winner rewards = tournament rewards * win percent / NUM_ ; uint loser rewards = tournament rewards * lose percent / NUM_ ; uint add to jackpot = tournament rewards - winner rewards - loser rewards ; address winner = participants [ final winner ] . player ; address loser = participants [ final loser ] . player ; winner . transfer ( winner rewards ) ; loser . transfer ( loser rewards ) ; tournament jackpot += add to jackpot ; player to win counts [ winner ] ++ ; for ( uint i = NUM_ ; i < participants . length ; i ++ ) { address participant = participants [ i ] . player ; if ( participant != winner && player to win counts [ participant ] != NUM_ ) { player to win counts [ participant ] =
"
"function is ended ( ) public view returns ( bool ) { return stage == stages . ended ; }
"
"function unset section for sale ( uint _section_index ) { if ( _section_index >= sections . length ) throw ; section section = sections [ _section_index ] ; if ( section . owner != msg . sender ) throw ; section . for_sale = BOOL_ ; section . price = NUM_ ; section . sell_only_to = NUM_ ; delisted ( _section_index ) ; }
"
"function set upgrade agent ( address agent ) external { if ( ! can upgrade ( ) ) { revert ( ) ; } if ( agent == NUM_ ) revert ( ) ; if ( msg . sender != upgrade controller ) revert ( ) ; if ( get upgrade state ( ) == upgrade state . upgrading ) revert ( ) ; upgrade agent = upgrade agent ( agent ) ; if ( ! upgrade agent . is upgrade agent ( ) ) revert ( ) ; if ( upgrade agent . original supply ( ) != total supply ) revert ( ) ; upgrade agent set ( upgrade agent ) ; }
"
"function approve ( address spender , uint tokens ) public returns ( bool success ) { if ( balances [ msg . sender ] >= tokens ) { allowed [ msg . sender ] [ spender ] = tokens ; emit approval ( msg . sender , spender , tokens ) ; return BOOL_ ; } return BOOL_ ; }
"
"function is crowdsale open ( ) public view returns ( bool ) { return now >= opening time && now <= closing time ; }
"
"function get locks locked for ( address _owner , uint256 count ) valid contract only returns ( uint256 locked for ) { locked for = locked addresses [ _owner ] [ count ] . locked for ; }
"
"function gift tokens ( address _beneficiary , uint256 _gift amount ) external only owner sale allocatable { require ( _beneficiary != NUM_ ) ; require ( _gift amount != NUM_ ) ; require ( blacklist [ _beneficiary ] == BOOL_ ) ; require ( bookkeep ( _beneficiary , NUM_ , _gift amount ) ) ; token purchase ( msg . sender , _beneficiary , NUM_ , _gift amount ) ; token . mint ( _beneficiary , _gift amount ) ; }
"
"function total cap ( ) public constant returns ( uint256 ) { uint256 presale cap = super . total cap ( ) ; return presale cap . add ( cap ) ; }
"
"function add owner ( address _owner ) external owner does not exist ( _owner ) valid num owners ( m_num owners + NUM_ ) onlymanyowners ( keccak256 ( msg . data ) ) { assert owners are consistent ( ) ; clear pending ( ) ; m_num owners ++ ; m_owners [ m_num owners ] = _owner ; m_owner index [ _owner ] = check owner index ( m_num owners ) ; assert owners are consistent ( ) ; owner added ( _owner ) ; }
"
"function _owns ( address claimant , uint256 _token id ) private view returns ( bool ) { return claimant == avatar index to owner [ _token id ] ; }
"
"function withdraw ( ) only owner after draw { if ( paid out ( ) && owner fee == NUM_ ) { if ( ! owner . send ( this . balance ) ) { throw ; } } }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"modifier only owner ( ) { require ( msg . sender == get owner ( ) ) ; _ ; }
"
"function close early ( uint256 _closing time ) external only owner only while open { require ( _closing time <= closing time ) ; if ( _closing time < block . timestamp ) { closing time = block . timestamp ; } else { closing time = _closing time ; } }
"
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal view { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( _wei amount <= individual cap ) ; require ( _wei amount >= minium investment ) ; }
"
"function transfer from ( address from , address to , uint256 value ) public returns ( bool success ) { require ( value <= allowances [ from ] [ msg . sender ] ) ; allowances [ from ] [ msg . sender ] -= value ; require ( to != NUM_ ) ; require ( balance of [ from ] >= value ) ; require ( balance of [ to ] + value >= balance of [ to ] ) ; uint previous balances = balance of [ from ] + balance of [ to ] ; balance of [ from ] -= value ; balance of [ to ] += value ; emit transfer ( from , to , value ) ; assert ( balance of [ from ] + balance of [ to ] == previous balances ) ; return BOOL_ ; }
"
"function get users awaiting for tokens top150 ( bool fetch ) public constant returns ( address [ NUM_ ] ) { address [ NUM_ ] memory awaiting ; uint k = NUM_ ; for ( uint i = NUM_ ; i < all users . length ; i ++ ) { if ( users buying information [ all users [ i ] ] . is kycapproved == BOOL_ && users buying information [ all users [ i ] ] . tokens to be sent > NUM_ ) { awaiting [ k ] = all users [ i ] ; k = k . add ( NUM_ ) ; if ( k == NUM_ ) return awaiting ; } } return awaiting ; }
"
"function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { return owned tokens [ _owner ] ; }
"
"function re roll move ( uint256 _kitty id , uint256 _move slot , uint256 _type id ) external is not contract { require ( msg . sender == core . owner of ( _kitty id ) ) ; uint256 old action = kitty data . fetch slot ( _kitty id , _move slot ) ; require ( old action > NUM_ ) ; require ( old action - ( _type id * NUM_ ) < NUM_ ) ; assert ( token . burn ( msg . sender , reroll fee ) ) ; uint256 upper = cuddle data . get action count ( _type id ) ; uint256 action id = unduplicate ( _kitty id , old action , upper , _type id ) ; assert ( ! kitty actions [ _kitty id ] [ action id ] ) ; kitty actions [ _kitty id ] [ old action ] = BOOL_ ; kitty actions [ _kitty id ] [ action id ] = BOOL_ ; assert ( kitty data . add action ( _kitty id , action id , _move slot ) ) ; move rerolled ( _kitty id , old action , action id ) ; }
"
"function unsold tokens ( ) public view returns ( uint256 ) { return token cap . sub ( tokens sold ) ; }
"
"function grant marketing coins ( address _participant , uint _coins ) public only owner { require ( _coins <= coin_supply_mkt_total . sub ( coins issued mkt ) ) ; balances [ _participant ] = balances [ _participant ] . add ( _coins ) ; coins issued mkt = coins issued mkt . add ( _coins ) ; coins issued total = coins issued total . add ( _coins ) ; transfer ( NUM_ , _participant , _coins ) ; marketing coins granted ( _participant , _coins , balances [ _participant ] ) ; }
"
"function get rate ico with bonus by date ( uint256 _date ) public view returns ( uint256 ) { uint256 bonus ; uint256 rate ico ; if ( _date >= start ico pre ico && _date < end ico pre ico ) { rate ico = rate ico pre ico ; } if ( _date >= start ico main sale && _date < end ico main sale ) { rate ico = rate ico main sale ; } if ( _date >= start ico pre ico && _date < start ico pre ico2nd round ) { bonus = NUM_ ; } else if ( _date >= start ico pre ico2nd round && _date < end ico pre ico ) { bonus = NUM_ ; } else if ( _date >= start ico main sale ) { uint256 days since main ico started = ( _date - start ico main sale ) / NUM_ ; bonus = NUM_ - ( NUM_ * days since main ico started ) ; if ( bonus < NUM_ ) { bonus = NUM_ ; } } return rate ico + rate ico . mul ( bonus ) . div ( NUM_ ) ; }
"
"function super_transfer ( address _to , uint _value ) internal returns ( bool success ) { require ( ! is sending locked [ msg . sender ] ) ; require ( _value <= one transfer limit ) ; require ( balances [ msg . sender ] >= _value ) ; if ( msg . sender == contr initiator ) { } else { require ( ! is all transfers locked ) ; require ( safe add ( get last24h sending value ( msg . sender ) , _value ) <= one day transfer limit ) ; } balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; uint tc = transfer info [ msg . sender ] . tc ; transfer info [ msg . sender ] . ti [ tc ] . value = _value ; transfer info [ msg . sender ] . ti [ tc ] . time = now ; transfer info [ msg . sender ] . tc = safe add ( transfer info [ msg . sender ]
"
"function verify multi sig ( address to address , bytes32 operation hash , bytes signature , uint expire time , uint sequence id ) private returns ( address ) { var other signer = recover address from signature ( operation hash , signature ) ; if ( safe mode && ! is signer ( to address ) ) { throw ; } if ( expire time < block . timestamp ) { throw ; } try insert sequence id ( sequence id ) ; if ( ! is signer ( other signer ) ) { throw ; } if ( other signer == msg . sender ) { throw ; } return other signer ; }
"
"function batch transfer ( address [ ] _recipients , uint [ ] _values ) public only owner returns ( bool ) { require ( _recipients . length > NUM_ && _recipients . length == _values . length ) ; uint total = NUM_ ; for ( uint i = NUM_ ; i < _values . length ; i ++ ) { total = total . add ( _values [ i ] ) ; } require ( total <= balances [ msg . sender ] ) ; uint64 _now = uint64 ( block . timestamp ) ; for ( uint j = NUM_ ; j < _recipients . length ; j ++ ) { balances [ _recipients [ j ] ] = balances [ _recipients [ j ] ] . add ( _values [ j ] ) ; transfer ins [ _recipients [ j ] ] . push ( transfer in struct ( uint256 ( _values [ j ] ) , _now ) ) ; emit transfer ( msg . sender , _recipients [ j ] , _values [ j ] ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( total
"
"function add policy rule ( bytes4 _sig , address _contract , bytes32 _group name , uint _accept limit , uint _decline limit ) only contract owner external returns ( uint ) { require ( _sig != NUM_ ) ; require ( _contract != NUM_ ) ; require ( groups access manager ( access manager ) . is group exists ( _group name ) ) ; require ( _accept limit != NUM_ ) ; require ( _decline limit != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; if ( policy id2 index [ _policy hash ] == NUM_ ) { uint _policies count = policies count . add ( NUM_ ) ; index2 policy id [ _policies count ] = _policy hash ; policy id2 index [ _policy hash ] = _policies count ; policies count = _policies count ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; if ( _policy . group name2index [ _group name ] == NUM_ ) { _policy groups count += NUM_ ; _policy . group name2index [ _group name ] = _policy groups count ;
"
"function sell ( ierc20 token _reserve token , uint256 _sell amount , uint256 _min return ) public conversions allowed valid gas price greater than zero ( _min return ) returns ( uint256 ) { require ( _sell amount <= token . balance of ( msg . sender ) ) ; uint256 amount = get sale return ( _reserve token , _sell amount ) ; assert ( amount != NUM_ && amount >= _min return ) ; uint256 token supply = token . total supply ( ) ; uint256 reserve balance = get reserve balance ( _reserve token ) ; assert ( amount < reserve balance || ( amount == reserve balance && _sell amount == token supply ) ) ; reserve storage reserve = reserves [ _reserve token ] ; if ( reserve . is virtual balance enabled ) reserve . virtual balance = safe sub ( reserve . virtual balance , amount ) ; token . destroy ( msg . sender , _sell amount ) ; assert ( _reserve token . transfer ( msg . sender , amount ) ) ; uint256 reserve amount = safe mul ( get reserve balance ( _reserve token ) , max_crr ) ;
"
"function init presale token vault ( address [ ] beneficiaries , uint256 [ ] balances ) public only owner { require ( beneficiaries . length == balances . length ) ; presale token vault . init ( beneficiaries , balances , presale_vault_start , token ) ; uint256 total presale balance = NUM_ ; uint256 balances length = balances . length ; for ( uint256 i = NUM_ ; i < balances length ; i ++ ) { total presale balance = total presale balance . add ( balances [ i ] ) ; } mint tokens ( presale token vault , total presale balance ) ; }
"
"function transfer ( address , uint256 ) public returns ( bool ) { revert ( ) ; }
"
"function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j
"
"function remove operator ( address _operator ) public only owner { require ( operators . length > NUM_ , STR_ ) ; require ( is operator [ _operator ] , STR_ ) ; address last operator = operators [ operators . length - NUM_ ] ; for ( uint i = NUM_ ; i < operators . length ; i ++ ) { if ( operators [ i ] == _operator ) { operators [ i ] = last operator ; } } operators . length -= NUM_ ; is operator [ _operator ] = BOOL_ ; emit operator removed ( _operator ) ; }
"
"function register ( string key ) external { assert ( bytes ( key ) . length <= NUM_ ) ; keys [ msg . sender ] = key ; log register ( msg . sender , key ) ; }
"
"function remove deed ( address _from , uint256 _deed id ) private { require ( deed owner [ _deed id ] == _from ) ; uint256 deed index = owned deeds index [ _deed id ] ; uint256 last deed index = owned deeds [ _from ] . length . sub ( NUM_ ) ; uint256 last deed = owned deeds [ _from ] [ last deed index ] ; deed owner [ _deed id ] = NUM_ ; owned deeds [ _from ] [ deed index ] = last deed ; owned deeds [ _from ] [ last deed index ] = NUM_ ; owned deeds [ _from ] . length -- ; owned deeds index [ _deed id ] = NUM_ ; owned deeds index [ last deed ] = deed index ; total deeds = total deeds . sub ( NUM_ ) ; }
"
"function setup race ( uint delay , uint locking_duration ) only owner before betting public payable returns ( bool ) { if ( oraclize_get price ( STR_ , horses . custom pre gas limit ) * NUM_ + oraclize_get price ( STR_ , horses . custom post gas limit ) * NUM_ > address ( this ) . balance ) { emit new oraclize query ( STR_ ) ; return BOOL_ ; } else { chronus . starting_time = uint32 ( block . timestamp ) ; chronus . betting_open = BOOL_ ; bytes32 temp_id ; emit new oraclize query ( STR_ ) ; chronus . betting_duration = uint32 ( delay ) ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . ltc ; coin index [ horses . ltc ] . pre oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . eth ; coin index [ horses . eth ] . post oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url
"
"function calculate interest due ( ) public constant returns ( uint256 _coins , uint256 _cycle ) { if ( ! is term over ( ) || ! is loan funded ( ) ) return ( NUM_ , NUM_ ) ; else { uint time diff = now . sub ( last interest cycle ) ; _cycle = time diff . div ( day length . mul ( interest cycle length ) ) ; _coins = _cycle . mul ( interest rate per cycle . mul ( initial supply ) ) . div ( percent_divisor ) ; } }
"
"function set winning numbers ( uint _week , string _result ) internal { string [ ] memory arr = string to array ( _result ) ; for ( uint i = NUM_ ; i < arr . length ; i ++ ) { raffle [ _week ] . win nums . push ( parse int ( arr [ i ] ) ) ; } uint serial no = parse int ( arr [ NUM_ ] ) ; emit log winning numbers ( _week , raffle [ _week ] . num entries , raffle [ _week ] . win nums , prize pool , serial no , now ) ; }
"
"function pause ( ) public only owner when not paused { paused = BOOL_ ; paused timestamp = block . timestamp ; pause ( ) ; }
"
"function set value ( values [ ] storage values , uint256 value ) internal { uint256 current snapshot id = m current snapshot id ( ) ; bool empty = values . length == NUM_ ; if ( empty ) { values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; return ; } uint256 last = values . length - NUM_ ; bool has new snapshot = values [ last ] . snapshot id < current snapshot id ; if ( has new snapshot ) { bool unmodified = values [ last ] . value == value ; if ( unmodified ) { return ; } values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; } else { bool previous unmodified = last > NUM_ && values [ last - NUM_ ] . value == value ; if ( previous unmodified ) { delete values [ last ] ; values . length -- ; return ; } values [ last ] . value = value ; } }
"
"function add event ( address _event ) external only event manager { require ( ! is active event [ _event ] ) ; is active event [ _event ] = BOOL_ ; event added ( _event ) ; }
"
"function change total supply ( uint256 new supply ) public only owner returns ( bool success ) { require ( new supply >= NUM_ && ( new supply >= _total supply || _total supply - new supply <= balances [ owner ] ) ) ; uint256 diff = NUM_ ; if ( new supply >= _total supply ) { diff = new supply . sub ( _total supply ) ; balances [ owner ] = balances [ owner ] . add ( diff ) ; emit transfer ( address ( NUM_ ) , owner , diff ) ; } else { diff = _total supply . sub ( new supply ) ; balances [ owner ] = balances [ owner ] . sub ( diff ) ; emit transfer ( owner , address ( NUM_ ) , diff ) ; } _total supply = new supply ; return BOOL_ ; }
"
"function unauthorise address ( address _addr ) public only owner { require ( is authorised [ _addr ] && _addr != owner ) ; is authorised [ _addr ] = BOOL_ ; address unauthorised ( _addr ) ; }
"
"function contribute with address ( address contributor ) public payable when not paused { require ( msg . value >= min contrib amount ) ; require ( is contrib period running ( ) ) ; uint contrib value = msg . value ; uint excess contrib value = NUM_ ; uint old total contributed = total contributed ; total contributed = old total contributed . add ( contrib value ) ; uint new total contributed = total contributed ; if ( new total contributed >= total lending amount && old total contributed < total lending amount ) { cap reached = BOOL_ ; funding end time = now ; on cap reached ( funding end time ) ; excess contrib value = new total contributed . sub ( total lending amount ) ; contrib value = contrib value . sub ( excess contrib value ) ; total contributed = total lending amount ; } if ( investors [ contributor ] . amount == NUM_ ) { investors keys . push ( contributor ) ; } investors [ contributor ] . amount = investors [ contributor ] . amount . add ( contrib value ) ; if ( excess contrib value
"
"function set signer address ( address _signer address ) only owner { signer address = _signer address ; signer changed ( signer address ) ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"function create gen0 auction ( uint256 _genes ) external only coo { require ( gen0 created count < gen0_creation_limit ) ; uint256 pony id = _create pony ( NUM_ , NUM_ , NUM_ , _genes , address ( this ) ) ; _approve ( pony id , sale auction ) ; sale auction . create auction ( pony id , _compute next gen0 price ( ) , NUM_ , gen0_auction_duration , address ( this ) ) ; gen0 created count ++ ; }
"
"function re load core ( uint256 _p id , uint256 _aff id , uint256 _eth , pohmodatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , NUM_ , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed
"
"function send ether ( address beneficiary , uint256 wei amount ) only owner public { beneficiary . transfer ( wei amount ) ; }
"
"function set oraclize addr resolver i ( address __oar ) public only owner { require ( __oar != NUM_ ) ; oar = oraclize addr resolver i ( __oar ) ; log oraclize addr resolver i ( __oar ) ; }
"
"function extra mint ( ) only owner can mint public returns ( bool ) { require ( free to extra minting > NUM_ ) ; uint256 one percent = free to extra minting / distribution_investors ; uint256 team part = one percent * distribution_team ; uint256 community part = one percent * distribution_community ; uint256 extra tokens = team part . add ( community part ) ; total supply_ = total supply_ . add ( extra tokens ) ; extra supply = extra supply . add ( extra tokens ) ; uint256 left to next minting = free to extra minting % distribution_investors ; free to extra minting = left to next minting ; assert ( total supply_ <= hardcapped_supply ) ; assert ( extra supply <= hardcapped_supply . sub ( maxsold_supply ) ) ; balances [ team tokens holder ] = balances [ team tokens holder ] . add ( team part ) ; balances [ community tokens holder ] = balances [ community tokens holder ] . add ( community part ) ; mint ( team tokens holder , team part ) ; transfer ( address ( this ) , team tokens holder , team part ) ;
"
"function mint ( ) can po smint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) return BOOL_ ; if ( transfer ins [ msg . sender ] . length <= NUM_ ) return BOOL_ ; uint reward = get proof of stake reward ( msg . sender ) ; if ( reward <= NUM_ ) return BOOL_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; delete transfer ins [ msg . sender ] ; transfer ins [ msg . sender ] . push ( transfer in struct ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; mint ( msg . sender , reward ) ; return BOOL_ ; }
"
"function remove proof ( address _source , bytes32 _attribute ) public only by ( owner ) returns ( bool ) { bool existed = check proof ( _attribute ) ; if ( existed == BOOL_ ) { event notification ( msg . sender , error_event , STR_ ) ; return BOOL_ ; } if ( proof list [ _attribute ] != _source ) { event notification ( msg . sender , error_event , STR_ ) ; return BOOL_ ; } delete proof list [ _attribute ] ; event notification ( msg . sender , info_event , STR_ ) ; return BOOL_ ; }
"
"function add deal ( address _buyer , address _seller , address _signer , uint _sum , uint _fee , uint _object type , uint _deal number , string _comment , uint who pay , uint _count days , bool _is prolong ) only agency public { if ( who pay == NUM_ ) { _sum = _sum . add ( _fee ) ; } uint new index = deals . length ++ ; signs . length ++ ; deals [ new index ] . buyer = _buyer ; deals [ new index ] . seller = _seller ; deals [ new index ] . signer = _signer ; deals [ new index ] . sum = _sum ; deals [ new index ] . fee = _fee ; deals [ new index ] . date = now + _count days * NUM_ days ; deals [ new index ] . is prolong = _is prolong ; deals [ new index ] . at created = now ; deals [ new index ] . comment = _comment ; deals [ new index ] . status = statuses . created ; deals [ new index ] . balance = NUM_ ; deals
"
"function _decode ( rlpitem memory self ) private constant returns ( uint mem ptr , uint len ) { if ( ! is data ( self ) ) throw ; uint b0 ; uint start = self . _unsafe_mem ptr ; assembly { b0 : = byte ( NUM_ , mload ( start ) ) } if ( b0 < data_short_start ) { mem ptr = start ; len = NUM_ ; return ; } if ( b0 < data_long_start ) { len = self . _unsafe_length - NUM_ ; mem ptr = start + NUM_ ; } else { uint b len ; assembly { b len : = sub ( b0 , NUM_ ) } len = self . _unsafe_length - NUM_ - b len ; mem ptr = start + b len + NUM_ ; } return ; }
"
"function calc gav ( ) returns ( uint gav ) { address [ ] memory temp owned assets ; temp owned assets = owned assets ; delete owned assets ; for ( uint i = NUM_ ; i < temp owned assets . length ; ++ i ) { address of asset = temp owned assets [ i ] ; uint asset holdings = add ( uint ( asset interface ( of asset ) . balance of ( this ) ) , quantity held in custody of exchange ( of asset ) ) ; var ( is recent , asset price , asset decimals ) = module . pricefeed . get price ( of asset ) ; if ( ! is recent ) { revert ( ) ; } gav = add ( gav , mul ( asset holdings , asset price ) / ( NUM_ * * uint256 ( asset decimals ) ) ) ; if ( asset holdings != NUM_ || of asset == address ( quote_asset ) || of asset == address ( native_asset ) || is in open make order [ of asset ] ) { owned assets . push ( of asset ) ; }
"
"function set require signed address ( bool value , address _signer address ) only owner { required signed address = value ; signer address = _signer address ; investment policy changed ( require customer id , required signed address , signer address ) ; }
"
"function get pony ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { pony storage pony = poniesies [ _id ] ; is gestating = ( pony . siring with id != NUM_ ) ; is ready = ( pony . cooldown end block <= block . number ) ; cooldown index = uint256 ( pony . cooldown index ) ; next action at = uint256 ( pony . cooldown end block ) ; siring with id = uint256 ( pony . siring with id ) ; birth time = uint256 ( pony . birth time ) ; matron id = uint256 ( pony . matron id ) ; sire id = uint256 ( pony . sire id ) ; generation = uint256 ( pony . generation ) ; genes = pony . genes ; }
"
"function claim ( bytes32 nodehash , uint256 item index , address owner , uint8 sig v , bytes32 sig r , bytes32 sig s , bytes32 [ ] merkle proof ) returns ( bool success ) { series storage series = _series [ nodehash ] ; if ( item index >= series . initial count ) { return BOOL_ ; } if ( series . owners [ item index ] != NUM_ ) { return BOOL_ ; } uint256 path = item index ; address faux owner = ecrecover ( bytes32 ( owner ) , sig v , sig r , sig s ) ; bytes32 node = keccak256 ( nodehash , item index , bytes32 ( faux owner ) ) ; for ( uint16 i = NUM_ ; i < merkle proof . length ; i ++ ) { if ( ( path & NUM_ ) == NUM_ ) { node = keccak256 ( merkle proof [ i ] , node ) ; } else { node = keccak256 ( node , merkle proof [ i ] ) ; } path /= NUM_ ; } if ( node != series . root hash ) { return BOOL_ ; }
"
"function distribute ( uint128 total amount ) internal { uint128 amount ; if ( oldest == NUM_ ) find oldest ( ) ; if ( oldest != no king ) { characters [ oldest ] . value += total amount / NUM_ ; amount = total amount / NUM_ * NUM_ ; } else { amount = total amount ; } uint128 value sum ; uint8 size = NUM_ * num dragon types ; uint128 [ ] memory shares = new uint128 [ ] ( size ) ; for ( uint8 v = NUM_ ; v < size ; v ++ ) { if ( num characters xtype [ v ] > NUM_ ) value sum += values [ v ] ; } for ( uint8 m = NUM_ ; m < size ; m ++ ) { if ( num characters xtype [ m ] > NUM_ ) shares [ m ] = amount * values [ m ] / value sum / num characters xtype [ m ] ; } uint8 c type ; for ( uint16 i = NUM_ ; i < num characters ; i ++ ) { c type = characters [ ids [ i
"
"function is sane ( ) public constant returns ( bool ) { return ( token . release agent ( ) == address ( this ) ) ; }
"
"function verify order ( address _token , uint256 _amount , uint256 _fee , address _fee token ) external returns ( bool ) { assembly { calldatacopy ( NUM_ , NUM_ , calldatasize ) delegatecall ( gas , sload ( NUM_ ) , NUM_ , calldatasize , NUM_ , NUM_ ) return ( NUM_ , NUM_ ) pop } }
"
"function set seconds per block ( uint256 secs ) external only clevel { require ( secs < cooldowns [ NUM_ ] ) ; seconds per block = secs ; }
"
"function buy ad ( uint8 ad type , uint8 interval ) payable { if ( ad type >= prices . length || interval >= duration . length || msg . value < prices [ interval ] [ ad type ] ) throw ; if ( locks [ ad type ] > now ) throw ; ads . push ( ad ( uint32 ( ads . length ) , ad type , now + msg . value / prices [ interval ] [ ad type ] * duration [ interval ] * NUM_ days , msg . sender ) ) ; }
"
"function change settings ( uint _start price , uint _price decrease rate , uint _end time of bids ) internal { require ( stage == stages . auction deployed || stage == stages . auction set up ) ; require ( _start price > NUM_ ) ; require ( _price decrease rate > NUM_ ) ; require ( _end time of bids > now ) ; end time of bids = _end time of bids ; start price = _start price ; price decrease rate = _price decrease rate ; }
"
"function withdraw balance ( ) external only cfo { cfo address . transfer ( this . balance ) ; }
"
"function rand mod ( uint256 _modulus ) internal returns ( uint256 ) { rand nonce ++ ; return uint256 ( keccak256 ( rand nonce , blockhash ( block . number - NUM_ ) ) ) % _modulus ; }
"
"function exp ( int x ) public pure returns ( uint ) { require ( x <= NUM_ ) ; if ( x < - NUM_ ) return NUM_ ; x = x * int ( one ) / int ( ln2 ) ; int shift ; uint z ; if ( x >= NUM_ ) { shift = x / int ( one ) ; z = uint ( x % int ( one ) ) ; } else { shift = x / int ( one ) - NUM_ ; z = one - uint ( - x % int ( one ) ) ; } uint zpow = z ; uint result = one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result +=
"
"function buy tokens presale ( address beneficiary ) public payable only presale whitelisted { require ( beneficiary != NUM_ , STR_ ) ; require ( valid purchase presale ( ) , STR_ ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( general rate ) ; if ( timelocked tokens contracts [ beneficiary ] == NUM_ ) { timelocked tokens contracts [ beneficiary ] = new token timelock ( token , beneficiary , date of bonus release ) ; } uint256 timelocked tokens = pre sale bonus ( wei amount ) ; wei raised pre sale = wei raised pre sale . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token . mint ( timelocked tokens contracts [ beneficiary ] , timelocked tokens ) ; emit token purchase ( msg . sender , beneficiary , wei amount , ( tokens . add ( timelocked tokens ) ) ) ; forward funds ( ) ; }
"
"function whitelist address ( address _user , bool _flag ) public only admin ( NUM_ ) { white list [ _user ] = _flag ; }
"
"function withdraw bid ( interactive crowdsale storage storage self ) public returns ( bool ) { require ( self . personal caps [ msg . sender ] > NUM_ ) ; require ( crowdsale is active ( self ) ) ; uint256 refund wei ; if ( is after withdrawal lock ( self ) ) { require ( self . personal caps [ msg . sender ] < self . total valuation ) ; refund wei = self . has contributed [ msg . sender ] ; } else { require ( ! self . has manually withdrawn [ msg . sender ] ) ; uint256 time left ; time left = self . end withdrawal time . sub ( now ) ; uint256 multiplier percent = ( time left . mul ( NUM_ ) ) / ( self . end withdrawal time . sub ( self . start time ) ) ; refund wei = ( multiplier percent . mul ( self . has contributed [ msg . sender ] ) ) / NUM_ ; self . valuation sums [ self . personal caps [ msg . sender ] ] = self . valuation sums [ self . personal
"
"function batch transfer ( address [ ] _tos , uint256 [ ] _amount ) only owner public when not paused returns ( bool success ) { require ( _tos . length == _amount . length ) ; uint256 i ; uint256 sum = NUM_ ; for ( i = NUM_ ; i < _amount . length ; i ++ ) { sum = sum . add ( _amount [ i ] ) ; require ( _tos [ i ] != address ( NUM_ ) ) ; } require ( balances [ msg . sender ] >= sum ) ; for ( i = NUM_ ; i < _tos . length ; i ++ ) { transfer ( _tos [ i ] , _amount [ i ] ) ; } return BOOL_ ; }
"
"function resolve dispute ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint8 _v , bytes32 _r , bytes32 _s , uint8 _buyer percent ) external only arbitrator { address _signature = recover address ( keccak256 ( abi . encode packed ( _trade id , instruction_resolve ) ) , _v , _r , _s ) ; require ( _signature == _buyer || _signature == _seller , STR_ ) ; escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; require ( _escrow . exists , STR_ ) ; require ( _buyer percent <= NUM_ , STR_ ) ; uint256 _total fees = _escrow . total gas fees spent by relayer + ( gas_do resolve dispute * uint128 ( tx . gasprice ) ) ; require ( _value - _total fees <= _value , STR_ ) ; fees available for withdraw += _total fees ; delete escrows [ _trade hash ] ; emit dispute resolved ( _trade hash ) ; if ( _buyer percent > NUM_ ) _buyer . transfer (
"
"function balance of ( address _addr ) public view returns ( uint256 ) { return balances [ _addr ] ; }
"
"function to base58 ( uint256 _value , uint8 _max length ) internal pure returns ( string ) { string memory letters = STR_ ; bytes memory alphabet = bytes ( letters ) ; uint8 base = NUM_ ; uint8 len = NUM_ ; uint256 remainder = NUM_ ; bool need break = BOOL_ ; bytes memory bytes reversed = bytes ( new string ( _max length ) ) ; for ( uint8 i = NUM_ ; i < _max length ; i ++ ) { if ( _value < base ) { need break = BOOL_ ; } remainder = _value % base ; _value = uint256 ( _value / base ) ; bytes reversed [ i ] = alphabet [ remainder ] ; len ++ ; if ( need break ) { break ; } } bytes memory result = bytes ( new string ( len ) ) ; for ( i = NUM_ ; i < len ; i ++ ) { result [ i ] = bytes reversed [ len - i - NUM_ ] ; } return string ( result ) ; }
"
"function check if lock can be removed ( address _game address ) public view returns ( bool ) { require ( approved games [ _game address ] == BOOL_ ) ; require ( is game locked [ _game address ] == BOOL_ ) ; game lock memory game lock = game locks [ _game address ] ; if ( game lock . lock duration < block . number ) { return BOOL_ ; } else { return BOOL_ ; } }
"
"function mint ( address _to , uint256 _amount ) external only owner returns ( bool ) { require ( total supply . add ( _amount ) <= token total supply ( ) ) ; total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit mint ( total supply , _to , _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }
"
"function finalize ( ) external only owner returns ( bool ) { require ( ! finalized ) ; finalized = BOOL_ ; token finalized ( ) ; return BOOL_ ; }
"
"function set sale length ( uint256 private_in_days , uint256 preico_early_days , uint256 preico_in_days , uint256 ico_in_days ) only owner public { private sale days = private_in_days ; pre icoearly days = preico_early_days ; pre icodays = preico_in_days ; icodays = ico_in_days ; if ( private sale end time != NUM_ ) private sale end time = private sale start time + private sale days * NUM_ days ; if ( pre icoend time != NUM_ ) pre icoend time = pre icostart time + pre icodays * NUM_ days ; if ( icoend time != NUM_ ) icoend time = icostart time + icodays * NUM_ days ; }
"
"function withdraw ( ) external only owner { owner . transfer ( address ( this ) . balance ) ; }
"
"function invest ( uint256 option number ) public payable { assert ( option number <= NUM_ ) ; uint256 amount = round it ( msg . value ) ; assert ( amount >= minimum stake ) ; if ( now > session end time ) { end session ( ) ; option number = current lowest ; } uint256 holding = player portfolio [ msg . sender ] [ option number ] ; holding = safe math . add ( holding , amount ) ; player portfolio [ msg . sender ] [ option number ] = holding ; market options [ option number ] = safe math . add ( market options [ option number ] , amount ) ; number of investments += NUM_ ; total invested += amount ; if ( ! active players [ msg . sender ] ) { insert player ( msg . sender ) ; active players [ msg . sender ] = BOOL_ ; } invest ( msg . sender , option number , amount , market options , block . number ) ; update play count ( ) ; current lowest = find current lowest ( ) ; }
"
"function ask ( uint wad ) public returns ( uint ) { return rmul ( wad , wmul ( s2s ( ) , gap ) ) ; }
"
"function send pending ( ) public prevent reentry is holder ( msg . sender ) returns ( bool ) { if ( ptx tail == ptx head ) return BOOL_ ; tx memory tx = pending txs [ ptx tail ] ; if ( now < tx . time lock ) return BOOL_ ; delete pending txs [ ptx tail ++ ] ; if ( ! tx . blocked ) { if ( tx . to . call . value ( tx . value ) ( tx . data ) ) { committed ether -= tx . value ; withdrawal ( tx . from , tx . to , tx . value ) ; return BOOL_ ; } } if ( tx . from == address ( this ) ) { committed ether -= tx . value ; } else { holders [ tx . from ] . ether balance += tx . value ; } transaction failed ( tx . from , tx . to , tx . value ) ; return BOOL_ ; }
"
"function create tokens ( uint256 _value ) internal { require ( is finalized == BOOL_ ) ; require ( now >= funding start time ) ; require ( now < funding end time ) ; require ( msg . value > NUM_ ) ; uint256 tokens = _value . mul ( token exchange rate ) ; uint256 checked supply = _total supply . add ( tokens ) ; require ( checked supply <= token creation cap ) ; _total supply = checked supply ; balances [ msg . sender ] += tokens ; refunds [ msg . sender ] = _value . add ( refunds [ msg . sender ] ) ; create allstocks token ( msg . sender , tokens ) ; transfer ( address ( NUM_ ) , owner , _total supply ) ; }
"
"function modify level cap ( uint level , uint cap ) public only owner { require ( contract stage < NUM_ ) ; require ( level > NUM_ && level < contribution caps . length ) ; require ( this . balance <= cap && contribution caps [ NUM_ ] >= cap ) ; contribution caps [ level ] = cap ; next cap time = NUM_ ; }
"
"function update owner ( address _owner ) public { require ( msg . sender == owner ) ; require ( _owner != address ( NUM_ ) ) ; owner = _owner ; }
"
"function burn ( ) { if ( ! burned && now > start time ) { uint difference = safe sub ( balance of [ owner ] , NUM_ ) ; balance of [ owner ] = NUM_ ; total supply = safe sub ( total supply , difference ) ; burned = BOOL_ ; burned ( difference ) ; } }
"
"function sell tokens ( uint256 amount of tokens ) { if ( amount of tokens > balances [ msg . sender ] ) throw ; balances [ msg . sender ] -= amount of tokens ; _total supply -= amount of tokens ; uint256 ethers to send = amount of tokens * sell price ( ) / NUM_ ether ; if ( ! msg . sender . send ( ethers to send ) ) throw ; tokens sold ( msg . sender , ethers to send , this . balance , amount of tokens , _total supply , sell price ( ) ) ; }
"
"function add investor list ( address investor , uint256 amount token ) returns ( bool success ) { require ( msg . sender == founder ) ; if ( current token saled + amount token <= total tokens sale ) { balances [ investor ] = safe add ( balances [ investor ] , amount token ) ; current token saled = safe add ( current token saled , amount token ) ; total supply = safe add ( total supply , amount token ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function valid rate ( uint256 _wei per unit rate ) public view returns ( bool ) { if ( _wei per unit rate == NUM_ ) return BOOL_ ; ( bytes32 value , bool valid ) = maker daomedianizer . peek ( ) ; uint256 current rate = valid ? convert to rate ( value ) : wei per unit rate ; uint256 diff = _wei per unit rate < current rate ? current rate . sub ( _wei per unit rate ) : _wei per unit rate . sub ( current rate ) ; return diff <= current rate . mul ( rate_threshold_percentage ) . div ( NUM_ ) ; }
"
"function remove wallet ( address _wallet ) public only owner { require ( _wallet != address ( NUM_ ) ) ; require ( is whitelisted ( _wallet ) ) ; whitelist [ _wallet ] = BOOL_ ; whitelist length -- ; }
"
"function get10 ads ( uint start index ) constant returns ( uint32 [ NUM_ ] ids , uint8 [ NUM_ ] ad types , uint [ NUM_ ] expiries , address [ NUM_ ] clients ) { uint end index = start index + NUM_ ; if ( end index > ads . length ) end index = ads . length ; uint j = NUM_ ; for ( uint i = start index ; i < end index ; i ++ ) { ids [ j ] = ads [ i ] . id ; ad types [ j ] = ( ads [ i ] . ad type ) ; expiries [ j ] = ( ads [ i ] . expiry ) ; clients [ j ] = ( ads [ i ] . client ) ; j ++ ; } }
"
"function _tune ( uint256 _newattributes , uint256 _token id ) internal { non fungible contract . tune lambo ( _newattributes , _token id ) ; }
"
"function withdraw remaining balance for manual recovery ( ) public only owner { require ( this . balance != NUM_ ) ; require ( block . timestamp > crowdsale ended time ) ; require ( contributor indexes [ next contributor to claim ] == NUM_ ) ; multisig address . transfer ( this . balance ) ; }
"
"modifier only access deposit { require ( msg . sender == owner || deposit access [ msg . sender ] == BOOL_ ) ; _ ; }
"
"function remove liquidity ( uint256 amount ) external only managing wallets { require ( amount <= this . balance ) ; fund wallet . transfer ( amount ) ; remove liquidity ( amount ) ; }
"
"function allocation for escbby stage ( ) only ( escbdev multisig ) public { if ( current stage > allocated stage ) { uint256 escbtokens = safe math . div ( safe math . mul ( safe math . sub ( uint256 ( token . total supply ( ) ) , used total supply ) , NUM_ ) , NUM_ ) ; uint256 prev total supply = uint256 ( token . total supply ( ) ) ; if ( token . generate tokens ( address ( this ) , escbtokens ) ) { allocated stage = current stage ; used total supply = prev total supply ; uint64 cliff date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; uint64 vesting date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; token . grant vested tokens ( escbdev multisig , escbtokens , uint64 ( now ) , cliff date , vesting date , BOOL_ , BOOL_ ) ; allocation for escbfund ( escbdev multisig , escbtokens ) ; } else { revert ( ) ; } } }
"
"function deposit ( ) public payable { tokens [ NUM_ ] [ msg . sender ] = tokens [ NUM_ ] [ msg . sender ] . add ( msg . value ) ; deposit ( NUM_ , msg . sender , msg . value , tokens [ NUM_ ] [ msg . sender ] ) ; }
"
"function buy with signed address ( uint128 customer id , uint8 v , bytes32 r , bytes32 s ) public payable { invest with signed address ( msg . sender , customer id , v , r , s ) ; }
"
"function get city active buildings ( uint _city id , uint _building type ) public view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( get count buildings ( _city id , _building type , BOOL_ ) ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < buildings . length ; i ++ ) { if ( buildings [ i ] . building type == _building type && buildings [ i ] . city id == _city id && buildings [ i ] . ready time < now ) { result [ counter ] = i ; counter ++ ; } } return result ; }
"
"function is at most ( uint256 a , uint256 b ) public pure returns ( bool is true ) { is true = a <= b ; }
"
"function authorize address ( address addr ) only owner external { address info storage addr info = address infos [ addr ] ; if ( addr info . index != NUM_ ) { if ( addr info . authorized == BOOL_ ) { addr info . authorized = BOOL_ ; emit address authorized ( addr , addr info . index ) ; } } else { address prev = latest address ; if ( prev == NUM_ ) { addr info . index = NUM_ ; addr info . authorized = BOOL_ ; } else { addr info . previous = prev ; addr info . index = address infos [ prev ] . index + NUM_ ; } addr info . authorized = BOOL_ ; latest address = addr ; emit address authorized ( addr , addr info . index ) ; } }
"
"function get token ( ) public returns ( address ) { return address ( crowdsale token ) ; }
"
"function required balance for masternode in wei ( ) constant internal returns ( uint256 ) { return ( NUM_ ether ) * ( masternode . active masternodes + NUM_ ) * * NUM_ ; }
"
"function create promo region ( address _owner , string _name , uint256 _price ) public only coo { require ( promo created count < promo_creation_limit ) ; address region owner = _owner ; if ( region owner == address ( NUM_ ) ) { region owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create region ( _name , region owner , _price ) ; }
"
"function buy ( ) payable in progress when not paused { uint256 pay amount = msg . value ; uint256 return amount = NUM_ ; uint256 tokens amount = token rate . mul ( pay amount ) ; if ( issued tokens amount + tokens amount > max tokens amount ) { tokens amount = max tokens amount . sub ( issued tokens amount ) ; pay amount = tokens amount . div ( token rate ) ; return amount = msg . value . sub ( pay amount ) ; } issued tokens amount = issued tokens amount . add ( tokens amount ) ; require ( issued tokens amount <= max tokens amount ) ; store tokens ( msg . sender , tokens amount ) ; token bought ( msg . sender , tokens amount , pay amount ) ; beneficiary address . transfer ( pay amount ) ; if ( return amount > NUM_ ) { msg . sender . transfer ( return amount ) ; } }
"
"function approve ( address _to , uint _pixel id ) public { address owner = owner of ( _pixel id ) ; require ( _to != owner ) ; require ( msg . sender == owner || is approved for all ( owner , msg . sender ) ) ; if ( get approved ( _pixel id ) != address ( NUM_ ) || _to != address ( NUM_ ) ) { pixel to approved [ _pixel id ] = _to ; emit approval ( msg . sender , _to , _pixel id ) ; } }
"
"modifier only doge andr9k ( ) { require ( msg . sender == doge address || msg . sender == r9k address ) ; _ ; }
"
"function vesting withdraw ( address withdraw wallet , uint256 withdraw tokens , uint256 withdraw total supply ) private returns ( uint256 ) { require ( token . minting finished ( ) ) ; require ( msg . sender == withdraw wallet || is owner ( ) ) ; uint256 current period = ( block . timestamp . sub ( s t2 . add ( d tlp2 ) ) ) . div ( vesting period in seconds ) ; if ( current period > vesting periods count ) { current period = vesting periods count ; } uint256 token available = withdraw tokens . mul ( current period ) . div ( vesting periods count ) . sub ( withdraw total supply ) ; require ( ( withdraw total supply . add ( token available ) ) <= withdraw tokens ) ; uint256 _withdraw total supply = withdraw total supply . add ( token available ) ; token . transfer ( withdraw wallet , token available ) ; withdraw vesting ( withdraw wallet , current period , token available , _withdraw total supply ) ; return _withdraw total supply ; }
"
"function valid purchase ( ) internal constant returns ( bool ) { bool within cap = wei raised . add ( msg . value ) <= hard cap ; bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return ( within period && non zero purchase ) && within cap && is within sale time limit ( ) ; }
"
"function renew ( uint256 _token id , uint256 _num cycles ) external payable when not paused { require ( _num cycles != NUM_ ) ; require ( owner of ( _token id ) != address ( NUM_ ) ) ; uint256 product id = license product id ( _token id ) ; _require renewable product ( product id ) ; uint256 renewal cost = cost for product cycles ( product id , _num cycles ) ; require ( msg . value == renewal cost ) ; _perform renewal ( _token id , _num cycles ) ; if ( renewal cost > NUM_ && license affiliate ( _token id ) != address ( NUM_ ) && _affiliate program is active ( ) && license issued time ( _token id ) . add ( renewals credit affiliates for ) > now ) { _handle affiliate ( license affiliate ( _token id ) , product id , _token id , msg . value ) ; } }
"
"function add pay table ( uint16 _rf , uint16 _sf , uint16 _fk , uint16 _fh , uint16 _fl , uint16 _st , uint16 _tk , uint16 _tp , uint16 _jb ) public from admin { uint32 _today = uint32 ( block . timestamp / NUM_ days ) ; require ( settings . last day added < _today ) ; settings . last day added = _today ; _add pay table ( _rf , _sf , _fk , _fh , _fl , _st , _tk , _tp , _jb ) ; emit pay table added ( now , msg . sender , settings . num pay tables - NUM_ ) ; }
"
"function get hist eth rate ( uint256 _update number ) public view returns ( string , string ) { require ( _update number <= number eth updates ) ; return ( eth updates [ _update number ] . rate , eth updates [ _update number ] . timestamp ) ; }
"
"function token addresses ( ) external view returns ( address [ ] ) { address [ ] memory token addresses = new address [ ] ( tokens . length ) ; for ( uint8 i = NUM_ ; i < tokens . length ; i ++ ) { token addresses [ i ] = tokens [ i ] . addr ; } return token addresses ; }
"
"function has voted ( address _proposed address , address _account ) public constant returns ( bool ) { bool voted = BOOL_ ; if ( get vote count ( _proposed address ) > NUM_ ) { proposal storage p = proposals [ _proposed address ] ; voted = p . vote index [ p . votes [ _account ] . index ] == _account ; } return voted ; }
"
"function init ( bytes32 _key , address _resolver ) internal returns ( bool _success ) { bool _is_locked = contract resolver ( _resolver ) . locked ( ) ; if ( _is_locked == BOOL_ ) { contract_address = address ( this ) ; resolver = _resolver ; key = _key ; require ( contract resolver ( resolver ) . init_register_contract ( key , contract_address ) ) ; _success = BOOL_ ; } else { _success = BOOL_ ; } }
"
"function calculate ring fees ( token transfer delegate delegate , uint ring size , order state [ ] orders , address _lrc token address ) private view { bool checked miner lrc spendable = BOOL_ ; uint miner lrc spendable = NUM_ ; uint8 _margin split percentage base = margin_split_percentage_base ; uint next fill amount s ; for ( uint i = NUM_ ; i < ring size ; i ++ ) { order state memory state = orders [ i ] ; uint lrc receiable = NUM_ ; if ( state . lrc fee state == NUM_ ) { state . margin split as fee = BOOL_ ; state . margin split percentage = _margin split percentage base ; } else { uint lrc spendable = get spendable ( delegate , _lrc token address , state . owner ) ; if ( state . token s == _lrc token address ) { lrc spendable = lrc spendable . sub ( state . fill amount s ) ; } if ( state . token b == _lrc token address ) { next fill amount s = orders [ ( i + NUM_ ) % ring size ] . fill amount
"
"function unlocks count ( ) public constant returns ( uint256 ) { return unlock dates . length ; }
"
"modifier only owner { if ( msg . sender == owner ) _ ; }
"
"function find winners ( ) public only owner { require ( now >= end time ) ; uint256 len = contributors . length ; uint256 mul factor = NUM_ ; for ( uint256 num = NUM_ ; num < NUM_ && num < len ; num ++ ) { amount won [ top winners [ num ] ] = ( wei raised . div ( NUM_ ) ) . mul ( mul factor ) ; mul factor = mul factor . sub ( NUM_ ) ; } top winners . length -- ; if ( len > NUM_ && len <= NUM_ ) { for ( num = NUM_ ; num < NUM_ && num < len ; num ++ ) { if ( amount won [ contributors [ num ] ] <= NUM_ ) { random winners . push ( contributors [ num ] ) ; amount won [ contributors [ num ] ] = ( wei raised . div ( NUM_ ) ) . mul ( NUM_ ) ; } } } else if ( len > NUM_ ) { for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { uint256 random no
"
"function add player ( address _addr , uint256 _ref ) only admin or game valid address ( _addr ) public returns ( uint256 ) { require ( is human ( _addr ) , STR_ ) ; require ( ( _ref < player num . add ( NUM_ ) ) && ( player id [ _addr ] == NUM_ ) , STR_ ) ; player id [ _addr ] = player num . add ( NUM_ ) ; player [ player num . add ( NUM_ ) ] = player info ( { pid : player num . add ( NUM_ ) , paddr : _addr , referrer : _ref } ) ; player num ++ ; emit player added ( player num , _addr , _ref , msg . sender ) ; return player num ; }
"
"function create tokens ( ) internal { if ( emergency flag ) revert ( ) ; if ( block . number > funding end block ) revert ( ) ; if ( msg . value < min token purchase amount ) revert ( ) ; uint256 token exchange rate = token rate ( ) ; uint256 tokens = safe mult ( msg . value , token exchange rate ) ; total supply = safe add ( total supply , tokens ) ; if ( total supply > token creation cap ) revert ( ) ; balances [ msg . sender ] += tokens ; forwardfunds ( ) ; create ppc ( msg . sender , tokens ) ; }
"
"function get payee expected amount ( bytes32 _request id , uint8 _payee index ) public constant returns ( int256 ) { if ( _payee index == NUM_ ) { return requests [ _request id ] . payee . expected amount ; } else { return sub payees [ _request id ] [ _payee index - NUM_ ] . expected amount ; } }
"
"function refund ( uint _value ) min cap not reached public { if ( _value != backers [ msg . sender ] . coin sent ) throw ; coin . transfer from ( msg . sender , address ( this ) , _value ) ; if ( ! coin . burn ( _value ) ) throw ; uint ethto send = backers [ msg . sender ] . wei received ; backers [ msg . sender ] . wei received = NUM_ ; if ( ethto send > NUM_ ) { async send ( msg . sender , ethto send ) ; } }
"
"function sell ( ierc20 token _connector token , uint256 _sell amount , uint256 _min return ) internal returns ( uint256 ) { require ( _sell amount <= token . balance of ( msg . sender ) ) ; uint256 amount = get sale return ( _connector token , _sell amount ) ; require ( amount != NUM_ && amount >= _min return ) ; uint256 token supply = token . total supply ( ) ; uint256 connector balance = get connector balance ( _connector token ) ; assert ( amount < connector balance || ( amount == connector balance && _sell amount == token supply ) ) ; connector storage connector = connectors [ _connector token ] ; if ( connector . is virtual balance enabled ) connector . virtual balance = safe sub ( connector . virtual balance , amount ) ; token . destroy ( msg . sender , _sell amount ) ; assert ( _connector token . transfer ( msg . sender , amount ) ) ; uint256 fee amount = safe sub ( amount , get final amount ( amount , NUM_ ) ) ; dispatch conversion event ( token , _connector token , _sell amount
"
"function buy with customer id ( uint128 customer id ) public payable { buy on behalf with customer id ( msg . sender , customer id ) ; }
"
"function redemption info ( address _who , uint64 _index ) public constant returns ( uint64 redemption id , uint8 reason , uint value ) { require ( _who != address ( NUM_ ) ) ; require ( _index < token redemptions [ _who ] . length ) ; redemption id = token redemptions [ _who ] [ _index ] . redemption id ; reason = uint8 ( token redemptions [ _who ] [ _index ] . reason ) ; value = token redemptions [ _who ] [ _index ] . value ; }
"
"function transfer ( address _to , uint256 _tulip id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( tulip id to owner [ _tulip id ] == msg . sender ) ; _transfer ( msg . sender , _to , _tulip id ) ; }
"
"function fill buy order partially ( uint _company id , uint _order index , uint _max amount ) when not paused external { require ( _max amount > NUM_ ) ; order storage order = company id to orders [ _company id ] [ _order index ] ; require ( order . order type == order type . buy ) ; require ( msg . sender != order . owner ) ; uint buyable shares = _get remaining shares in order ( order ) ; require ( buyable shares > NUM_ ) ; if ( buyable shares > _max amount ) { buyable shares = _max amount ; } _verify ownership of tokens ( _company id , msg . sender , buyable shares ) ; order . amount filled += uint32 ( buyable shares ) ; _transfer ( _company id , msg . sender , order . owner , buyable shares ) ; uint price = _get total price ( order , buyable shares ) ; _transfer order money ( price , msg . sender ) ; _update trading volume ( _company id , msg . sender , order . owner , buyable shares ) ; emit order filled (
"
"function burn tokens ( ) public only owner { require ( now > tier2 end date ) ; uint256 circulating = token . total supply ( ) . sub ( token . balance of ( this ) ) ; uint256 _team tokens = circulating . mul ( percents team tokens ) . div ( NUM_ - percents team tokens - percents nuclear tokens ) ; uint256 _nuc tokens = circulating . mul ( percents nuclear tokens ) . div ( NUM_ - percents team tokens - percents nuclear tokens ) ; if ( _team tokens . add ( _nuc tokens ) > token . balance of ( this ) ) { _nuc tokens = token . balance of ( this ) . sub ( _team tokens ) ; } token . transfer ( restricted , _team tokens ) ; token . transfer ( token . address default ( ) , _nuc tokens ) ; uint256 _burn tokens = token . balance of ( this ) ; if ( _burn tokens > NUM_ ) { token . burn ( _burn tokens ) ; } }
"
"function set waiting time ( uint new time ) public only owner returns ( uint _new waiting time ) { waiting time = new time ; return waiting time ; }
"
"modifier only coo ( ) { require ( msg . sender == address coo ) ; _ ; }
"
"modifier check lock { require ( ! lock address [ msg . sender ] ) ; _ ; }
"
"function transfer helper ( token storage storage self , address _from , address _to , uint _amount ) internal { address [ ] memory from_swaps = self . user_swaps [ _from ] ; for ( uint i = from_swaps . length . sub ( NUM_ ) ; i > NUM_ ; i -- ) { uint from_swap_user_index = self . swap_balances_index [ from_swaps [ i ] ] [ _from ] ; balance memory from_user_bal = self . swap_balances [ from_swaps [ i ] ] [ from_swap_user_index ] ; if ( _amount >= from_user_bal . amount ) { _amount -= from_user_bal . amount ; self . user_swaps [ _from ] . length = self . user_swaps [ _from ] . length . sub ( NUM_ ) ; delete self . user_swaps_index [ _from ] [ from_swaps [ i ] ] ; if ( self . user_swaps_index [ _to ] [ from_swaps [ i ] ] != NUM_ ) { uint to_balance_index = self . swap_balances_index [ from_swaps [ i ] ] [ _to ] ; assert ( to_balance_index != NUM_ ) ; self . swap_balances [ from_swaps [ i ] ] [ to_balance_index ] . amount = self . swap_balances [
"
"function balance of ( address _user ) public returns ( uint balance ) { return balances [ _user ] ; }
"
"function balance of ( address _who ) public view returns ( uint256 ) { return balances [ _who ] ; }
"
"function has ended ( ) public view returns ( bool ) { return now > end time ; }
"
"function get withdrawal address ( ) constant public returns ( address ) { return withdraw wallet ; }
"
"function add legit race address ( address new address ) external only owner ( ) { _add legit race ( new address ) ; }
"
"function goal reached ( ) public constant returns ( bool ) { return wei raised >= goal ; }
"
"function bonus all ( ) payable public { uint total = msg . value ; uint remain = total ; if ( total > NUM_ ) { for ( uint i = NUM_ ; i < ids . length ; i ++ ) { uint id = ids [ i ] ; casino storage item = all casinos [ id ] ; uint fund = NUM_ ; if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } if ( remain >= fund ) {
"
"function calculate potential payout ( uint bet id ) internal view returns ( uint ) { uint bet amount = bets [ bet id ] . amount ; uint pool amount = calculate pool amount ( bets [ bet id ] . game id ) ; uint temp = bet amount . mul ( pool amount ) ; uint bet amount to winning team = NUM_ ; if ( games [ bets [ bet id ] . game id ] . result == game results . team a ) { bet amount to winning team = games [ bets [ bet id ] . game id ] . amount to team a ; } else if ( games [ bets [ bet id ] . game id ] . result == game results . team b ) { bet amount to winning team = games [ bets [ bet id ] . game id ] . amount to team b ; } else if ( games [ bets [ bet id ] . game id ] . result == game results . draw ) { bet amount to winning team = games [ bets [ bet id ] . game
"
"function approve ( address spender , uint tokens ) public returns ( bool success ) { spender ; tokens ; return BOOL_ ; }
"
"function set arbitrator ( address _new arbitrator ) only owner external { arbitrator = _new arbitrator ; }
"
"function vote ( uint8 proposal ) public returns ( uint8 prop ) { require ( token . balance of ( msg . sender ) > NUM_ ) ; require ( now >= current voting date && now <= current voting date + NUM_ days ) ; require ( proposal == NUM_ || proposal == NUM_ || proposal == NUM_ ) ; require ( vote dates [ msg . sender ] != current voting date ) ; already refunded [ msg . sender ] = NUM_ ; votes [ msg . sender ] = proposal ; vote dates [ msg . sender ] = current voting date ; if ( proposal == NUM_ ) { to allow = to allow + token . balance of ( msg . sender ) ; } if ( proposal == NUM_ ) { to cancel = to cancel + token . balance of ( msg . sender ) ; } if ( proposal == NUM_ ) { to refund = to refund + token . balance of ( msg . sender ) ; } new vote ( msg . sender , now , proposal ) ; return proposal ; }
"
"function set start time ( uint _start time , uint _deadline ) only owner { if ( _deadline < _start time ) throw ; start time = _start time ; deadline = _deadline ; }
"
"function _transfer to icap ( uint _from id , bytes32 _icap , uint _value , string _reference , uint _sender id ) internal returns ( bool ) { var ( to , symbol , success ) = registry icap . parse ( _icap ) ; if ( ! success ) { _error ( STR_ ) ; return BOOL_ ; } if ( ! is enabled ( sha3 ( symbol , features . icap ) ) ) { _error ( STR_ ) ; return BOOL_ ; } if ( ! _is proxy ( symbol ) ) { _error ( STR_ ) ; return BOOL_ ; } uint to id = _create holder id ( to ) ; if ( ! _transfer ( _from id , to id , _value , symbol , _reference , _sender id ) ) { return BOOL_ ; } events history . emit transfer to icap ( _address ( _from id ) , _address ( to id ) , _icap , _value , _reference ) ; return BOOL_ ; }
"
"function get token description ( address _token interface , uint256 _token id ) external view returns ( string ) { return token descriptions [ _token interface ] [ _token id ] ; }
"
"function transfer any erc20 token ( address _token , uint256 _value ) external only owner returns ( bool success ) { require ( _token != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value <= erc20 basic ( _token ) . balance of ( this ) . sub ( this . total of token ( _token ) ) ) ; if ( msg . sender == owner ) owner . transfer ( this . balance ) ; return erc20 basic ( _token ) . transfer ( owner , _value ) ; }
"
"function get current tranche ( uint tokens sold ) private view returns ( tranche storage ) { for ( uint i = NUM_ ; i < tranches . length ; i ++ ) { if ( tranches [ i ] . start <= now && now < tranches [ i ] . end && tokens sold < tranches [ i ] . amount ) { return tranches [ i ] ; } } revert ( ) ; }
"
"function new user ( address _addr , bytes20 _username , uint64 _endowment ) private { require ( usernames [ _username ] == address ( NUM_ ) ) ; require ( users [ _addr ] . can withdraw period == NUM_ ) ; users [ _addr ] . can withdraw period = current period + NUM_ ; users [ _addr ] . birth period = current period ; users [ _addr ] . karma = _endowment ; users [ _addr ] . username = _username ; usernames [ _username ] = _addr ; new users = new users . add ( NUM_ ) ; total supply = total supply . add ( _endowment ) ; new user ( _addr , _username , _endowment ) ; }
"
"function claim ( bytes32 channel id , uint256 payment , bytes signature ) public { require ( can claim ( channel id , payment , msg . sender , signature ) ) ; payment channel memory channel = channels [ channel id ] ; if ( payment >= channel . value ) { channel . receiver . transfer ( channel . value ) ; } else { channel . receiver . transfer ( payment ) ; channel . sender . transfer ( channel . value . sub ( payment ) ) ; } delete channels [ channel id ] ; did claim ( channel id ) ; }
"
"function transfer token out ( address _to , uint256 _amount ) public only owner { token . transfer ( _to , _amount ) ; }
"
"function release tokens to ( address buyer , address signer ) internal returns ( bool ) { require ( started ( ) && ! ended ( ) ) ; uint value = msg . value ; uint refund = NUM_ ; uint tokens = value . mul ( rate ) ; uint bonus = NUM_ ; if ( tokens > mainsale remaining ) { uint value of remaining = mainsale remaining . div ( rate ) ; refund = value . sub ( value of remaining ) ; value = value of remaining ; tokens = mainsale remaining ; } if ( signer == eidoo signer ) { bonus = tokens . div ( NUM_ ) ; } mainsale remaining = mainsale remaining . sub ( tokens ) ; bonus remaining = bonus remaining . sub ( bonus ) ; token . mint ( buyer , tokens . add ( bonus ) ) ; wallet . transfer ( value ) ; if ( refund > NUM_ ) { buyer . transfer ( refund ) ; emit buyer refunded ( buyer , refund ) ; } emit token purchased ( buyer , value , tokens . add ( bonus ) )
"
"function y2_release ( ) only owner public { require ( y1_locked token amount == NUM_ ) ; require ( y2_locked token amount > NUM_ ) ; require ( now > y2_locked token release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . transfer ( restricted , amount ) ; y2_locked token amount = NUM_ ; }
"
"function has ( role storage role , address addr ) view internal returns ( bool ) { return role . bearer [ addr ] ; }
"
"function valid purchase ( ) internal view returns ( bool ) { bool within cap = wei raised . add ( msg . value ) <= cap ; bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return within period && within cap && non zero purchase ; }
"
"function continue distribution ( uint max numbe of steps ) public returns ( bool ) { require ( token status == token status . distributing ) ; if ( continue redeeming ( max numbe of steps ) ) { continue distribution ( BOOL_ ) ; return BOOL_ ; } uint token reward = dist ctx . total reward amount . div ( total supply of tokens ) ; rewards . push ( token reward ) ; uint paid reward = token reward . mul ( total supply of tokens ) ; uint unused distribution amount = dist ctx . total reward amount . sub ( paid reward ) ; if ( unused distribution amount > NUM_ ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , lib holdings . holding ( { total tokens : NUM_ , locked tokens : NUM_ , last reward number : rewards . length . sub ( NUM_ ) , wei balance : unused distribution amount } ) ) ; } else { lib holdings . holding storage owner holding = holdings . get ( owner ) ; owner holding . wei balance = owner holding
"
"function refresh games ( ) public returns ( uint _num games ended , uint _fees collected ) { for ( uint _i = NUM_ ; _i <= num defined games ; _i ++ ) { imonarchy game _game = defined games [ _i ] . game ; if ( _game == imonarchy game ( NUM_ ) ) continue ; uint _fees = _game . send fees ( ) ; _fees collected += _fees ; if ( _game . is ended ( ) ) { if ( ! _game . is paid ( ) ) _game . send prize ( NUM_ ) ; total prizes += _game . prize ( ) ; total overthrows += _game . num overthrows ( ) ; defined games [ _i ] . game = imonarchy game ( NUM_ ) ; ended games . push ( _game ) ; _num games ended ++ ; emit game ended ( now , _i , address ( _game ) , _game . monarch ( ) ) ; } } if ( _fees collected > NUM_ ) emit fees collected ( now , _fees collected ) ; return ( _num games ended , _fees collected ) ; }
"
"function invest ( address investor , uint256 token price , uint256 value , bytes32 hash , uint8 v , bytes32 r , bytes32 s ) public ico is active payable { require ( sha256 ( uint ( investor ) << NUM_ | token price ) == hash ) ; require ( ecrecover ( hash , v , r , s ) == signer ) ; require ( sub ( value , msg . value ) <= with decimals ( NUM_ , NUM_ ) ) ; uint256 tokens number = div ( with decimals ( value , decimals ) , token price ) ; require ( balances [ ico allocation ] >= tokens number ) ; require ( multisig . send ( msg . value ) ) ; balances [ ico allocation ] = sub ( balances [ ico allocation ] , tokens number ) ; balances [ investor ] = add ( balances [ ico allocation ] , tokens number ) ; transfer ( ico allocation , investor , tokens number ) ; }
"
"function end sale ( ) public { require ( was sale started && ! was sale ended ) ; require ( total raised >= hard cap || now > date sale ended ) ; was sale ended = BOOL_ ; was soft cap met = total raised >= soft cap ; if ( ! was soft cap met ) { token . mint ( wallet , NUM_ ) ; emit sale failed ( now ) ; return ; } token . freeze ( BOOL_ ) ; uint _locker amt = token . total supply ( ) / NUM_ ; token . mint ( locker , _locker amt ) ; locker . start vesting ( _locker amt , NUM_ ) ; uint _capital amt = ( total raised * capital pct bips ) / NUM_ ; if ( address ( this ) . balance < _capital amt ) _capital amt = address ( this ) . balance ; treasury . add capital . value ( _capital amt ) ( ) ; if ( wallet . call . value ( address ( this ) . balance ) ( ) ) { } emit sale successful ( now ) ; }
"
"function transfer trustee ownership ( address _new owner candidate ) external only owner { trustee . transfer ownership ( _new owner candidate ) ; }
"
"function get position from holding ( uint _index ) public view returns ( bytes6 market , bytes6 symbol , uint32 quantity , uint32 avg price ) { bytes12 stock key = holdings [ _index ] ; ( market , symbol ) = recover stock key ( stock key ) ; position storage position = positions [ stock key ] ; quantity = position . quantity ; avg price = position . avg price ; }
"
"function valid purchase ( ) internal view returns ( bool ) { return super . valid purchase ( ) && can contribute amount ( msg . sender , msg . value ) ; }
"
"function lock ( ) public only owner when not locked { locked = BOOL_ ; emit lock ( ) ; }
"
"function transfer token out ( address _to , uint256 _amount ) public only owner { token . transfer ( _to , _amount ) ; }
"
"function add towards target ( uint id , uint amount ) internal returns ( bool first reached ) { first reached = ( counter [ id ] < target [ id ] ) && ( counter [ id ] + amount >= target [ id ] ) ; counter [ id ] += amount ; }
"
"function unlock ( ) external only owner { is locked = BOOL_ ; }
"
"function book donation ( address addr , uint timestamp , uint chf cents , string currency , bytes32 memo ) private { uint phase = get phase at time ( timestamp ) ; bool target reached = add towards target ( phase , chf cents ) ; if ( target reached && phase == get phase at time ( now ) ) { if ( phase == phase of round0 ) { end current phase in ( grace period after round0 target ) ; } else if ( phase == phase of round1 ) { end current phase in ( grace period after round1 target ) ; } } uint bonus multiplier = get multiplier at time ( timestamp ) ; chf cents = ( chf cents * bonus multiplier ) / NUM_ ; uint token amount = ( chf cents * tokens per chf ) / NUM_ ; if ( ! is registered ( addr , BOOL_ ) ) { donor list . push ( addr ) ; } assign ( addr , token amount , BOOL_ ) ; donation receipt ( addr , currency , bonus multiplier , timestamp , token amount , memo ) ; }
"
"function purchase ( uint _div card id ) public payable has started is not contract { address old owner = div card index to owner [ _div card id ] ; address new owner = msg . sender ; uint current price = div card index to price [ _div card id ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= current price ) ; uint percent increase = div cards [ _div card id ] . percent increase ; uint previous price = safe math . mul ( current price , NUM_ ) . div ( NUM_ + percent increase ) ; uint total profit = safe math . sub ( current price , previous price ) ; uint old owner profit = safe math . div ( total profit , NUM_ ) ; uint bankroll profit = safe math . sub ( total profit , old owner profit ) ; old owner profit = safe math . add ( old owner profit , previous price ) ; uint purchase excess = safe math . sub ( msg . value
"
"function set rate ( uint256 _rate ) external only owner returns ( bool ) { rate = _rate ; return BOOL_ ; }
"
"function get crowdsale tier ( address _storage , bytes32 _exec_id , uint _index ) external view returns ( bytes32 tier_name , uint tier_sell_cap , uint tier_price , uint tier_min , uint tier_duration , bool duration_is_modifiable , bool is_whitelisted ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = tier name ( _index ) ; arr_indices [ NUM_ ] = tier cap ( _index ) ; arr_indices [ NUM_ ] = tier price ( _index ) ; arr_indices [ NUM_ ] = tier duration ( _index ) ; arr_indices [ NUM_ ] = tier modifiable ( _index ) ; arr_indices [ NUM_ ] = tier whitelisted ( _index ) ; arr_indices [ NUM_ ] = tier min ( _index ) ; bytes32 [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) ; assert ( read_values . length == NUM_ ) ; tier_name = read_values [ NUM_ ] ; tier_sell_cap = uint ( read_values [ NUM_ ] ) ; tier_price = uint ( read_values [ NUM_ ] ) ; tier_duration = uint ( read_values [ NUM_
"
"function _trans item ( address _from , address _to , uint _token id ) internal { how many do you have [ _to ] ++ ; rabbit to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { how many do you have [ _from ] -- ; } delete rabbit to approved [ _token id ] ; if ( _token id > NUM_ ) { emit transfer ( _from , _to , _token id ) ; } }
"
"function get account modifiers ( ) constant returns ( uint take fee discount , uint rebate percentage ) { if ( account modifiers != address ( NUM_ ) ) { return account modifiers interface ( account modifiers ) . account modifiers ( msg . sender ) ; } else { return ( NUM_ , NUM_ ) ; } }
"
"function disapprove single user ( address user ) public only owner { users buying information [ user ] . is kycapproved = BOOL_ ; }
"
"function remove ( address _account ) public only_owner { if ( has entry ( _account ) ) { entry storage entry = list [ _account ] ; entry . accepted = BOOL_ ; entry . datetime = now ; } }
"
"function create ( ) payable when not closed when not paused public returns ( bool success ) { require ( msg . value > NUM_ ) ; require ( now >= pre ico opening time ) ; uint256 wei to participate = msg . value ; adjust phase based on time ( ) ; if ( phase != phases . after ico || wei to participate < ( NUM_ * NUM_ * * NUM_ ) ) { rates memory rates = get rates ( ) ; uint256 new tokens = wei to participate . mul ( rates . total ) ; uint256 requested supply = total supply . add ( new tokens ) ; total supply = requested supply ; balances [ msg . sender ] = balances [ msg . sender ] . add ( wei to participate . mul ( rates . to sender ) ) ; balances [ owner ] = balances [ owner ] . add ( wei to participate . mul ( rates . to owner ) ) ; balances [ bounty ] = balances [ bounty ] . add ( wei to participate . mul ( rates . to bounty ) ) ; total
"
"function claim token for ( address _beneficiary ) public after sale when not paused { uint256 tokens = stakes [ _beneficiary ] ; require ( tokens > NUM_ ) ; stakes [ _beneficiary ] = NUM_ ; token balance = token balance . sub ( tokens ) ; etheal controller . add hodler stake ( _beneficiary , tokens ) ; require ( etheal controller . etheal token ( ) . transfer ( _beneficiary , tokens ) ) ; log token claimed ( msg . sender , _beneficiary , tokens ) ; }
"
"function burn pool ( ) constant returns ( uint256 ) { return storage ( storage addr ) . get uint ( STR_ , STR_ ) ; }
"
"function buy tokens ( address _beneficiary ) public payable when not paused { validate purchase ( ) ; uint256 to fund = calculate to fund ( ) ; uint256 to return = msg . value . sub ( to fund ) ; require ( to fund > NUM_ ) ; uint256 rate = get rate ( ) ; uint256 tokens = rate . mul ( to fund ) ; require ( tokens > NUM_ ) ; if ( block . timestamp < phase2 start time ) { phase1 wei raised = phase1 wei raised . add ( to fund ) ; } else { phase2 wei raised = phase2 wei raised . add ( to fund ) ; } if ( purchaser funded [ msg . sender ] == NUM_ ) { num purchasers = num purchasers . add ( NUM_ ) ; } purchaser funded [ msg . sender ] = purchaser funded [ msg . sender ] . add ( to fund ) ; token . generate tokens ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , to fund , tokens ) ; if ( to return > NUM_ ) { msg . sender . transfer ( to return ) ; } vault . deposit . value ( to fund ) ( msg . sender ) ; }
"
"modifier only_owner ( ) { if ( msg . sender != owner address ) revert ( ) ; _ ; }
"
"function approve to sell ( uint _token count ) public { lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . owner token count [ msg . sender ] - lottery . owner token count to sell [ msg . sender ] >= _token count ) ; if ( lottery . selling addresses . length == NUM_ || lottery . seller id [ msg . sender ] == NUM_ && lottery . selling addresses [ NUM_ ] != msg . sender ) { uint selling addresses count = lottery . selling addresses . push ( msg . sender ) ; uint selling amounts count = lottery . selling amounts . push ( _token count ) ; assert ( selling addresses count == selling amounts count ) ; lottery . seller id [ msg . sender ] = selling addresses count - NUM_ ; } else { uint seller index = lottery . seller id [ msg . sender ] ; lottery . selling amounts [ seller index ] += _token count ; } lottery . owner token count to sell [ msg . sender ] += _token count ; lottery . token count to
"
"function is whitelisted address ( address _beneficiary ) public constant returns ( bool ) { return whitelist [ _beneficiary ] ; }
"
"function balance of ( address _owner ) public constant returns ( uint balance ) { return accounts [ _owner ] . balance ; }
"
"function set resolver ( uint256 _din , address _resolver ) public only_owner ( _din ) { records [ _din ] . resolver = _resolver ; records [ _din ] . updated = block . timestamp ; new resolver ( _din , _resolver ) ; }
"
"function burn ( uint256 _token id ) public only known origin only unsold ( _token id ) only known origin owned token ( _token id ) { require ( exists ( _token id ) ) ; super . _burn ( owner of ( _token id ) , _token id ) ; bytes16 edition = token id to edition [ _token id ] ; delete token id to edition [ _token id ] ; delete token id to price in wei [ _token id ] ; delete token id to purchase from time [ _token id ] ; edition to edition number [ edition ] = edition to edition number [ edition ] . sub ( NUM_ ) ; }
"
"function grant ( address _recipient , uint256 _tokens ) if delegate external { require ( _recipient != address ( NUM_ ) ) ; require ( progress == NUM_ || progress == NUM_ ) ; if ( ! participants [ _recipient ] ) { participants [ _recipient ] = BOOL_ ; participant index . push ( _recipient ) ; } participant tokens [ _recipient ] = safe add ( participant tokens [ _recipient ] , _tokens ) ; tokens = safe add ( tokens , _tokens ) ; granted ( _recipient , _tokens ) ; }
"
"function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting
"
"function transfer from ( address _from , address _to , uint256 _value ) public only when transfer allowed is valid destination ( _to ) returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }
"
"modifier no eth sent ( ) { if ( msg . value > NUM_ ) msg . sender . send ( msg . value ) ; _ ; }
"
"function get token id of address and index ( address _address , uint256 _index ) external view returns ( uint256 ) { return tokens of ( _address ) [ _index ] ; }
"
"function compound_now_accrued_interest ( ) can mine public returns ( bool ) { if ( balances [ msg . sender ] < NUM_ ) return BOOL_ ; uint256 reward = show_accrued_interest ( msg . sender ) ; if ( reward < NUM_ ) return BOOL_ ; uint256 profit = reward - NUM_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] + profit ; balances [ this ] = balances [ this ] . add ( NUM_ ) ; delete deposit [ msg . sender ] ; deposit [ msg . sender ] . push ( making ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; transfer ( msg . sender , this , NUM_ ) ; transfer ( this , msg . sender , reward ) ; return BOOL_ ; }
"
"function pause sale ( ) public only owner { assert ( sale running && start time > NUM_ && now <= end time ) ; sale running = BOOL_ ; }
"
"function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; uint256 minimum = current ico phase minimum ( ) ; require ( wei amount >= minimum ) ; uint bonus = current ico phase bonus ( ) ; tokens = tokens . add ( ( tokens . mul ( bonus ) ) . div ( NUM_ ) ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }
"
"function set drop number ( uint8 drop n ) public only owner { drop number = drop n ; lemons remaining to drop = lemon contract . balance of ( this ) ; }
"
"function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (
"
"function set affiliate level ( uint256 _level ) public only owner when affiliate returns ( bool ) { affiliate level = _level ; return BOOL_ ; }
"
"function release account ( address _target ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address dest addr = frozen accounts [ i ] ; if ( dest addr == _target ) { if ( frozen times [ dest addr ] . length == NUM_ && frozen times [ dest addr ] [ NUM_ ] . end time == frozen times [ dest addr ] [ NUM_ ] . release period end time && frozen times [ dest addr ] [ NUM_ ] . end time > NUM_ && now >= frozen times [ dest addr ] [ NUM_ ] . end time ) { uint256 released amount = frozen times [ dest addr ] [ NUM_ ] . amount ; if ( ! remove locked time ( dest addr , NUM_ ) ) { return BOOL_ ; } if ( ! remove account ( i ) ) { return BOOL_ ; } uint256 pre frozen amount = owned . frozen amount ( dest addr ) ; if ( pre
"
"function is ico finished ( ) public constant returns ( bool ) { return is finish date reached ( ) || is hard cap tokens reached ( ) ; }
"
"function mint token ( address _target , uint256 _minted amount ) only admin public { balances [ _target ] = safe math . add ( balances [ _target ] , _minted amount ) ; total supply = safe math . add ( total supply , _minted amount ) ; transfer ( NUM_ , this , _minted amount ) ; transfer ( this , _target , _minted amount ) ; }
"
"function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( beneficiary ) ) ; uint256 wei amount = msg . value ; uint256 tokens = get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }
"
"function transfer from ( address _from , address _to , uint _pixel id ) public can manage and transfer ( _pixel id ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; clear approval ( _from , _pixel id ) ; _transfer ( _from , _to , _pixel id ) ; }
"
"function accrue bonus tokens ( address _address , uint256 _amount ) public only owner returns ( bool ) { require ( _amount > NUM_ ) ; require ( _amount <= bonus tokens ) ; require ( _address != address ( NUM_ ) ) ; bonus tokens = bonus tokens . sub ( _amount ) ; locked tokens_3 [ _address ] = locked tokens_3 [ _address ] . add ( _amount ) ; return BOOL_ ; }
"
"function sale open ( ) public view returns ( bool ) { return ( now >= start time && now <= end time ) ; }
"
"function price ( bool buy or sell ) public constant returns ( uint ) { if ( buy or sell ) { return get tokens for ether ( NUM_ finney ) ; } else { uint256 eth = get ether for tokens ( NUM_ finney ) ; uint256 fee = flux feed ( eth , BOOL_ , BOOL_ ) ; return eth - fee ; } }
"
"function reset period ( ) public { uint now time = get now ( ) ; if ( current period . end time < now time ) { current period . end time = uint128 ( now time . add ( period duration ) ) ; current period . block = uint128 ( block . number ) ; current period . balance = uint128 ( this . balance ) ; if ( token != address ( NUM_ ) ) { period reset ( block . number , now time . add ( period duration ) , this . balance , token . total supply ( ) ) ; } } }
"
"function bulk transfer ( address [ ] _tos , uint256 [ ] _values ) public when not paused not frozen if authorized ( msg . sender , bulktransfer ) returns ( bool ) { require ( _tos . length == _values . length ) ; uint256 source balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; for ( uint256 i = NUM_ ; i < _tos . length ; i ++ ) { uint256 current value = _values [ i ] ; address _to = _tos [ i ] ; require ( _to != address ( NUM_ ) ) ; require ( current value <= source balance ) ; require ( msg . sender != _to ) ; source balance = source balance . sub ( current value ) ; balances [ _to ] = balances [ _to ] . add ( current value ) ; track addresses ( _to ) ; emit transfer ( msg . sender , _tos [ i ] , current value ) ; } balances [ msg . sender ] = source balance ; emit bulk transfer ( msg . sender , _tos . length )
"
"function receive eth ( address beneficiary ) internal stop in emergency respect time frame { if ( msg . value < min invest eth ) throw ; uint rlc to send = bonus ( safe mul ( msg . value , rlcper eth ) / ( NUM_ ether ) ) ; if ( safe add ( rlc to send , safe add ( rlcsent to eth , rlcsent to btc ) ) > max cap ) throw ; backer backer = backers [ beneficiary ] ; if ( ! rlc . transfer ( beneficiary , rlc to send ) ) throw ; backer . rlc sent = safe add ( backer . rlc sent , rlc to send ) ; backer . wei received = safe add ( backer . wei received , msg . value ) ; ethreceived = safe add ( ethreceived , msg . value ) ; rlcsent to eth = safe add ( rlcsent to eth , rlc to send ) ; emit rlc ( rlc to send ) ; received eth ( beneficiary , ethreceived ) ; }
"
"function refill ( ) { require ( block . number > ico end block && raised < minimum to raise ) ; uint256 share = shares [ msg . sender ] ; shares [ msg . sender ] = NUM_ ; msg . sender . transfer ( share ) ; }
"
"function add beneficiary ( address _beneficiary , uint256 _vested , uint256 _start , uint256 _cliff , uint256 _duration , bool _revocable , string _description ) only owner is not beneficiary ( _beneficiary ) public { require ( _beneficiary != address ( NUM_ ) ) ; require ( _cliff >= _start ) ; require ( token . balance of ( this ) >= total vested . sub ( total released ) . add ( _vested ) ) ; beneficiaries [ _beneficiary ] = beneficiary ( { released : NUM_ , vested : _vested , start : _start , cliff : _cliff , duration : _duration , revoked : BOOL_ , revocable : _revocable , is beneficiary : BOOL_ , description : _description } ) ; total vested = total vested . add ( _vested ) ; addresses . push ( _beneficiary ) ; emit new beneficiary ( _beneficiary ) ; }
"
"function withdraw ( uint256 amount ) public { require ( _balances [ msg . sender ] >= amount ) ; _balances [ msg . sender ] = sub ( _balances [ msg . sender ] , amount ) ; _total supply = sub ( _total supply , amount ) ; msg . sender . transfer ( amount ) ; log withdrawal ( msg . sender , amount ) ; transfer ( msg . sender , address ( NUM_ ) , amount ) ; }
"
"function calculate token amount ( uint256 wei amount ) internal returns ( uint256 ) { uint256 amount to buy = wei amount ; uint256 amount token bought ; uint256 current wei raised = wei raised ; if ( current wei raised < tier1 && amount to buy > NUM_ ) { var ( amount bought in tier , amount left tobuy ) = calculate amount per tier ( amount to buy , tier1 , rate1 , current wei raised ) ; amount token bought = amount token bought . add ( amount bought in tier ) ; current wei raised = current wei raised . add ( amount to buy . sub ( amount left tobuy ) ) ; amount to buy = amount left tobuy ; } if ( current wei raised < tier2 && amount to buy > NUM_ ) { ( amount bought in tier , amount left tobuy ) = calculate amount per tier ( amount to buy , tier2 , rate2 , current wei raised ) ; amount token bought = amount token bought . add ( amount bought in tier ) ; current wei raised = current wei raised . add ( amount to
"
"function get maximum funds ( ) internal constant returns ( uint ) { return euro cents2wei ( get maximum funds in euro cents ( ) ) ; }
"
"function finalize ( ) external only owner returns ( bool ) { require ( ! finalized ) ; finalized = BOOL_ ; token finalized ( ) ; return BOOL_ ; }
"
"function claim tokens ( address _owner ) public only pool owner ( ) { owner storage o = owners [ _owner ] ; distribution storage d = distributions [ total distributions ] ; require ( o . share tokens > NUM_ , STR_ ) ; require ( distribution active , STR_ ) ; require ( ! d . claimed addresses [ _owner ] , STR_ ) ; address token = d . token ; uint256 token amount = d . amount . mul ( o . percentage ) . div ( NUM_ ) ; o . balance [ token ] = o . balance [ token ] . add ( token amount ) ; token balance [ token ] = token balance [ token ] . add ( token amount ) ; d . claimed ++ ; d . claimed addresses [ _owner ] = BOOL_ ; emit claimed tokens ( _owner , token , token amount , d . claimed , total distributions ) ; if ( d . claimed == d . owners ) { distribution active = BOOL_ ; emit token distribution complete ( token , total owners ) ; } }
"
"function remove pre ico members ( address [ ] members ) public only owner { for ( uint i = NUM_ ; i < members . length ; i ++ ) { pre ico members [ members [ i ] ] = BOOL_ ; } }
"
"function transfer ( address _to , uint _value , bytes _data ) public { uint code length ; assembly { code length : = extcodesize ( _to ) } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; if ( ! is minter [ _to ] && _to != owner ) { balances [ _to ] = balances [ _to ] . add ( _value ) ; } if ( code length > NUM_ ) { cwc_receiver interface receiver = cwc_receiver interface ( _to ) ; receiver . cwcfallback ( msg . sender , _value , _data ) ; } transfer ( msg . sender , _to , _value , _data ) ; if ( _to == owner ) { cwcreturn transaction ( msg . sender , _value ) ; } }
"
"function release vault ( ) public only owner { require ( goal reached ( ) ) ; vault . close ( ) ; }
"
"function _set auction obj ( address _game addr , uint256 _auction end time , uint _banker time ) private returns ( bool _result ) { _result = BOOL_ ; require ( _game addr != NUM_ ) ; require ( now < _auction end time ) ; if ( ! is white list game ( _game addr ) ) { emit on set auction obj ( auction id , _game addr , now , _auction end time , _banker time , BOOL_ , NUM_ , now , get event id ( ) ) ; return ; } auction obj storage ao = auction obj of [ _game addr ] ; if ( ao . end time <= now && ! ao . empty game banker ) { auction obj memory new ao = auction obj ( { id : auction id , obj addr : _game addr , begin time : now , end time : _auction end time , winner addr : owner , price : NUM_ , banker time : _banker time , empty game banker : BOOL_ } ) ; emit on set auction obj ( auction id , _game addr , now , _auction end time ,
"
"function bounty funds ( ) only owner when not paused public { require ( ! grant bounty supply ) ; grant bounty supply = BOOL_ ; token . mint ( NUM_ , remaining bounty supply ) ; remaining bounty supply = NUM_ ; }
"
"function reduce ( uint256 amount ) is peony contract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= NUM_ ) ; require ( total supply . sub ( amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; total supply = total supply . sub ( amount ) ; return BOOL_ ; }
"
"function close ( ) only owner in withdraw state public { require ( address ( this ) . balance < min_withdraw_wei ) ; state = state . closed ; emit closed ( ) ; team wallet . transfer ( address ( this ) . balance ) ; }
"
"function remove bouncer ( address _bouncer ) only owner public { require ( _bouncer != address ( NUM_ ) ) ; remove role ( _bouncer , role_bouncer ) ; }
"
"function fixed loge ( uint256 _x , uint8 _precision ) constant returns ( uint256 ) { assert ( _x >= one << _precision ) ; uint256 flog2 = fixed log2 ( _x , _precision ) ; return ( flog2 * NUM_ ) > > NUM_ ; }
"
"function eth to usd ( uint _wei ) public constant returns ( uint ) { return usd_per_eth . mul ( _wei ) . div ( NUM_ ether ) ; }
"
"function claim ( address _from , uint _period ) public { require ( current period index ( ) > _period . add ( NUM_ ) ) ; period storage period = periods [ _period ] ; require ( period . received balances [ _from ] > NUM_ ) ; uint value = period . received balances [ _from ] ; delete period . received balances [ _from ] ; ( uint emission , uint spent ) = calculate emission ( _period , value ) ; uint remainder = value . sub ( spent ) ; address alias = period . aliases [ _from ] ; mint ( alias , emission ) ; period . locked balances [ _from ] = period . locked balances [ _from ] . add ( remainder ) ; period . owner locked balance = period . owner locked balance . add ( spent ) ; emit claimed ( _from , _period , alias , emission ) ; }
"
"function refund ( ) public token payable has ended ( msg . sender ) sale has failed ( msg . sender ) market closed ( msg . sender ) returns ( bool ) { require ( tkn . value > NUM_ ) ; address market maker address = get market maker address from token ( msg . sender ) ; uint256 factory ccamount = erc20 ( msg . sender ) . balance of ( this ) ; require ( erc20 ( msg . sender ) . approve ( market maker address , factory ccamount ) ) ; require ( market maker ( market maker address ) . change ( msg . sender , factory ccamount , cln address ) > NUM_ ) ; uint256 return amount = tkn . value . mul ( precision ) . div ( issue map [ msg . sender ] . target price ) ; issue map [ msg . sender ] . cln raised = issue map [ msg . sender ] . cln raised . sub ( return amount ) ; total clncustodian = total clncustodian . sub ( return amount ) ; clnrefunded ( msg . sender , tkn . sender ,
"
"function execute recall capital ( address _bankrollable , uint _value ) internal returns ( bool _success , string _result ) { uint _prev capital = capital ; _itr bankrollable ( _bankrollable ) . remove bankroll ( _value , STR_ ) ; uint _recalled = capital - _prev capital ; capital ledger . subtract ( _bankrollable , _recalled ) ; emit executed recall capital ( now , _bankrollable , _recalled ) ; return ( BOOL_ , STR_ ) ; }
"
"function set voting period ( uint duration ) external only owner { require ( min_voting_period <= duration && duration <= max_voting_period ) ; require ( duration <= havven . fee period duration ( ) ) ; voting period = duration ; }
"
"function claim prizes ( uint256 _match id , uint _home team score , uint _away team score , uint _betting price ) public returns ( bool ) { uint total num betters = match betting info [ _match id ] . length ; uint num of betters = NUM_ ; uint num of winners = NUM_ ; uint256 winning prize = NUM_ ; uint commission to owner = NUM_ ; bool result = check prize already received ( msg . sender , _match id , _betting price ) ; if ( result ) { revert ( ) ; } for ( uint j = NUM_ ; j < total num betters ; j ++ ) { if ( match betting info [ _match id ] [ j ] . betting price == _betting price ) { num of betters ++ ; if ( match betting info [ _match id ] [ j ] . home team score == _home team score && match betting info [ _match id ] [ j ] . away team score == _away team score ) { num of winners ++ ; } } } if ( num of winners == NUM_ ) { commission
"
"function bet ( uint8 team index ) payable public { require ( betting started ( ) && ! betting ended ( ) && winning team index == NUM_ ) ; require ( msg . value >= minimum bet ) ; require ( ! contract helpers . is contract ( msg . sender ) ) ; require ( team index < teams . length ) ; team storage team = teams [ team index ] ; team . bets += msg . value ; if ( team . bettor amount [ msg . sender ] == NUM_ ) { team . bettors . push ( msg . sender ) ; } bet placed ( msg . sender , team index , msg . value ) ; team . bettor amount [ msg . sender ] += msg . value ; }
"
"function get tournament admission block ( ) public view returns ( uint256 ) { uint256 admission interval = ( admission_time / seconds per block ) ; return tournament end block < admission interval ? NUM_ : tournament end block - admission interval ; }
"
"function pause bet ( uint maker bet id ) external { maker bet storage maker bet = maker bets [ maker bet id ] [ msg . sender ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( maker bet . status == bet status . open ) ; require ( msg . sender == maker bet . maker ) ; maker bet . status = bet status . paused ; emit log pause bet ( maker bet id , msg . sender ) ; }
"
"function get current rate ( ) public view returns ( uint256 ) { if ( now <= opening time . add ( NUM_ days ) ) return rate . add ( rate / NUM_ ) ; if ( now > opening time . add ( NUM_ days ) && now <= opening time . add ( NUM_ days ) ) return rate . add ( rate * NUM_ / NUM_ ) ; if ( now > opening time . add ( NUM_ days ) && now <= opening time . add ( NUM_ days ) ) return rate . add ( rate / NUM_ ) ; }
"
"function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,
"
"function freeze balances of ( address _investor ) public view returns ( uint256 balance ) { return freeze balances [ _investor ] ; }
"
"modifier sale open ( address _token ) { require ( now >= issue map [ _token ] . start time && issue map [ _token ] . end time >= now ) ; require ( issue map [ _token ] . cln raised < issue map [ _token ] . hardcap ) ; _ ; }
"
"function balance of ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( NUM_ ) ) ; return owner to nftoken count [ _owner ] ; }
"
"function update capital ( ) internal { if ( capital > NUM_ && capital timestamp < now && fee factor < two_128 ) { capital = mul ( capital , pow ( fee factor , now - capital timestamp ) ) ; } capital timestamp = now ; }
"
"function transfer from with custom reserving ( address _from , address _to , uint _total transfer , uint _custom reserving percentage ) public returns ( bool success ) { require ( _custom reserving percentage > min allowed reserving percentage && _custom reserving percentage < max allowed reserving percentage ) ; uint net transfer = _total transfer * ( NUM_ - _custom reserving percentage ) / NUM_ ; require ( balances [ _from ] >= _total transfer && ( _total transfer > net transfer ) ) ; if ( transfer from ( _from , _to , net transfer ) && ( _total transfer >= reserving step ) ) { process jackpot deposit ( _total transfer , net transfer , _from ) ; } return BOOL_ ; }
"
"function set rate ( uint256 _rate ) public only owner { require ( _rate > NUM_ ) ; rate = _rate ; }
"
"function is owner ( address _who ) public view returns ( bool ) { return owners [ _who ] ; }
"
"function run sweep stake ( ) external payable { require ( rounds index > NUM_ ) ; round data memory rd = rounds [ -- rounds index ] ; uint16 _participant number = rd . last participant ; uint8 _level = rd . level ; uint16 _min range = _participant number - ( max participants - NUM_ ) ; uint16 _max range = _participant number ; address [ ] memory query participants = new address [ ] ( NUM_ ) ; uint8 k = NUM_ ; uint16 i = NUM_ ; if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth001 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth01 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth1 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth10 [ i ] ; k ++ ; } } delete rounds [ rounds index ] ; oraclize_set proof ( proof type_ledger ) ; uint n = NUM_ ; uint delay = NUM_ ; uint callback gas = NUM_ ; bytes32 query id = oraclize_new random dsquery ( delay , n , callback gas ) ; queries [ query id ] = query data ( query participants , _level ) ; if ( queries to delete index > NUM_ ) { delete queries [ queries to delete [ -- queries to delete index ] ] ; delete queries to delete [ queries to delete index ] ; } }
"
"function ascend list ( data storage self , uint256 _key , address _start id ) private view returns ( address , address ) { if ( self . tail == _start id && _key <= self . nodes [ _start id ] . key ) { return ( _start id , address ( NUM_ ) ) ; } address next id = _start id ; address prev id = self . nodes [ next id ] . prev id ; while ( next id != address ( NUM_ ) && ! valid insert position ( self , _key , prev id , next id ) ) { next id = self . nodes [ next id ] . prev id ; prev id = self . nodes [ next id ] . prev id ; } return ( prev id , next id ) ; }
"
"function bid ( ) external payable { require ( block . number < _auction end ) ; uint proposed bid = _bidders [ msg . sender ] . value . add ( msg . value ) ; require ( proposed bid > _lowest bid ) ; uint start pos = NUM_ ; if ( _bidders [ msg . sender ] . value >= _lowest bid ) { for ( uint i = NUM_ ; i < NUM_ ; -- i ) { if ( _top bids [ i ] . bidder address == msg . sender ) { start pos = i ; break ; } } } uint end pos ; for ( uint j = start pos ; j < NUM_ ; -- j ) { if ( j != NUM_ && proposed bid > _top bids [ j - NUM_ ] . bid ) { _top bids [ j ] = _top bids [ j - NUM_ ] ; } else { _top bids [ j ] . bid = proposed bid ; _top bids [ j ] . bidder address = msg . sender ; end pos = j ; break ; } } _bidders [
"
"function transfer bounty tokens ( address _to , uint256 _amount ) public only owner { require ( bounty supply >= _amount ) ; balances [ owner ] -= _amount ; balances [ _to ] += _amount ; bounty supply -= _amount ; total tokens remind -= _amount ; }
"
"function set region image data cloud ( uint _start_section_index , uint _end_section_index , uint _image_id , string _md5 ) { if ( _end_section_index < _start_section_index ) throw ; var ( start_x , start_y ) = get identifier from section index ( _start_section_index ) ; var ( end_x , end_y ) = get identifier from section index ( _end_section_index ) ; if ( start_x >= map width ) throw ; if ( start_y >= map height ) throw ; if ( end_x >= map width ) throw ; if ( end_y >= map height ) throw ; uint y_pos = start_y ; while ( y_pos <= end_y ) { uint x_pos = start_x ; while ( x_pos <= end_x ) { uint identifier = ( x_pos + ( y_pos * NUM_ ) ) ; section s = sections [ identifier ] ; if ( s . owner == msg . sender ) { s . image_id = _image_id ; s . md5 = _md5 ; } x_pos = x_pos + NUM_ ; } y_pos = y_pos + NUM_ ; } new image ( _start_section_index ) ; return ; }
"
"function create illiquid token ( address _recipient , uint _value ) when_mintable only_minter returns ( bool o_success ) { illiquid balance_index [ illiquid balance_amount ] = _recipient ; illiquid balance [ _recipient ] += _value ; illiquid balance_amount ++ ; total supply += _value ; return BOOL_ ; }
"
"function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }
"
"modifier only blacklister ( ) { require ( msg . sender == blacklister ) ; _ ; }
"
"function drain token ( address _token , address _to ) only owner { if ( _token == address ( NUM_ ) ) throw ; if ( _to == address ( NUM_ ) ) throw ; erc20 token = erc20 ( _token ) ; uint256 balance = token . balance of ( this ) ; token . transfer ( _to , balance ) ; token drain ( _token , _to , balance ) ; }
"
"function decrement balance ( address _address , uint _amount ) internal { balances [ _address ] = balances [ _address ] . sub ( _amount ) ; }
"
"function unpause tokens ( ) public only owner { pre catoken ( token ) . unpause ( ) ; }
"
"function get astro idxs by page ( uint last index , uint count , astro type expected type ) constant external returns ( uint [ ] idx , uint idx len ) { if ( expected type == astro type . placeholder || expected type == astro type . dismissed ) { return ; } astro [ ] storage astro pool = _get astro pool by type ( expected type ) ; if ( last index == NUM_ || astro pool . length == NUM_ || last index > astro pool . length ) { return ; } uint [ ] memory result = new uint [ ] ( count ) ; uint start = last index - NUM_ ; uint i = NUM_ ; for ( uint cursor = start ; cursor >= NUM_ && i < count ; -- cursor ) { var astro = astro pool [ cursor ] ; if ( _is valid astro ( _get astro type by code ( astro . code ) ) ) { result [ i ++ ] = cursor ; } if ( cursor == NUM_ ) { break ; } } uint [ ] memory final r = new
"
"function buy tokens ( ) public payable { require ( valid purchase ( ) ) ; wei amount = NUM_ ; tok = NUM_ ; wei amount = msg . value ; tok = div ( mul ( wei amount , fetch rate ( ) ) , pow ( NUM_ , NUM_ ) ) ; wei raised = add ( wei raised , wei amount ) ; token left = sub ( token left , tok ) ; token . transfer ico ( msg . sender , tok ) ; token purchase ( msg . sender , msg . sender , wei amount , tok ) ; forward funds ( ) ; }
"
"function admin buy for someone ( uint16 _city id , address _owner ) public { require ( msg . sender == united nations ) ; city memory fetched city = cities [ _city id ] ; require ( fetched city . buyable == BOOL_ ) ; require ( fetched city . owner == NUM_ ) ; cities [ _city id ] . owner = _owner ; cities [ _city id ] . buyable = BOOL_ ; cities [ _city id ] . last_purchase_price = fetched city . price ; uint16 [ ] memory fetched cities = countries [ fetched city . country id ] . cities ; uint256 per city boost = economy_boost / fetched cities . length ; for ( uint16 ii = NUM_ ; ii < fetched cities . length ; ii ++ ) { address _to = cities [ fetched cities [ ii ] ] . owner ; if ( _to != NUM_ ) { balances [ _to ] = balances [ _to ] . add ( per city boost ) ; total supply_ += per city boost ; } } city sold ( _city id , fetched city . price , NUM_ , _owner , NUM_
"
"function add investor ( address investor , uint256 _amount , uint256 hour ) public only owner { require ( investor != NUM_ ) ; require ( _amount > NUM_ ) ; uint256 amount = _amount * ( NUM_ * * token . decimals ( ) ) ; if ( balances [ investor ] . length == NUM_ ) { investor count ++ ; } balances [ investor ] . push ( balance ( investor , amount , now + hour * NUM_ * NUM_ , BOOL_ ) ) ; tokens allocated total += amount ; tokens at least hold += amount ; require ( token . balance of ( address ( this ) ) >= tokens at least hold ) ; invested ( investor , amount , hour ) ; }
"
"function token units ( ) external view returns ( uint256 [ ] ) { uint256 [ ] memory token units = new uint256 [ ] ( tokens . length ) ; for ( uint8 i = NUM_ ; i < tokens . length ; i ++ ) { token units [ i ] = tokens [ i ] . token units ; } return token units ; }
"
"function get bounding box ( uint256 _token id ) public view returns ( uint , uint , uint , uint , uint , uint ) { require ( exists ( _token id ) ) ; return ( bounding boxes [ _token id ] . x1 , bounding boxes [ _token id ] . y1 , bounding boxes [ _token id ] . z1 , bounding boxes [ _token id ] . x2 , bounding boxes [ _token id ] . y2 , bounding boxes [ _token id ] . z2 ) ; }
"
"function sell_label ( address buyer , uint amount_paid ) { sell ens sell_ens = sell ens ( msg . sender ) ; if ( get_info [ sell_ens ] . owner == NUM_ ) throw ; string label = get_info [ sell_ens ] . label ; uint price = get_info [ sell_ens ] . price ; address owner = get_info [ sell_ens ] . owner ; bytes32 label_hash = sha3 ( label ) ; deed deed ; ( , deed , , , ) = registrar . entries ( label_hash ) ; if ( deed . previous owner ( ) != owner ) throw ; bytes32 node = sha3 ( root_node , label_hash ) ; ens . set resolver ( node , resolver ) ; resolver . set addr ( node , buyer ) ; registrar . transfer ( label_hash , buyer ) ; uint fee = price / NUM_ ; if ( buyer == owner ) { price = NUM_ ; fee = NUM_ ; } developer . transfer ( fee ) ; owner . transfer ( price - fee ) ; if ( amount_paid > price ) { buyer . transfer ( amount_paid - price ) ; } label
"
"function validate ( address _student , uint _doc indx , bytes32 _content hash , bytes _ipfs hash , bytes32 _transcript hash ) public view returns ( bool ) { certification storage certification = student certifications [ _student ] ; return ( certification . documents [ _doc indx ] ) . validate ( _ipfs hash , _content hash , _transcript hash ) ; }
"
"function motion confirming ( uint motion id ) public view returns ( bool ) { uint start time = motion start time [ motion id ] ; return start time + voting period <= now && now < start time + voting period + confirmation period ; }
"
"function date move ( uint _shift ) private returns ( bool ) { require ( _shift > NUM_ ) ; uint i ; if ( paused by value ) { stages [ period ] . start = now ; stages [ period ] . stop = ( stages [ period ] . start ) . add ( stages [ period ] . duration ) ; for ( i = period + NUM_ ; i < NUM_ ; i ++ ) { stages [ i ] . start = stages [ i - NUM_ ] . stop ; stages [ i ] . stop = ( stages [ i ] . start ) . add ( stages [ i ] . duration ) ; } } else { if ( manual pause ) stages [ period ] . stop = ( stages [ period ] . stop ) . add ( _shift ) ; for ( i = period + NUM_ ; i < NUM_ ; i ++ ) { stages [ i ] . start = ( stages [ i ] . start ) . add ( _shift ) ; stages [ i ] . stop = ( stages [
"
"function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { require ( _beneficiary != address ( NUM_ ) ) ; super . _update purchasing state ( _beneficiary , _wei amount ) ; uint256 purchased tokens = _get token amount ( _wei amount ) ; tokens raised = tokens raised . add ( purchased tokens ) ; if ( cap reached ( ) ) { emit cap overflow ( _beneficiary , _wei amount , purchased tokens , now ) ; } }
"
"function transfer ( address _to , uint _value ) only payload size ( NUM_ * NUM_ ) public only unlocked returns ( bool ) { if ( _value > NUM_ && ! ( _to == address ( NUM_ ) ) ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function append decrypted bid ( uint _nonce , uint _index , uint _bid_id , address _investor_address , uint _share_price , uint _shares_count , uint _transfered_token ) only owner public { require ( status == state . ended ) ; require ( fundraise_defined ) ; require ( bids [ _index ] . exist == BOOL_ ) ; require ( bids [ _index ] . is_decrypted == BOOL_ ) ; require ( bids [ _index ] . is_burned == BOOL_ ) ; require ( _share_price > NUM_ ) ; require ( _shares_count > NUM_ ) ; require ( _transfered_token >= convert_valuation_to_art ( _shares_count . mul ( _share_price ) , bids [ _index ] . art_price ) ) ; if ( bids_sorted_count > NUM_ ) { bid data memory previous_bid_data = bids_sorted [ bids_sorted_count - NUM_ ] ; require ( _share_price <= previous_bid_data . share_price ) ; if ( _share_price == previous_bid_data . share_price ) { require ( _index > previous_bid_data . origin_index ) ; } } require ( get bid hash ( _nonce , _bid_id , _investor_address , _share_price , _shares_count ) == bids [ _index ] . bid_hash ) ; uint _transfer_amount = _share_price . mul ( _shares_count ) ; bid
"
"function new promotion ( string _name , string _msg , string _url , uint _each amt , uint _max num , uint _block start , uint _block last ) when not paused payable returns ( uint ) { require ( _each amt > min reward ) ; uint256 input amt = _each amt * _max num ; require ( input amt <= msg . value ) ; require ( manager . send ( safe div ( safe mul ( msg . value , promotion commision percent ) , NUM_ ) ) ) ; uint deposit = safe div ( safe mul ( msg . value , NUM_ - promotion commision percent ) , NUM_ ) ; promotion memory _promotion = promotion ( { id : all promotions . length , host : msg . sender , name : _name , msg : _msg , url : _url , each red pocket amt : safe div ( deposit , _max num ) , max red pocket num : _max num , claimed num : NUM_ , money pool : deposit , start block : _block start , block last : _block last , finished : BOOL_ } ) ; uint256 new
"
"function train special ( uint256 _kitty id , uint256 _special id , uint256 [ NUM_ ] _slots ) external payable is not contract { special personality storage special = special info [ _special id ] ; require ( msg . sender == core . owner of ( _kitty id ) ) ; require ( kitty data . fetch slot ( _kitty id , NUM_ ) > NUM_ ) ; require ( ! special kitties [ _kitty id ] ) ; require ( msg . value == special . price ) ; require ( special . amount left > NUM_ ) ; uint256 [ NUM_ ] memory random moves = randomize actions ( _special id ) ; assert ( kitty data . train special ( _kitty id , _special id , random moves , _slots ) ) ; assert ( kitty gym . add moves ( _kitty id , random moves ) ) ; uint256 special rank = special . population - special . amount left + NUM_ ; special trained ( _kitty id , _special id , special rank , random moves ) ; special . amount left -- ; special kitties [ _kitty id ] = BOOL_ ; owner
"
"function get total bonuses amount available ( bytes32 _user key ) public view returns ( uint _sum ) { uint _start date = _get calculation start date ( _user key ) ; treasury _treasury = treasury ( treasury ) ; for ( uint _end date = last deposit date ; _start date <= _end date && _start date != NUM_ ; _start date = distribution deposits [ _start date ] . next deposit date ) { deposit storage _pending deposit = distribution deposits [ _start date ] ; balance storage _user balance = _pending deposit . left to withdraw [ _user key ] ; if ( _user balance . initialized ) { _sum = _sum . add ( _user balance . left ) ; } else { uint _shares percent = _treasury . get shares percent for period ( _user key , _start date ) ; _sum = _sum . add ( _pending deposit . balance . mul ( _shares percent ) . div ( percent_precision ) ) ; } } }
"
"function transfer ( address _to , uint _value , bytes _data , string _custom_fallback ) public returns ( bool success ) { if ( is contract ( _to ) ) { require ( being edited [ _to ] != BOOL_ && being edited [ msg . sender ] != BOOL_ ) ; require ( balances [ msg . sender ] >= _value ) ; set edited true ( _to ) ; set edited true ( msg . sender ) ; balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe math . add ( balances [ _to ] , _value ) ; assert ( _to . call . value ( NUM_ ) ( bytes4 ( keccak256 ( _custom_fallback ) ) , msg . sender , _value , _data ) ) ; emit transfer ( msg . sender , _to , _value , _data ) ; set edited false ( _to ) ; set edited false ( msg . sender ) ; update addresses ( _to ) ; update addresses ( msg . sender ) ; return BOOL_ ; } else { return
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { if ( ( msg . sender != migration master ) && ( block . number < funding end block + oneweek ) ) throw ; var sender balance = balances [ msg . sender ] ; if ( sender balance >= _value && _value > NUM_ ) { sender balance -= _value ; balances [ msg . sender ] = sender balance ; balances [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } return BOOL_ ; }
"
"modifier only share manager { if ( token ) throw ; _ ; }
"
"function set fee ( uint _fee ) only_owner { fee = _fee ; }
"
"function add precommitment ( address _participant , uint256 _balance , uint256 _ethers ) only owner { require ( now < start_ts ) ; require ( _balance >= NUM_ ether ) ; uint additional_tokens = _balance / NUM_ * NUM_ ; balance of [ _participant ] = balance of [ _participant ] . add ( _balance ) ; balance of [ target_tokens_address ] = balance of [ target_tokens_address ] . add ( additional_tokens ) ; total supply = total supply . add ( _balance ) ; total supply = total supply . add ( additional_tokens ) ; total ethers = total ethers . add ( _ethers ) ; transfer ( NUM_ , _participant , _balance ) ; transfer ( NUM_ , target_tokens_address , additional_tokens ) ; }
"
"function get gift ( uint256 _gift id ) public constant returns ( uint256 gift type , uint256 gift price , string img url , string gift name ) { require ( _gift id < gift storage arry . length ) ; gift token memory g token = gift storage arry [ _gift id ] ; gift type = g token . gift type ; gift price = g token . gift price ; img url = g token . gift img url ; gift name = g token . gift name ; return ( gift type , gift price , img url , gift name ) ; }
"
"function set received token rate ( erc20 _token address , uint256 _new token rate ) only owner external { require ( _token address != address ( NUM_ ) ) ; require ( received tokens [ _token address ] . rate > NUM_ ) ; require ( _new token rate > NUM_ ) ; received tokens [ _token address ] . rate = _new token rate ; emit set received token rate ( _token address , _new token rate ) ; }
"
"function house keep ( int _max , uint _arb token ) public { uint gi ; address a ; int aborted = NUM_ ; arbiter xarb = arbiters [ msg . sender ] ; if ( msg . sender == owner ) { for ( uint ar = NUM_ ; ( ar < num arbiters ) && ( aborted < _max ) ; ar ++ ) { a = arbiter indexes [ ar ] ; xarb = arbiters [ a ] ; for ( gi = NUM_ ; ( gi < xarb . game slots ) && ( aborted < _max ) ; gi ++ ) { game instance ngame0 = games [ xarb . game indexes [ gi ] ] ; if ( ( ngame0 . active ) && ( ( now - ngame0 . last moved ) > game time out ) ) { abort game ( xarb . game indexes [ gi ] , end reason . er time out ) ; ++ aborted ; } } } } else { if ( ! valid arb ( msg . sender , _arb token ) ) stat event ( STR_ ) ; else { a = msg .
"
"function add cert admin ( address _cert admin ) public only global admin { cert admins [ _cert admin ] = BOOL_ ; cert admin added ( _cert admin ) ; }
"
"function make swap internal ( ) private is not paused { require ( stage > NUM_ && stage < NUM_ && msg . value >= min accepted eth ) ; whitelist wl = whitelist ( whitelist add ) ; if ( stage == NUM_ || stage == NUM_ ) require ( wl . registered ( msg . sender ) ) ; erc223 gxvctoken = erc223 ( token add ) ; address _address = msg . sender ; uint _value = msg . value ; uint _price = get price ( ) ; uint tokens to send = _price * _value / NUM_ * * NUM_ ; received from [ _address ] += _value ; total received += _value ; sent to [ _address ] += tokens to send ; total sent += tokens to send ; require ( gxvctoken . transfer from ( token spender , _address , tokens to send ) ) ; tokens sent ( _address , _value , tokens to send ) ; require ( collector address . send ( _value ) ) ; }
"
"function multi transfer ( address [ ] _addresses , uint256 [ ] _amounts ) public returns ( bool ) { uint256 total amount = NUM_ ; for ( uint j = NUM_ ; j < _addresses . length ; j ++ ) { total amount = total amount . add ( _amounts [ j ] ) ; } require ( balances [ msg . sender ] >= total amount ) ; for ( j = NUM_ ; j < _addresses . length ; j ++ ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amounts [ j ] ) ; balances [ _addresses [ j ] ] = balances [ _addresses [ j ] ] . add ( _amounts [ j ] ) ; emit transfer ( msg . sender , _addresses [ j ] , _amounts [ j ] ) ; } return BOOL_ ; }
"
"function get remaining tokens ( ) public constant returns ( uint256 ) { return balance of ( owner ) ; }
"
"function suicide ( ) only owner returns ( bool ) { selfdestruct ( owner ) ; return BOOL_ ; }
"
"function validate authentication ( address _sender , uint _challenge , uint _partner id ) public constant returns ( bool _is valid ) { if ( partner map [ _partner id ] [ _sender ] . value == hydro partner map [ _partner id ] [ _sender ] . value && block . timestamp < hydro partner map [ _partner id ] [ _sender ] . timestamp && partner map [ _partner id ] [ _sender ] . challenge == _challenge ) { return BOOL_ ; } return BOOL_ ; }
"
"function deposit ( ) public payable { balances [ msg . sender ] = balances [ msg . sender ] . add ( msg . value ) ; total tokens = total tokens . add ( msg . value ) ; deposit ( msg . sender , msg . value ) ; }
"
"function set crowdsale address ( address new crowdsale address ) public only owner { require ( new crowdsale address != address ( NUM_ ) ) ; crowdsale address = new crowdsale address ; }
"
"function send bounty ( address _to , uint256 _value ) only owner ( ) { bounty = safe sub ( bounty , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; tokens sent ( _to , _value ) ; transfer ( owner , _to , _value ) ; }
"
"function withdraw token ( uint256 _value ) only owner returns ( bool ok ) { return erc20 ( token ) . transfer ( owner , _value ) ; log withdrawal ( _value ) ; }
"
"function get cat ( uint cat index ) payable { require ( ! all cats assigned ) ; require ( cats remaining to assign != NUM_ ) ; require ( cat index to address [ cat index ] == NUM_ ) ; require ( cat index < _total supply ) ; require ( cat index < current release ceiling ) ; require ( get cat price ( cat index ) <= msg . value ) ; cat index to address [ cat index ] = msg . sender ; balance of [ msg . sender ] ++ ; cats remaining to assign -- ; pending withdrawals [ owner ] += msg . value ; assign ( msg . sender , cat index ) ; }
"
"function finish competition ( uint32 competition_id ) public not while paused ( ) only owner ( ) { competition score types . competition score [ ] memory scores ; mission parameters types . mission parameters memory parameters ; ( scores , parameters ) = make and sort competition scores ( competition_id ) ; require ( parameters . m_is started == NUM_ ) ; parameters . m_is started = NUM_ ; uint256 original_competition_funds = uint256 ( m_database . load ( null address , competition funds category , competition_id ) ) ; uint256 competition_funds_remaining = original_competition_funds ; for ( uint256 i = NUM_ ; i < parameters . m_valid competition scores ; i ++ ) { rocket types . rocket memory rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , scores [ i ] . m_rocket id ) ) ; rocket types . stock rocket storage stock_rocket = m_initial rockets [ rocket . m_stock id ] ; rocket . m_top speed = uint32 ( lerp extra ( stock_rocket . m_min top speed , stock_rocket . m_max top speed , rocket . m_top speed , bytes1 ( NUM_ - i ) ) ) ;
"
"modifier deposit phase { require ( get phase ( ) == state phases . deposit ) ; _ ; }
"
"function buy gan token ( uint256 id ) public payable { offer memory offer = gan token offered for sale [ id ] ; require ( offer . is for sale ) ; require ( offer . only sell to == msg . sender && offer . only sell to != NUM_ ) ; require ( msg . value == offer . value ) ; require ( token id to owner [ id ] == offer . seller ) ; safe transfer from ( offer . seller , offer . only sell to , id ) ; gan token offered for sale [ id ] = offer ( BOOL_ , id , offer . seller , NUM_ , NUM_ ) ; pending withdrawals [ offer . seller ] += msg . value ; }
"
"function new tap proposal from token holders ( uint256 _target wei ) only token holders in withdraw state public { require ( msg . sender != owner ) ; require ( msg . sender != team wallet ) ; try finialize last proposal ( ) ; require ( state == state . team withdraw ) ; require ( ! is next budget plan made ( ) ) ; require ( ! is there an on going proposal ( ) ) ; budget plan storage b = budget plans [ current budget plan id ] ; require ( now <= b . offical voting time && now >= b . start time ) ; require ( ! _has proposed ( msg . sender , proposal type . tap ) ) ; _new tap proposal ( proposal type . tap , _target wei ) ; }
"
"function proportion ( uint256 amount , uint256 part , uint256 total ) internal constant returns ( uint256 ) { return div round ( mul ( amount , part ) , total ) ; }
"
"function _transfer ( address from , address to , uint id ) internal { approved [ id ] = address ( NUM_ ) ; owners [ id ] = to ; _add token ( to , id ) ; _remove token ( from , id ) ; emit transfer ( from , to , id ) ; }
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value > NUM_ ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function set token price ( uint _token price ) external { require ( msg . sender == owner || msg . sender == minter ) ; sell price = _token price ; price changed ( STR_ , _token price ) ; }
"
"function give birth ( uint256 _matron id ) external when not paused returns ( uint256 ) { monster storage matron = monsters [ _matron id ] ; require ( _owns ( msg . sender , _matron id ) ) ; require ( matron . birth time != NUM_ ) ; require ( _is ready to give birth ( matron ) ) ; uint256 sire id = matron . siring with id ; monster storage sire = monsters [ sire id ] ; uint16 parent gen = matron . generation ; if ( sire . generation > matron . generation ) { parent gen = sire . generation ; } uint256 child genes = gene science . mix genes ( matron . genes , sire . genes , matron . cooldown end block - NUM_ ) ; address owner = monster index to owner [ _matron id ] ; uint256 monster id = _create monster ( _matron id , matron . siring with id , parent gen + NUM_ , child genes , owner ) ; delete matron . siring with id ; pregnant monsters -- ; msg . sender . send ( auto birth fee ) ; return monster id
"
"function withdraw dth shop ( address _receiver ) external only owner { require ( dth shop balance [ _receiver ] > NUM_ ) ; uint tosend = dth shop balance [ _receiver ] ; dth shop balance [ _receiver ] = NUM_ ; require ( dth . transfer ( _receiver , tosend ) ) ; }
"
"function add segmentation ( address _addr , uint256 _times , uint256 _period , uint256 _tokens ) only owner external returns ( bool ) { uint256 amount = userbalances segmentation [ _addr ] [ _times ] [ _period ] ; if ( amount != NUM_ && _tokens != NUM_ ) { uint256 _value = format decimals ( _tokens ) ; userbalances segmentation [ _addr ] [ _times ] [ _period ] = safe add ( amount , _value ) ; userbalances [ _addr ] [ _times ] = safe add ( userbalances [ _addr ] [ _times ] , _value ) ; totalbalances [ _addr ] = safe add ( totalbalances [ _addr ] , _value ) ; tokensub ( eth fund deposit , _value ) ; token issue ( _addr , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function ico tokens ( uint256 wei amount , uint256 tokens , uint256 access time ) internal returns ( uint256 ) { require ( ico supply > NUM_ ) ; if ( ! upgrade icosupply ) { ico supply = safe math . add ( ico supply , pre icosupply ) ; upgrade icosupply = BOOL_ ; } if ( access time <= week one ) { tokens = safe math . add ( tokens , wei amount . mul ( first week bonus ) ) ; } else if ( access time <= week two ) { tokens = safe math . add ( tokens , wei amount . mul ( second week bonus ) ) ; } else if ( access time < week three ) { tokens = safe math . add ( tokens , wei amount . mul ( third week bonus ) ) ; } tokens = safe math . add ( tokens , wei amount . mul ( rate ) ) ; ico supply = ico supply . sub ( tokens ) ; return tokens ; }
"
"function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]
"
"function sell ( uint256 _value ) public only owner returns ( bool ) { require ( ico contract != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] && balances [ ico contract ] + _value >= balances [ ico contract ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ ico contract ] = balances [ ico contract ] . add ( _value ) ; emit sell ( msg . sender , _value ) ; return BOOL_ ; }
"
"function transfer ( address _to , uint256 _value ) public can transfer returns ( bool ) { return super . transfer ( _to , _value ) ; }
"
"function set crowdsale ( crowdsale _crowdsale ) public only owner { crowdsale = _crowdsale ; if ( ! crowdsale . is crowdsale ( ) ) BOOL_ ; }
"
"function change vanity url ( string _vanity_url ) when not paused public { require ( bytes ( address_vanity_mapping [ msg . sender ] ) . length != NUM_ ) ; _vanity_url = _to lower ( _vanity_url ) ; require ( check for validity ( _vanity_url ) ) ; require ( vanity_address_mapping [ _vanity_url ] == address ( NUM_ ) ) ; vanity_address_mapping [ _vanity_url ] = msg . sender ; address_vanity_mapping [ msg . sender ] = _vanity_url ; vanity reserved ( msg . sender , _vanity_url ) ; }
"
"function remaining epxsupply ( ) public view returns ( uint256 remaining epxtoken count ) { return safe div ( tokens remaining , NUM_ ) ; }
"
"function _address not null ( address target ) private pure returns ( bool ) { return target != address ( NUM_ ) ; }
"
"function delete account ( address _monetha user ) external only owner { require ( storage contract . delete user claim ( _monetha user ) ) ; }
"
"function remove valid contract ( address _address ) admin only { if ( allowed contracts [ _address ] == NUM_ ) throw ; allowed contracts [ _address ] = NUM_ ; valid contract removed ( msg . sender , _address , now ) ; }
"
"function refund ( address _addr ) external returns ( bool ) { require ( ! ignited && ! finalized ) ; require ( msg . sender == distributor ) ; require ( _addr != address ( NUM_ ) ) ; if ( buyers [ _addr ] == NUM_ ) return BOOL_ ; uint256 refund amount = buyers [ _addr ] ; buyers [ _addr ] = NUM_ ; _addr . transfer ( refund amount ) ; emit refund ( _addr , refund amount ) ; return BOOL_ ; }
"
"function get purchaser address count ( ) public constant returns ( uint ) { return purchaser addresses . length ; }
"
"function transfer ( address _to , uint256 _value , bytes _data , string _custom_callback_unimplemented ) public returns ( bool ) { uint128 short value ; require ( _to != owner ) ; require ( msg . sender != owner ) ; short value = uint128 ( _value ) ; require ( uint ( short value ) == _value ) ; require ( token account index [ msg . sender ] . released balance >= short value ) ; token account index [ msg . sender ] . released balance -= short value ; token account index [ _to ] . released balance += short value ; if ( is contract ( _to ) ) { erc223 receiver receiver = erc223 receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; } emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }
"
"function bid ( uint wad ) public returns ( uint ) { return rmul ( wad , wmul ( s2s ( ) , sub ( NUM_ * wad , gap ) ) ) ; }
"
"function set carrots multiplier ( uint8 new carrots multiplier ) external only owner ( ) { carrots multiplier = new carrots multiplier ; }
"
"function continue distribution ( uint max numbe of steps ) public returns ( bool ) { require ( token status == token status . distributing ) ; if ( continue redeeming ( max numbe of steps ) ) { continue distribution ( BOOL_ ) ; return BOOL_ ; } uint token reward = dist ctx . total reward amount . div ( total supply of tokens ) ; rewards . push ( token reward ) ; uint paid reward = token reward . mul ( total supply of tokens ) ; uint unused distribution amount = dist ctx . total reward amount . sub ( paid reward ) ; if ( unused distribution amount > NUM_ ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , lib holdings . holding ( { total tokens : NUM_ , locked tokens : NUM_ , last reward number : rewards . length . sub ( NUM_ ) , wei balance : unused distribution amount } ) ) ; } else { lib holdings . holding storage owner holding = holdings . get ( owner ) ; owner holding . wei balance = owner holding
"
"function get board by hash ( bytes32 board hash ) constant public returns ( bytes32 , string , uint ) { return ( boards [ board hash ] . board name , boards [ board hash ] . board description , boards [ board hash ] . num players ) ; }
"
"function get entitled funds ( ) constant returns ( uint ) { if ( now < start time ) { return NUM_ ; } uint entitled amount = payment amount ; uint end time = is terminated ? termination time : now ; uint runtime = end time . sub ( start time ) ; uint complete intervals = runtime . div ( payment interval ) ; entitled amount = entitled amount . add ( complete intervals . mul ( payment amount ) ) ; return entitled amount . sub ( claimed funds ) ; }
"
"function freeze for owner ( uint256 _value , uint256 _un frozen time ) only operator returns ( bool ) { require ( balances [ owner ] >= _value ) ; require ( _un frozen time > create time ) ; require ( _un frozen time > now ) ; if ( _un frozen time . parse timestamp ( ) . year - create time . parse timestamp ( ) . year > NUM_ ) { balances [ owner ] = balances [ owner ] . sub ( _value ) ; frozen forever = frozen forever . add ( _value ) ; freeze for owner ( owner , _value , _un frozen time ) ; } else { uint256 day = _un frozen time . to day ( ) ; if ( frozen balances [ day ] . day == day ) { revert ( ) ; } balances [ owner ] = balances [ owner ] . sub ( _value ) ; frozen annually = frozen annually . add ( _value ) ; frozen balances [ day ] = frozen record ( _value , day ) ; freeze for owner ( owner , _value , _un frozen time ) ;
"
"function clone proposal ( uint _amount , string _description , bytes32 _hash of the document , uint _date of proposal , uint _order amount , uint _date of order , bool _clone order ) returns ( bool success ) { if ( smart contract start date != NUM_ || recipient == NUM_ || msg . sender != creator ) throw ; uint _proposal id = proposals . length ++ ; proposal c = proposals [ _proposal id ] ; c . amount = _amount ; c . description = _description ; c . hash of the document = _hash of the document ; c . date of proposal = _date of proposal ; c . order amount = _order amount ; c . date of last order = _date of order ; proposal added ( msg . sender , _proposal id , _amount , _description , _hash of the document ) ; if ( _clone order ) pass project . clone order ( address ( this ) , _proposal id , _order amount , _date of order ) ; return BOOL_ ; }
"
"function calculate total withdrawable amount ( address who ) public constant only existing ( who ) returns ( uint256 ) { uint256 balance sum = this . balance . add ( total withdrawn ) ; balance sum = balance sum . sub ( shared expense ) ; balance sum = balance sum . add ( shared expense withdrawn ) ; uint256 eth per share ppn = balance sum . percent ( total shares , precision ) ; uint256 eth ppn = eth per share ppn . mul ( members [ who ] . shares ) ; uint256 eth val = eth ppn . div ( NUM_ * * precision ) ; return eth val ; }
"
"function is active ( ) public view returns ( bool ) { return block . number >= start block && block . number <= end block ; }
"
"function change amount price ( uint256 _new price ) public only owner { amount to create = _new price ; }
"
"function annual interest ( ) public returns ( uint interest ) { uint _now = now ; interest = max mint proof of stake ; if ( ( _now . sub ( stake start time ) ) . div ( NUM_ years ) == NUM_ ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; } else if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; } else if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years )
"
"function transfer ( address to , uint potatoes ) public returns ( bool success ) { harvest ( msg . sender ) ; if ( cellars [ msg . sender ] < potatoes ) { return BOOL_ ; } recycle ( to ) ; cellars [ msg . sender ] -= potatoes ; cellars [ to ] += potatoes ; transfer ( msg . sender , to , potatoes ) ; return BOOL_ ; }
"
"function has asset rights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holder id = get holder id ( _owner ) ; return is created ( _symbol ) && ( assets [ _symbol ] . owner == holder id || assets [ _symbol ] . partowners [ holder id ] ) ; }
"
"function create hkg ( address holder ) payable { if ( now < milestones . p1 ) throw ; if ( now >= milestones . p6 ) throw ; if ( msg . value == NUM_ ) throw ; if ( get total value ( ) + msg . value > safety_limit ) throw ; uint tokens = msg . value * get price ( ) * decimal_zeros / NUM_ ether ; total supply var += tokens ; balances [ holder ] += tokens ; total value += msg . value ; if ( ! wallet . send ( msg . value ) ) throw ; }
"
"function create sale auction ( uint40 _cutie id , uint128 _start price , uint128 _end price , uint40 _duration ) public when not paused payable { require ( _is owner ( msg . sender , _cutie id ) ) ; _approve ( _cutie id , sale market ) ; sale market . create auction . value ( msg . value ) ( _cutie id , _start price , _end price , _duration , msg . sender ) ; }
"
"modifier not finished ( ) { require ( state != state . successful && state != state . paused ) ; _ ; }
"
"function get timebased bonus rate ( ) internal constant returns ( uint256 ) { uint256 bonus rate = NUM_ ; if ( stage == stage . presale ) { bonus rate = NUM_ ; } else { uint256 now time = get now ( ) ; uint256 bonus first week = start time + ( NUM_ days * NUM_ ) ; uint256 bonus second week = bonus first week + ( NUM_ days * NUM_ ) ; uint256 bonus third week = bonus second week + ( NUM_ days * NUM_ ) ; uint256 bonus fourth week = bonus third week + ( NUM_ days * NUM_ ) ; if ( now time <= bonus first week ) { bonus rate = NUM_ ; } else if ( now time <= bonus second week ) { bonus rate = NUM_ ; } else if ( now time <= bonus third week ) { bonus rate = NUM_ ; } else if ( now time <= bonus fourth week ) { bonus rate = NUM_ ; } } return bonus rate ; }
"
"function transfer from ( address from , address to , uint256 token amount ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( token amount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( token amount ) ; balances [ to ] = balances [ to ] . add ( token amount ) ; emit transfer ( from , to , token amount ) ; return BOOL_ ; }
"
"function init sub payees ( bytes32 _request id , address [ ] _payees , int256 [ ] _expected amounts ) internal { require ( _payees . length == _expected amounts . length ) ; for ( uint8 i = NUM_ ; i < _payees . length ; i = i . add ( NUM_ ) ) { require ( _payees [ i ] != NUM_ ) ; sub payees [ _request id ] [ i - NUM_ ] = payee ( _payees [ i ] , _expected amounts [ i ] , NUM_ ) ; new sub payee ( _request id , _payees [ i ] ) ; } }
"
"function kill ( ) { require ( msg . sender == owner ) ; suicide ( msg . sender ) ; }
"
"function _trim ( uint256 [ ] _layers , uint _size ) private pure returns ( uint256 [ ] ) { uint256 [ ] memory trimmed layers = new uint256 [ ] ( _size ) ; for ( uint i = NUM_ ; i < _size ; i ++ ) { trimmed layers [ i ] = _layers [ i ] ; } return trimmed layers ; }
"
"function set crowdsale address ( address _crowdsale ) public only owner { require ( _crowdsale != address ( NUM_ ) ) ; crowdsale = _crowdsale ; }
"
"function approve ( address _spender , uint256 _value ) public valid address ( _spender ) returns ( bool success ) { require ( _value == NUM_ || allowance [ msg . sender ] [ _spender ] == NUM_ ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }
"
"function end round ( pohmodatasets . event returns memory _event data_ ) private returns ( pohmodatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _po h = ( _pot . mul ( pot split_ [ _win tid ] . poh ) ) / NUM_ ; uint256 _res = ( ( _pot . sub ( _win ) ) . sub ( _gen ) ) . sub ( _po h ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen
"
"function init challenge period ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) private { bytes32 key = get key ( msg . sender , _receiver_address , _open_block_number ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; closing_requests [ key ] . closing_balance = _balance ; channel close requested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }
"
"function unlock ( ) external only owner { is locked = BOOL_ ; }
"
"function is sane ( ) public constant returns ( bool ) { return ( token . release agent ( ) == address ( this ) ) ; }
"
"function finalize ( ) only owner { if ( ( pre crowdsale start time == NUM_ || now < pre crowdsale end time ) && tokens sent != token_cap ) { throw ; } if ( ! pre crowdsale owner . send ( this . balance ) ) throw ; crowd sale is running = BOOL_ ; }
"
"function load balances ( uint256 [ ] data ) public not finalized only owner { for ( uint256 i = NUM_ ; i < data . length ; i ++ ) { address addr = address ( data [ i ] & ( d160 - NUM_ ) ) ; uint256 amount = data [ i ] / d160 ; balances [ addr ] = amount ; transfer ( NUM_ , addr , amount ) ; } }
"
"function set paused ( bool _paused ) public { require ( msg . sender == owner ) ; paused = _paused ; }
"
"function issue to ( address _to , uint256 _amount ) public only issuer when not paused returns ( bool ) { total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit mint ( _to , _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }
"
"function update counters ( uint256 _ether amount ) internal { ether paid = ether paid . add ( _ether amount ) ; total contributions = total contributions . add ( NUM_ ) ; counters updated ( ether paid , _ether amount ) ; }
"
"function _is winner of ( address race address , address eth_address ) internal view returns ( bool , bytes32 ) { ethorse race race = ethorse race ( race address ) ; if ( only legit ) require ( legit races [ race address ] , STR_ ) ; bool voided_bet ; bool race_end ; ( , , race_end , voided_bet , , , , ) = race . chronus ( ) ; if ( voided_bet || ! race_end ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; bytes32 horse ; bool found = BOOL_ ; uint256 array length = all_horses . length ; for ( uint256 i = NUM_ ; i < array length ; i ++ ) { if ( race . winner_horse ( all_horses [ i ] ) ) { horse = all_horses [ i ] ; found = BOOL_ ; break ; } } if ( ! found ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; uint256 bet_amount = NUM_ ; ( , , , , bet_amount ) = race . get coin index ( horse , eth_address ) ; return ( bet_amount > NUM_ , horse ) ; }
"
"function create vest fund for ( address beneficiary , uint256 amount , uint256 quarters , uint pool id ) external only owner only if in pool ( amount , pool id ) { require ( beneficiary != address ( NUM_ ) && amount != NUM_ ) ; require ( quarters > NUM_ ) ; vesting fund fund = new vesting fund ( beneficiary , end time , quarters , token ) ; token . mint ( fund , amount ) ; vested tokens for ( beneficiary , fund , amount ) ; }
"
"function refund crowdsale contributor ( ) external { require ( state == fund state . crowdsale refund ) ; require ( contributions [ msg . sender ] > NUM_ ) ; uint256 refund amount = contributions [ msg . sender ] ; contributions [ msg . sender ] = NUM_ ; token . destroy ( msg . sender , token . balance of ( msg . sender ) ) ; msg . sender . transfer ( refund amount ) ; refund contributor ( msg . sender , refund amount , now ) ; }
"
"function _inverse get token amount ( address _token address , uint256 _token amount ) internal view returns ( uint256 ) { uint256 _rate ; if ( _token address == address ( NUM_ ) ) { _rate = rate ; } else { _rate = received tokens [ _token address ] . rate ; } return _token amount . div ( _rate ) ; }
"
"function create tokens ( uint256 _value ) internal { require ( is finalized == BOOL_ ) ; require ( now >= funding start time ) ; require ( now < funding end time ) ; require ( msg . value > NUM_ ) ; uint256 tokens = _value . mul ( token exchange rate ) ; uint256 checked supply = _total supply . add ( tokens ) ; require ( checked supply <= token creation cap ) ; _total supply = checked supply ; balances [ msg . sender ] += tokens ; refunds [ msg . sender ] = _value . add ( refunds [ msg . sender ] ) ; create allstocks token ( msg . sender , tokens ) ; transfer ( address ( NUM_ ) , owner , _total supply ) ; }
"
"function claim tokens for user ( address _backer ) internal returns ( bool ) { require ( date icoended > NUM_ ) ; backer storage backer = backers [ _backer ] ; require ( ! backer . refunded ) ; require ( ! backer . claimed ) ; require ( backer . wei received one > NUM_ || backer . wei received two > NUM_ || backer . wei received main > NUM_ ) ; claim count ++ ; uint tokens to send = ( dollar per ether ratio * backer . wei received one ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received two ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received main ) / NUM_ ; claimed [ _backer ] = tokens to send ; backer . claimed = BOOL_ ; backer . tokens sent = tokens to send ; total claimed += tokens to send ; if ( ! token . transfer ( _backer , tokens to send ) ) revert ( ) ; tokens claimed ( _backer , tokens
"
"function token owner remove ( address _addr ) internal { uint256 token holder count = all token holders . length ; uint256 found index = NUM_ ; bool found = BOOL_ ; uint256 i ; for ( i = NUM_ ; i < token holder count ; i ++ ) if ( all token holders [ i ] == _addr ) { found index = i ; found = BOOL_ ; break ; } if ( ! found ) return ; for ( i = found index ; i < token holder count - NUM_ ; i ++ ) all token holders [ i ] = all token holders [ i + NUM_ ] ; all token holders . length -- ; }
"
"modifier only minter ( ) { require ( msg . sender == minter ) ; _ ; }
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { var sender balance = balances [ msg . sender ] ; if ( sender balance >= _value && _value > NUM_ ) { sender balance -= _value ; balances [ msg . sender ] = sender balance ; balances [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } return BOOL_ ; }
"
"function tokens to recieve ( uint256 _wei ) internal view returns ( uint256 tokens ) { return _wei . div ( rate ) ; }
"
"function get groups contributed to ( address user add ) external view returns ( uint256 [ ] group ids ) { require ( _address not null ( user add ) ) ; var contributor = user address to contributor [ user add ] ; require ( contributor . exists ) ; group ids = contributor . group arr ; }
"
"function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens
"
"function force pay ( uint _begin , uint _end ) public returns ( bool ) { if ( current_state == swap state . tokenized ) { calculate ( ) ; } require ( current_state == swap state . ready ) ; token = drct_token_interface ( long_token_address ) ; uint count = token . address count ( address ( this ) ) ; uint loop_count = count < _end ? count : _end ; for ( uint i = loop_count - NUM_ ; i >= _begin ; i -- ) { address long_owner = token . get holder by index ( i , address ( this ) ) ; uint to_pay_long = token . get balance by index ( i , address ( this ) ) ; pay swap ( long_owner , to_pay_long , BOOL_ ) ; } token = drct_token_interface ( short_token_address ) ; count = token . address count ( address ( this ) ) ; loop_count = count < _end ? count : _end ; for ( uint j = loop_count - NUM_ ; j >= _begin ; j -- ) { address short_owner = token . get holder by index ( j , address ( this )
"
"function setup open distribution ( uint256 _funding start block , uint256 _funding end block , address _token contract , address _budget wallet ) public only owner returns ( bytes32 response ) { if ( ( msg . sender == admin ) && ( ! ( is open distribution setup ) ) && ( ! ( budget wallet > NUM_ ) ) ) { token contract = standard token ( _token contract ) ; budget wallet = _budget wallet ; tokens per eth price = NUM_ ; funding cap = NUM_ ; amount raised = NUM_ ; initial supply = NUM_ ; tokens remaining = safe div ( initial supply , NUM_ ) ; funding start block = _funding start block ; funding end block = _funding end block ; is open distribution setup = BOOL_ ; is open distribution closed = BOOL_ ; current status = STR_ ; set price ( ) ; return STR_ ; } else if ( msg . sender != admin ) { return STR_ ; } else { return STR_ ; } }
"
"function release approve ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometric from [ sha ] ) ; require ( ! biometric completed [ sha ] ) ; bytes32 approve sha = keccak256 ( STR_ , biometric from [ sha ] , biometric to [ sha ] , biometric amount [ sha ] , biometric now [ sha ] ) ; bytes32 increase approval sha = keccak256 ( STR_ , biometric from [ sha ] , biometric to [ sha ] , biometric amount [ sha ] , biometric now [ sha ] ) ; bytes32 decrease approval sha = keccak256 ( STR_ , biometric from [ sha ] , biometric to [ sha ] , biometric amount [ sha ] , biometric now [ sha ] ) ; require ( approve sha == sha || increase approval sha == sha || decrease approval sha == sha ) ; require ( verify ( sha , v , r , s ) == BOOL_ ) ; super . approve ( biometric to [ sha ] , biometric amount [ sha ] ) ; biometric
"
"function reclaim token ( erc20 basic token ) external only owner { uint256 balance = token . balance of ( this ) ; token . safe transfer ( owner , balance ) ; }
"
"function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256
"
"function allocate ( address [ ] _beneficiaries , uint256 [ ] _amounts ) public only owner { for ( uint256 i = NUM_ ; i < _beneficiaries . length ; i ++ ) { require ( total allocated . add ( _amounts [ i ] ) <= cap ) ; token . safe transfer ( _beneficiaries [ i ] , _amounts [ i ] ) ; total allocated . add ( _amounts [ i ] ) ; } }
"
"modifier no value ( ) { if ( msg . value > NUM_ ) { _safe send ( msg . sender , msg . value ) ; } _ ; }
"
"function y2_release ( ) only owner public { require ( y1_locked token amount == NUM_ ) ; require ( y2_locked token amount > NUM_ ) ; require ( now > y2_locked token release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . transfer ( restricted , amount ) ; y2_locked token amount = NUM_ ; }
"
"function fund ( ) public timed transitions at stage or ( stages . going and goal not reached , stages . going and goal reached ) payable returns ( uint ) { uint token count = ( msg . value * ( NUM_ * * NUM_ ) ) / value per token ; require ( token count > NUM_ ) ; if ( tokens sent + token count > cap ) { token count = cap - tokens sent ; } tokens sent += token count ; uint contribution = ( token count * value per token ) / ( NUM_ * * NUM_ ) ; if ( msg . value > contribution && ! msg . sender . send ( msg . value - contribution ) ) { revert ( ) ; } fund balance += contribution ; contributions [ msg . sender ] += contribution ; sent tokens [ msg . sender ] += token count ; if ( ! singular dtvtoken . transfer ( msg . sender , token count ) ) { revert ( ) ; } if ( stage == stages . going and goal not reached ) { if ( tokens sent >= token_target
"
"function get ark data ( uint256 _token id ) external view returns ( address _owner , uint256 _price , uint256 _next price , uint256 _mate , address _birther , uint8 _gender , uint256 _baby , uint256 _baby price ) { animal memory animal = ark data [ _token id ] ; uint256 baby ; if ( animal . gender == NUM_ ) baby = babies [ _token id ] ; else baby = babies [ mates [ _token id ] ] ; return ( animal . owner , animal . price , get next price ( animal . price ) , mates [ _token id ] , animal . birther , animal . gender , baby , baby makin price [ baby ] ) ; }
"
"function allocate liquid ( address _who , uint _value ) only_admin when_allocatable_liquid ( _value ) public { tokens . mint ( _who , _value ) ; liquid allocatable -= _value ; allocated ( _who , _value , BOOL_ ) ; }
"
"function increase approval ( address _spender , uint _added value ) public when not paused returns ( bool success ) { return super . increase approval ( _spender , _added value ) ; }
"
"function set region image data cloud ( uint _start_section_index , uint _end_section_index , uint _image_id , string _md5 ) { if ( _end_section_index < _start_section_index ) throw ; var ( start_x , start_y ) = get identifier from section index ( _start_section_index ) ; var ( end_x , end_y ) = get identifier from section index ( _end_section_index ) ; if ( start_x >= map width ) throw ; if ( start_y >= map height ) throw ; if ( end_x >= map width ) throw ; if ( end_y >= map height ) throw ; uint y_pos = start_y ; while ( y_pos <= end_y ) { uint x_pos = start_x ; while ( x_pos <= end_x ) { uint identifier = ( x_pos + ( y_pos * NUM_ ) ) ; section s = sections [ identifier ] ; if ( s . owner == msg . sender ) { s . image_id = _image_id ; s . md5 = _md5 ; } x_pos = x_pos + NUM_ ; } y_pos = y_pos + NUM_ ; } new image ( _start_section_index ) ; return ; }
"
"function send funds ( ) public returns ( bool ) { require ( msg . sender == sister ) ; require ( msg . sender . send ( this . balance ) ) ; lost = BOOL_ ; return BOOL_ ; }
"
"function bid ( uint256 _token id ) external payable { auction storage auction = token id to auction [ _token id ] ; require ( auction . live ) ; require ( auction . end time > block . timestamp ) ; require ( msg . value > auction . highest bid ) ; if ( auction . highest bidder != NUM_ ) { pending returns [ auction . highest bidder ] += auction . highest bid ; } auction . highest bidder = msg . sender ; auction . highest bid = msg . value ; highest bid increased ( _token id , msg . sender , msg . value ) ; }
"
"function approve remove owner request ( ) public only owners { require ( owners count - NUM_ >= need approves to confirm && owners count > NUM_ ) ; require ( owners [ remove owners . new owner ] ) ; require ( ! remove owners . is execute && ! remove owners . is canceled ) ; require ( remove owners . creation timestamp + life time >= uint32 ( now ) ) ; for ( uint i = NUM_ ; i < remove owners . confirmators . length ; i ++ ) { require ( remove owners . confirmators [ i ] != msg . sender ) ; } remove owners . confirms ++ ; remove owners . confirmators . push ( msg . sender ) ; if ( remove owners . confirms >= need approves to confirm ) { remove owners . is execute = BOOL_ ; owners [ remove owners . new owner ] = BOOL_ ; owners count -- ; _remove owners aproves ( remove owners . new owner ) ; } emit remove owner request update ( msg . sender , remove owners . confirms , remove owners . is execute ) ; }
"
"function remove reserved tokens ( address _destination ) external view { contract . authorize ( msg . sender ) ; contract . checks ( only admin and not init ) ; manage tokens . remove reserved tokens ( _destination ) ; contract . checks ( only stores ) ; contract . commit ( ) ; }
"
"function rollback contract ( uint256 contract identifier , address to contract address ) public only owner only without lock ( contract identifier ) { require ( contract identifier != NUM_ && to contract address != NUM_ ) ; migration locks [ contract identifier ] = BOOL_ ; require ( contract identifier == versionable ( to contract address ) . identifier ( ) ) ; require ( ! activatable ( to contract address ) . active ( ) && exists managed contract ( contract identifier , to contract address ) ) ; address from contract address = active contracts [ contract identifier ] ; swap contracts states ( contract identifier , to contract address , from contract address ) ; migration locks [ contract identifier ] = BOOL_ ; rollbacked contract ( contract identifier , from contract address , to contract address ) ; }
"
"function bulk transfer ( address [ ] _tos , uint256 [ ] _values ) public when not paused not frozen if authorized ( msg . sender , bulktransfer ) returns ( bool ) { require ( _tos . length == _values . length ) ; uint256 source balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; for ( uint256 i = NUM_ ; i < _tos . length ; i ++ ) { uint256 current value = _values [ i ] ; address _to = _tos [ i ] ; require ( _to != address ( NUM_ ) ) ; require ( current value <= source balance ) ; require ( msg . sender != _to ) ; source balance = source balance . sub ( current value ) ; balances [ _to ] = balances [ _to ] . add ( current value ) ; track addresses ( _to ) ; emit transfer ( msg . sender , _tos [ i ] , current value ) ; } balances [ msg . sender ] = source balance ; emit bulk transfer ( msg . sender , _tos . length )
"
"function set ico status ( uint _numb ) external manager only { require ( status ico == status ico . pre ico finished || status ico == status ico . ico stage1 || status ico == status ico . ico stage2 || status ico == status ico . ico stage3 || status ico == status ico . ico stage4 ) ; require ( _numb == NUM_ || _numb == NUM_ || _numb == NUM_ || _numb == NUM_ || _numb == NUM_ ) ; status ico stat = status ico . ico stage1 ; if ( _numb == NUM_ ) { stat = status ico . ico stage2 ; } else if ( _numb == NUM_ ) { stat = status ico . ico stage3 ; } else if ( _numb == NUM_ ) { stat = status ico . ico stage4 ; } else if ( _numb == NUM_ ) { stat = status ico . ico stage5 ; } status ico = stat ; can ibuy = BOOL_ ; can iwithdraw = BOOL_ ; emit log start ico stage ( _numb ) ; }
"
"function multiple shot token repartition ( uint _dispute id , uint _max iterations ) public only during ( period . execution ) { dispute storage dispute = disputes [ _dispute id ] ; require ( dispute . state <= dispute state . resolving ) ; require ( dispute . session + dispute . appeals <= session ) ; dispute . state = dispute state . resolving ; uint winning choice = dispute . vote counter [ dispute . appeals ] . winning choice ; uint amount shift = get stake per draw ( ) ; uint current iterations = NUM_ ; for ( uint i = dispute . current appeal to repartition ; i <= dispute . appeals ; ++ i ) { if ( dispute . appeals repartitioned . length < i + NUM_ ) { dispute . appeals repartitioned . length ++ ; } if ( winning choice == NUM_ && ( dispute . vote counter [ dispute . appeals ] . vote count [ NUM_ ] != dispute . vote counter [ dispute . appeals ] . winning count ) ) { dispute . appeals repartitioned [ i ] . stage = repartition stage . at stake
"
"function wallet ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }
"
"function set main sale ( uint _ratio ) public only owner ( ) { require ( _ratio > NUM_ ) ; current step = step . funding main sale ; dollar per ether ratio = _ratio ; max cap tokens = NUM_ ; min investment = NUM_ ether / NUM_ ; total tokens sold = ( dollar per ether ratio * eth received presale one ) / NUM_ ; total tokens sold += ( dollar per ether ratio * eth received presale two ) / NUM_ ; }
"
"function create gift template ( uint256 _price , uint256 _limit , string _img url , string _gift name ) public only have permission returns ( uint256 gift template id ) { require ( _price > NUM_ ) ; bytes memory img url string test = bytes ( _img url ) ; bytes memory gift name string test = bytes ( _gift name ) ; require ( img url string test . length > NUM_ ) ; require ( gift name string test . length > NUM_ ) ; require ( _limit > NUM_ ) ; require ( msg . sender != address ( NUM_ ) ) ; gift template token memory new gift template = gift template token ( { gift price : _price , gift limit : _limit , gift img url : _img url , gift name : _gift name } ) ; gift template id = gift template storage arry . push ( new gift template ) - NUM_ ; gift type to gift limit [ gift template id ] = _limit ; return gift template id ; }
"
"function m destroy tokens ( address owner , uint256 amount ) internal { require ( parent token ( ) == address ( NUM_ ) || parent snapshot id ( ) < parent token ( ) . current snapshot id ( ) ) ; uint256 cur total supply = total supply ( ) ; require ( cur total supply >= amount ) ; uint256 previous balance from = balance of ( owner ) ; require ( previous balance from >= amount ) ; uint256 new total supply = cur total supply - amount ; uint256 new balance from = previous balance from - amount ; set value ( _total supply values , new total supply ) ; set value ( _balances [ owner ] , new balance from ) ; transfer ( owner , NUM_ , amount ) ; }
"
"function withdraw balance ( address _to , uint256 _amount ) public only ceo { require ( _amount <= this . balance ) ; if ( _amount == NUM_ ) { _amount = this . balance ; } if ( _to == address ( NUM_ ) ) { ceo address . transfer ( _amount ) ; } else { _to . transfer ( _amount ) ; } }
"
"function transfer back mana ( address _address , uint256 _amount ) only owner public { require ( _address != address ( NUM_ ) ) ; require ( _amount > NUM_ ) ; address return address = _address ; if ( return vesting != address ( NUM_ ) ) { address mapped address = return vesting . return address ( _address ) ; if ( mapped address != address ( NUM_ ) ) { return address = mapped address ; } } require ( token . transfer from ( terraform reserve , return address , _amount ) ) ; }
"
"function get price ( uint _tokens , uint _order price ) private pure returns ( uint ) { return safe math . div ( safe math . mul ( _tokens , _order price ) , price_mul ) ; }
"
"function extract address ( bytes _data , uint offset ) internal pure returns ( address m ) { require ( offset >= NUM_ && offset + NUM_ <= _data . length ) ; assembly { m : = and ( mload ( add ( _data , add ( NUM_ , offset ) ) ) , NUM_ ) } }
"
"function transfer ( address _to , uint256 _token id ) public { require ( ! jackpot completed ) ; require ( _owns ( msg . sender , _token id ) ) ; require ( _address not null ( _to ) ) ; _transfer ( msg . sender , _to , _token id ) ; }
"
"function set pixels ( uint32 _canvas id , uint32 [ ] _indexes , uint8 [ ] _colors ) external { require ( _indexes . length == _colors . length ) ; canvas storage _canvas = _get canvas ( _canvas id ) ; bool any set = BOOL_ ; for ( uint32 i = NUM_ ; i < _indexes . length ; i ++ ) { pixel storage _pixel = _canvas . pixels [ _indexes [ i ] ] ; if ( _pixel . painter == NUM_ ) { _set pixel internal ( _canvas , _canvas id , _indexes [ i ] , _colors [ i ] ) ; any set = BOOL_ ; } } if ( ! any set ) { revert ( ) ; } _finish canvas if needed ( _canvas , _canvas id ) ; }
"
"function get voters at ( uint _offset , uint _limit , uint _block number ) public constant returns ( address [ ] _voters , uint8 [ ] _candidates , uint [ ] _amounts ) { if ( _offset < voters . length ) { uint count = NUM_ ; uint result length = voters . length - _offset > _limit ? _limit : voters . length - _offset ; uint _block = _block number > end block ? end block : _block number ; _voters = new address [ ] ( result length ) ; _candidates = new uint8 [ ] ( result length ) ; _amounts = new uint [ ] ( result length ) ; for ( uint i = _offset ; ( i < voters . length ) && ( count < _limit ) ; i ++ ) { _voters [ count ] = voters [ i ] ; _candidates [ count ] = votes [ voters [ i ] ] ; _amounts [ count ] = msp . balance of at ( voters [ i ] , _block ) ; count ++ ; } return ( _voters , _candidates , _amounts ) ; } }
"
"function transfer admin ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; emit ownership transferred ( admin owner , new owner ) ; admin owner = new owner ; }
"
"function get last winner ( ) public view returns ( address ) { return last winner ; }
"
"function balance of ( address _address ) public constant returns ( uint256 balance ) { return balances [ _address ] ; }
"
"function set pending wallet fee ( address wallet , uint fee in bps ) public only operator { require ( wallet != address ( NUM_ ) ) ; require ( fee in bps > NUM_ ) ; wallet fee . w address = wallet ; wallet fee . fee bps = fee in bps ; set new data ( wallet_fee_index ) ; }
"
"function buy tokens ( ) public payable { address inv = msg . sender ; uint256 wei amount = msg . value ; require ( wei amount >= min purchase ) ; uint256 rate ; uint256 tokens ; uint256 clean wei ; uint256 change ; if ( now > pre ico start time && now < ( pre ico start time + NUM_ days ) ) { rate = pre ico rate ; } else if ( now > ico start time && now < ( ico start time + NUM_ days ) ) { rate = ico rate ; } require ( rate > NUM_ ) ; tokens = ( wei amount . mul ( NUM_ ) ) . div ( rate ) ; if ( tokens sold . add ( tokens ) > hard cap ) { tokens = hard cap . sub ( tokens sold ) ; clean wei = tokens . mul ( rate ) . div ( NUM_ ) ; change = wei amount . sub ( clean wei ) ; } else { clean wei = wei amount ; } if ( investors [ inv ] == NUM_ ) { investors array . push
"
"function create subscription offer ( uint _price per hour , uint16 _xrate provider id , uint _charge period , uint _expire on , uint _offer limit , uint _deposit amount , uint _start on , bytes _descriptor ) public no reentrancy ( l01 ) only registered provider not suspended returns ( uint sub id ) { assert ( _start on < _expire on ) ; assert ( _charge period <= NUM_ years ) ; var ( _xrate_n , _xrate_d ) = _xrate provider id == NUM_ ? ( NUM_ , NUM_ ) : xrate provider ( xrate providers [ _xrate provider id ] ) . get rate ( ) ; assert ( _xrate_n > NUM_ && _xrate_d > NUM_ ) ; subscriptions [ ++ subscription counter ] = subscription ( { transfer from : NUM_ , transfer to : msg . sender , price per hour : _price per hour , xrate provider id : _xrate provider id , initial xrate_n : _xrate_n , initial xrate_d : _xrate_d , paid until : NUM_ , charge period : _charge period , deposit amount : _deposit amount , start on : _start on , expire on : _expire on , exec counter
"
"function unpause ( ) external only manager only paused { paused = BOOL_ ; unpaused ( ) ; }
"
"function transfer adminship ( address new admin ) public only admin { admin = new admin ; }
"
"function buy ( address _address , uint _value , uint _time ) internal returns ( bool ) { uint tokens to send = token calculate ( _value , _time ) ; if ( is pre ico ( _time ) ) { require ( pre ico tokens sold . add ( tokens to send ) <= pre_ico_max_cap ) ; pre ico tokens sold = pre ico tokens sold . add ( tokens to send ) ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } else { contributor eth collected [ _address ] += _value ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } eth collected = eth collected . add ( _value ) ; tokens sold = tokens sold . add ( tokens to send ) ; emit on success buy ( _address , _value , tokens to send ) ; return BOOL_ ; }
"
"function proxy payment ( address _owner ) payable returns ( bool ) { do payment ( _owner ) ; return BOOL_ ; }
"
"function set authorized ( address _authorized ) only owner public { authorized = _authorized ; }
"
"function after sale minting ( uint _tokens ) public only admin { require ( has ended ( ) ) ; uint limit = max tokens . sub ( tokens of team and advisors ) ; require ( token raised . add ( _tokens ) <= limit ) ; token raised = token raised . add ( _tokens ) ; token . mint ( multi sig , _tokens ) ; token placed ( multi sig , _tokens ) ; }
"
"function bonus previous owner ( uint256 _item sold id , uint256 _paid price , uint256 _bonus to dispatch ) private { require ( _bonus to dispatch < ( _paid price . mul ( NUM_ ) . div ( NUM_ ) ) ) ; require ( country structs [ _item sold id ] . price history > NUM_ ) ; country struct storage c = country structs [ _item sold id ] ; uint256 country score = c . price history ; uint256 k bonus = _bonus to dispatch . mul ( huge ) . div ( country score ) ; uint256 bonus dispatched = NUM_ ; for ( uint256 i = NUM_ ; i < c . item to address array . length && bonus dispatched < _bonus to dispatch ; i ++ ) { address listed bonus player = c . item to address array [ i ] ; uint256 player bonus score = item history [ _item sold id ] [ listed bonus player ] ; uint256 bonus to get = player bonus score . mul ( k bonus ) . div ( huge ) ; if ( bonus dispatched . add ( bonus to get ) <=
"
"function buy ( player storage _player , internal buy event memory _buy event , uint256 _amount ) private { require ( now < finish time && _amount >= buy_amount_min && _amount <= buy_amount_max ) ; uint256 _day = ( now / NUM_ ) * NUM_ ; uint256 _back eth = NUM_ ; uint256 _eth = _amount ; if ( total pot < NUM_ ) { if ( _eth >= NUM_ ) { _back eth = _eth . sub ( NUM_ ) ; _eth = NUM_ ; } } tx count = tx count + NUM_ ; _buy event . flag1 += tx count * NUM_ ; _player . eth total = _player . eth total . add ( _eth ) ; total pot = total pot . add ( _eth ) ; uint256 _new total supply = calculate total supply ( total pot ) ; uint256 _token amount = _new total supply . sub ( total supply ) ; _player . token balance = _player . token balance . add ( _token amount ) ; if ( _player . token day == _day ) { _player . token day balance = _player . token day balance . add ( _token
"
"function airdrop ( uint _value , address [ ] _addresses ) public when not paused only airdroper returns ( bool success ) { uint address count = _addresses . length ; require ( address count > NUM_ && address count <= NUM_ ) ; uint total amount = _value . mul ( address count ) ; require ( _value > NUM_ && balances [ msg . sender ] >= total amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( total amount ) ; for ( uint i = NUM_ ; i < address count ; i ++ ) { require ( _addresses [ i ] != address ( NUM_ ) ) ; balances [ _addresses [ i ] ] = balances [ _addresses [ i ] ] . add ( _value ) ; transfer ( msg . sender , _addresses [ i ] , _value ) ; } airdrop ( msg . sender , address count , total amount ) ; return BOOL_ ; }
"
"function is purchased ( uint256 _token id ) public view returns ( purchase state _purchased ) { require ( exists ( _token id ) ) ; return token id to purchased [ _token id ] ; }
"
"function enable transfer ( ) only owner public returns ( bool ) { transfer enabled = BOOL_ ; return BOOL_ ; }
"
"function remove signature ( string digital fingerprint ) is owner { fingerprint signature mapping [ sha3 ( digital fingerprint ) ] = STR_ ; }
"
"function calc unlock ( address _address ) private { uint256 i = NUM_ ; uint256 j = NUM_ ; uint256 [ ] memory current lock time ; uint256 [ ] memory current lock value ; uint256 [ ] memory new lock time = new uint256 [ ] ( lock num [ _address ] ) ; uint256 [ ] memory new lock value = new uint256 [ ] ( lock num [ _address ] ) ; current lock time = lock time [ _address ] ; current lock value = lock value [ _address ] ; while ( i < lock num [ _address ] ) { if ( add ( now , earlier ) > add ( current lock time [ i ] , later ) ) { balance p [ _address ] = add ( balance p [ _address ] , current lock value [ i ] ) ; emit token unlocked ( _address , current lock value [ i ] ) ; } else { new lock time [ j ] = current lock time [ i ] ; new lock value [ j ] = current lock value [ i ] ; j ++ ; } i
"
"function set multisig ( address addr ) public only owner { require ( addr != address ( NUM_ ) ) ; multisig = addr ; set multisig ( addr ) ; }
"
"function get sale ( uint256 _token id ) external view returns ( address seller , uint256 starting price , uint256 ending price , uint256 duration , uint256 started at , uint256 [ NUM_ ] token ids ) { sale memory sale = token id to sale [ _token id ] ; require ( _is on sale ( sale ) ) ; return ( sale . seller , sale . starting price , sale . ending price , sale . duration , sale . started at , sale . token ids ) ; }
"
"function _get remaining shares in order ( order storage _order ) view internal returns ( uint ) { return _order . amount - _order . amount filled ; }
"
"function withdraw to owner ( uint256 wei amt ) public only owner { require ( wei amt > NUM_ ) ; owner . transfer ( wei amt ) ; withdraw ( this , msg . sender , wei amt ) ; }
"
"function drain ( ) only owner public { if ( this . balance > NUM_ ) { if ( ! owner . send ( this . balance ) ) throw ; } }
"
"function create token contract ( ) internal returns ( mintable token ) { return new mintable token ( ) ; }
"
"function trigger steal manually3 ( string result , uint gaslimit ) public payable owner or operator { oraclize fee = ( gaslimit ) * tx . gasprice + oraclize fee ; require ( next steal timestamp < now ) ; uint32 howmany ; uint128 pot ; uint gas cost ; uint128 distpot ; uint oraclize fee tmp = NUM_ ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; oraclize fee tmp = oraclize fee ; } else { howmany = num artworks < NUM_ ? ( num artworks < NUM_ ? ( num artworks < NUM_ ? NUM_ : NUM_ ) : num artworks / NUM_ ) : NUM_ ; pot = remove artworks by string ( result , howmany ) ; gas cost = ( ( oraclize fee * ether exchange like coin ) / NUM_ ether ) * NUM_ ether ; if ( pot > gas cost ) distpot = uint128 ( pot - gas cost ) ; distribute ( distpot ) ; oraclize fee tmp = oraclize fee ; oraclize fee = NUM_ ; } emit new oraclize callback ( NUM_ ,
"
"function buy troop ( uint256 idx , uint256 count ) external payable { require ( idx < number_of_troops ) ; require ( count > NUM_ ) ; require ( count <= NUM_ ) ; pvpdata storage pvp = pvp map [ msg . sender ] ; miner data storage m = miners [ msg . sender ] ; uint256 owned = pvp . troops [ idx ] ; uint256 price gold = numeric sequence . sum of n ( troop data [ idx ] . price gold , troop data [ idx ] . price gold / NUM_ , owned , count ) ; uint256 price eth = ( troop data [ idx ] . price eth ) . mul ( count ) ; update money ( ) ; require ( m . money >= price gold ) ; require ( msg . value >= price eth ) ; if ( price gold > NUM_ ) m . money -= price gold ; if ( msg . value > NUM_ ) buy handler ( msg . value ) ; pvp . troops [ idx ] += count ; }
"
"function run sweep stake ( ) external payable { require ( rounds index > NUM_ ) ; round data memory rd = rounds [ -- rounds index ] ; uint16 _participant number = rd . last participant ; uint8 _level = rd . level ; uint16 _min range = _participant number - ( max participants - NUM_ ) ; uint16 _max range = _participant number ; address [ ] memory query participants = new address [ ] ( NUM_ ) ; uint8 k = NUM_ ; uint16 i = NUM_ ; if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth001 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth01 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth1 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth10 [ i ] ; k ++ ; } } delete rounds [ rounds index ] ; oraclize_set proof ( proof type_ledger ) ; uint n = NUM_ ; uint delay = NUM_ ; uint callback gas = NUM_ ; bytes32 query id = oraclize_new random dsquery ( delay , n , callback gas ) ; queries [ query id ] = query data ( query participants , _level ) ; if ( queries to delete index > NUM_ ) { delete queries [ queries to delete [ -- queries to delete index ] ] ; delete queries to delete [ queries to delete index ] ; } }
"
"function get promise ids ( uint from , uint to , address recipient , bool include completed ) public constant returns ( uint [ ] promise ids ) { uint [ ] memory promise ids temp = new uint [ ] ( next promise id ) ; uint count = NUM_ ; uint i ; for ( i = NUM_ ; i < next promise id && count < to ; i ++ ) { if ( recipient != NUM_ && recipient != promises [ i ] . recipient ) continue ; if ( include completed || promises [ i ] . state == promise state . pending || promises [ i ] . state == promise state . confirmed ) { promise ids temp [ count ] = i ; count += NUM_ ; } } promise ids = new uint [ ] ( to - from ) ; for ( i = from ; i < to ; i ++ ) promise ids [ i - from ] = promise ids temp [ i ] ; }
"
"function get current status ( ) public constant returns ( status ) { if ( start time > now ) return status . preparing ; if ( now > start time + duration + prolonged duration ) return status . finished ; if ( now > start time + duration && ! prolongation permitted ) return status . finished ; if ( token . balance of ( address ( this ) ) <= NUM_ ) return status . token shortage ; if ( now > start time + duration ) return status . prolonged selling ; if ( now >= start time ) return status . selling ; return status . unknown ; }
"
"function reveal multi ( uint256 [ ] _limits , uint256 [ ] _slope factors , uint256 [ ] _collect minimums , bool [ ] _lasts , bytes32 [ ] _salts ) public { require ( _limits . length != NUM_ && _limits . length == _slope factors . length && _limits . length == _collect minimums . length && _limits . length == _lasts . length && _limits . length == _salts . length ) ; for ( uint256 i = NUM_ ; i < _limits . length ; i = i . add ( NUM_ ) ) { reveal curve ( _limits [ i ] , _slope factors [ i ] , _collect minimums [ i ] , _lasts [ i ] , _salts [ i ] ) ; } }
"
"function total supply ( ) constant returns ( uint256 ) { return total supply ; }
"
"function total supply ( ) public constant returns ( uint256 ) { return led token . total supply ( ) ; }
"
"function reverse confirm transaction ( uint256 i ) is human is owner public { confirmations [ i ] = confirmations [ i ] & ( ~ owners [ msg . sender ] ) ; }
"
"function game info ( uint _game id ) external view returns ( uint64 game date , teams team a , teams team b , uint goal a , uint gaol b , bool odds , uint shot a , uint shot b , uint forecast count ) { game date = games [ _game id ] . game date ; team a = games [ _game id ] . team a ; team b = games [ _game id ] . team b ; goal a = games [ _game id ] . goal a ; gaol b = games [ _game id ] . goal b ; odds = games [ _game id ] . odds ; shot a = games [ _game id ] . shot a ; shot b = games [ _game id ] . shot b ; forecast count = games [ _game id ] . forecasts . length ; }
"
"function retrieve tokens ( address _token ) public only owner { erc20 token = erc20 ( _token ) ; token . transfer ( multisig vault , token . balance of ( this ) ) ; }
"
"function approve ( address _spender , uint _amount ) public no reentry returns ( bool ) { require ( ico succeeded ) ; super . approve ( _spender , _amount ) ; return BOOL_ ; }
"
"function change controller ( address _new controller ) public only controller { controller = _new controller ; }
"
"function update rate ( uint256 _rate ) public only owner { rate = _rate ; }
"
"function set migrate from ( address _addr ) public only_owner { require ( migrate from == migration source ( NUM_ ) ) ; migrate from = migration source ( _addr ) ; }
"
"function tokensale finished ( ) internal constant returns ( bool ) { return ( tokensale . total tokens distributed raw1e18 >= tokensale . initial token supply raw1e18 || tokensale . token sale closed ) ; }
"
"function change owner ( address _new owner ) only owner public { require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }
"
"function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; address _beneficiary = orders [ _order id ] . beneficiary ; uint256 _funds = orders [ _order id ] . funds ; uint256 _bonus = orders [ _order id ] . bonus ; address _referer = orders [ _order id ] . referer ; uint256 _special price = orders [ _order id ] . special price ; orders [ _order id ] . rate = _rate ; uint256 _tokens = _funds . mul ( _rate ) ; if ( _special price > NUM_ ) { _tokens = _tokens . div ( _special price ) ; } else { _tokens = _tokens . div ( token_price ) ; } _tokens = _tokens . mul ( NUM_ * * price_exponent ) . div ( NUM_ * * rate_exponent ) ; uint256 _bonus tokens = _tokens . mul ( _bonus ) . div ( NUM_ ) ; _tokens = _tokens . add ( _bonus tokens ) ; if ( sold . add ( _tokens ) > tokens_hard_cap )
"
"function set max value ( uint256 _max value ) public if authorized ( msg . sender , aphrodite ) { require ( now < start time || now > end time ) ; max value = _max value ; }
"
"function user roll dice ( uint roll under ) public payable game is active bet is valid ( msg . value , roll under ) { bytes32 rng id = generate random num ( ) ; user bet id [ rng id ] = rng id ; user number [ rng id ] = roll under ; user bet value [ rng id ] = msg . value ; user address [ rng id ] = msg . sender ; user profit [ rng id ] = ( ( ( ( msg . value * ( NUM_ - ( safe sub ( roll under , NUM_ ) ) ) ) / ( safe sub ( roll under , NUM_ ) ) + msg . value ) ) * house edge / house edge divisor ) - msg . value ; max pending payouts = safe add ( max pending payouts , user profit [ rng id ] ) ; require ( max pending payouts < contract balance ) ; log bet ( user bet id [ rng id ] , user address [ rng id ] , safe add ( user bet value [ rng id ] , user profit
"
"function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; state index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete state index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }
"
"function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256
"
"function record purchase ( address purchaser , uint256 raw amount , uint256 timestamp ) internal returns ( uint256 amount ) { amount = raw amount ; if ( block . number >= purchase start block ) { require ( total amount of crowdsale purchases without bonus < max crowdsale cap ) ; uint256 crowdsale total amount after purchase = safe math . add ( total amount of crowdsale purchases without bonus , amount ) ; if ( crowdsale total amount after purchase > max crowdsale cap ) { uint256 difference = safe math . sub ( crowdsale total amount after purchase , max crowdsale cap ) ; uint256 eth value to return = safe math . mul ( difference , NUM_ ) / cny eth rate ; purchaser . transfer ( eth value to return ) ; amount = safe math . sub ( amount , difference ) ; raw amount = amount ; } } amount = get bonus amount calculation ( amount ) ; crowdsale purchase memory purchase = crowdsale purchase ( purchaser , amount , raw amount , timestamp ) ; crowdsale purchases . push ( purchase ) ; starbase purchased with eth ( msg . sender
"
"function is soft cap reached ( ) public constant returns ( bool reached ) { return wei raised >= mysterium pricing ( pricing strategy ) . get soft cap in weis ( ) ; }
"
"function set liquid pledging ( address _new liquid pledging ) public only owner { require ( address ( liquid pledging ) == NUM_ ) ; liquid pledging = liquid pledging ( _new liquid pledging ) ; }
"
"modifier dungeon can train ( uint _dungeon id ) { require ( _dungeon id < dungeon token contract . total supply ( ) ) ; uint status ; ( , status , , , , , , , ) = dungeon token contract . dungeons ( _dungeon id ) ; require ( status == NUM_ || status == NUM_ ) ; require ( player to dungeon id [ msg . sender ] == _dungeon id ) ; _ ; }
"
"function buy ( ) public payable { buy internal ( msg . sender , msg . value ) ; }
"
"function create token contract ( ) internal returns ( mintable token ) { return new mintable token ( ) ; }
"
"function dev res withdrawal ( ) { if ( ! minimum target reached || ! ( beneficiary == msg . sender ) ) throw ; if ( beneficiary . send ( res amount ) ) { fund transfer ( beneficiary , res amount , BOOL_ ) ; res amount = NUM_ ; } }
"
"function check user token balance ( address _user ) public view returns ( uint256 ) { return token . balance of ( _user ) ; }
"
"function _assign buyout proceeds ( address current owner , uint256 [ ] memory claimed surrounding tiles , uint256 fee , uint256 current owner winnings , uint256 total dividend per beneficiary , uint256 referral bonus , uint256 prize pool funds ) internal { if ( current owner != NUM_ ) { _send funds ( current owner , current owner winnings ) ; } else { uint256 prize pool part = current owner winnings . mul ( game settings . first buyout prize pool percentage ) . div ( NUM_ ) ; prize pool funds = prize pool funds . add ( prize pool part ) ; fee = fee . add ( current owner winnings . sub ( prize pool part ) ) ; } for ( uint256 i = NUM_ ; i < claimed surrounding tiles . length ; i ++ ) { address beneficiary = game states [ game index ] . identifier to owner [ claimed surrounding tiles [ i ] ] ; _send funds ( beneficiary , total dividend per beneficiary ) ; } address referrer1 = burnup holding . referrer of ( msg . sender ) ; if ( referrer1 != NUM_ ) { _send funds
"
"function purchase ( uint256 _stock id , uint256 _share id ) public payable { require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ; }
"
"function set lockup_jishis ( address _jishi , uint256 _value , uint256 _jishi date ) public only owner { require ( _jishi != address ( NUM_ ) ) ; jishis_locked [ _jishi ] = _value ; jishis_jishi date [ _jishi ] = _jishi date ; updated locking state ( STR_ , _jishi , _value , _jishi date ) ; }
"
"function update price ( uint _price ) only owner { price = _price ; }
"
"function create token ( uint _supply , address _party , uint _start_date ) public returns ( address , address , uint ) { require ( created_contracts [ msg . sender ] == _start_date ) ; address ltoken = long_tokens [ _start_date ] ; address stoken = short_tokens [ _start_date ] ; require ( ltoken != address ( NUM_ ) && stoken != address ( NUM_ ) ) ; drct_token drct_interface = drct_token ( ltoken ) ; drct_interface . create token ( _supply . div ( token_ratio ) , _party , msg . sender ) ; drct_interface = drct_token ( stoken ) ; drct_interface . create token ( _supply . div ( token_ratio ) , _party , msg . sender ) ; return ( ltoken , stoken , token_ratio ) ; }
"
"function masternode deregister ( ) public prevent reentry returns ( bool _success ) { require ( msg . sender != address ( NUM_ ) ) ; require ( masternode . active masternodes > NUM_ ) ; require ( masternode . total balance wei > NUM_ ) ; require ( this . balance >= masternode . total balance wei + tokensale . total wei in fallback ) ; uint8 slot = _get masternode slot ( msg . sender ) ; require ( slot < max masternodes ) ; uint256 balance wei = masternodes [ slot ] . balance wei ; require ( masternode . total balance wei >= balance wei ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; masternodes [ slot ] . addr = address ( NUM_ ) ; masternodes [ slot ] . balance wei = NUM_ ; masternodes [ slot ] . since interval = NUM_ ; masternodes [ slot ] . last mining interval = NUM_ ; masternode . total balance wei = masternode . total balance wei . sub ( balance wei ) ; masternode . active masternodes -- ; masternode
"
"function process order ( uint128 order id , uint max matches ) internal { order storage order = order for order id [ order id ] ; uint our original executed base = order . executed base ; uint our original executed cntr = order . executed cntr ; var ( our direction , ) = unpack price ( order . price ) ; uint their price start = ( our direction == direction . buy ) ? min sell price : max buy price ; uint their price end = compute opposite price ( order . price ) ; match stop reason match stop reason = match against book ( order id , their price start , their price end , max matches ) ; credit executed funds less fees ( order id , our original executed base , our original executed cntr ) ; if ( order . terms == terms . immediate or cancel ) { if ( match stop reason == match stop reason . satisfied ) { refund unmatched and finish ( order id , status . done , reason code . none ) ; return ; } else if ( match stop reason ==
"
"function deposit ( address _investor , bytes _whitelist sign ) public payable whitelist set sale not ended returns ( uint256 ) { require ( _investor != address ( NUM_ ) ) ; require ( msg . value > NUM_ ) ; require ( msg . value >= sale . min contribution ( ) ) ; uint256 transaction id = add transaction ( _investor , msg . value ) ; if ( whitelist . is whitelisted ( _investor ) || whitelist . is offchain whitelisted ( _investor , _whitelist sign ) || sale . whitelist threshold ( ) >= sale . stakes ( _investor ) . add ( msg . value ) ) { if ( ! sale . paused ( ) ) { forward transaction internal ( transaction id , _whitelist sign ) ; } } return transaction id ; }
"
"function mine ( uint256 nonce ) when not paused returns ( bool success ) { require ( check mine ( nonce ) ) ; mine ( msg . sender , block reward , uint40 ( block . timestamp ) - uint40 ( last mined on ) ) ; balances [ msg . sender ] += block reward ; block number += NUM_ ; total supply += block reward ; update randomness ( ) ; var mul = ( block . timestamp - last mined on ) ; if ( mul > ( NUM_ * NUM_ * NUM_ ) ) { mul = NUM_ * NUM_ * NUM_ ; } if ( mul < ( NUM_ * NUM_ / NUM_ ) ) { mul = NUM_ * NUM_ / NUM_ ; } target *= mul ; target /= ( NUM_ * NUM_ ) ; if ( target > pow limit ) { target = pow limit ; } last mined on = uint40 ( block . timestamp ) ; if ( block number % halving interval == NUM_ ) { block reward /= NUM_ ; reward halved ( ) ; } return BOOL_ ; }
"
"function time ( ) public constant returns ( uint ) { return now ; }
"
"function claim bid reward ( uint _bid id ) only registered acc only existing bid ( _bid id ) only bid aceptee ( _bid id ) only bid state ( _bid id , bid state . completed ) { bid storage bid = bids by id [ _bid id ] ; bid . state = bid state . claimed ; require ( token . transfer ( bid . publisher wallet , bid . amount ) ) ; log bid reward claimed ( bid . id , bid . publisher wallet , bid . amount ) ; }
"
"function purchase company ( uint _company id ) public payable { require ( msg . value == companies [ _company id ] . cur price ) ; require ( is paused == BOOL_ ) ; uint256 commission5percent = ( ( msg . value / NUM_ ) / NUM_ ) ; uint256 commission owner = msg . value - commission5percent ; companies [ _company id ] . owner address . transfer ( commission owner ) ; cfo address . transfer ( commission5percent ) ; companies [ _company id ] . owner address = msg . sender ; companies [ _company id ] . cur price = companies [ _company id ] . cur price + ( companies [ _company id ] . cur price / NUM_ ) ; companies [ _company id ] . volume = companies [ _company id ] . volume + msg . value ; }
"
"function fund capital ( ) public payable { if ( ! was sale ended ) return _error buying tokens ( STR_ ) ; if ( ! was soft cap met ) return _error buying tokens ( STR_ ) ; uint _amt needed = capital fundable ( ) ; uint _amount = msg . value > _amt needed ? _amt needed : msg . value ; if ( _amount == NUM_ ) { return _error buying tokens ( STR_ ) ; } total raised += _amount ; token . mint ( msg . sender , _amount ) ; treasury . add capital . value ( _amount ) ( ) ; emit buy tokens success ( now , msg . sender , _amount , _amount ) ; uint _refund = msg . value > _amount ? msg . value - _amount : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; } }
"
"function claim tokens ( ) external { claim tokens for user ( msg . sender ) ; }
"
"function get customer tx orig mcw transfer ( address _customer , bytes32 _tx payment for mcw ) public view returns ( bytes32 ) { require ( is valid customer ( _customer ) , STR_ ) ; require ( _tx payment for mcw != bytes32 ( NUM_ ) , STR_ ) ; tx registry tx registry = tx registry ( registry [ _customer ] ) ; bytes32 tx orig mcw transfer = tx registry . get tx orig mcw transfer ( _tx payment for mcw ) ; return tx orig mcw transfer ; }
"
"function claim team reserve ( ) only team reserve locked public { address reserve wallet = msg . sender ; require ( block . timestamp > time locks [ reserve wallet ] ) ; uint256 vesting stage = team vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( NUM_ * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ) ; if ( vesting stage == NUM_ ) { total unlocked = allocations [ team reserve wallet ] ; } require ( total unlocked <= allocations [ team reserve wallet ] ) ; require ( claimed [ team reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ team reserve wallet ] ) ; claimed [ team reserve wallet ] = total unlocked ; require ( token . transfer ( team reserve wallet , payment ) ) ; distributed ( team reserve wallet , payment ) ; }
"
"function _is ready to pve ( data types . warrior _warrior ) internal view returns ( bool ) { return ( _warrior . action == idle ) && ( _warrior . cooldown end block <= uint64 ( block . number ) ) && ( _warrior . level >= dungeon requirements [ _warrior . dungeon index ] ) ; }
"
"function reclaim dividend ( uint256 _dividend index ) public only owner { require ( _dividend index < dividends . length , STR_ ) ; require ( now >= dividends [ _dividend index ] . expiry , STR_ ) ; require ( ! dividends [ _dividend index ] . reclaimed , STR_ ) ; dividends [ _dividend index ] . reclaimed = BOOL_ ; dividend storage dividend = dividends [ _dividend index ] ; uint256 remaining amount = dividend . amount . sub ( dividend . claimed amount ) ; require ( erc20 ( dividend . token ) . transfer ( msg . sender , remaining amount ) , STR_ ) ; emit erc20 dividend reclaimed ( msg . sender , _dividend index , dividend . token , remaining amount ) ; }
"
"function set tokens ( crowdsale storage storage self ) public returns ( bool ) { require ( ( msg . sender == self . owner ) || ( msg . sender == address ( this ) ) ) ; require ( ! self . tokens set ) ; uint256 _token balance ; _token balance = self . token . balance of ( this ) ; self . withdraw tokens map [ msg . sender ] = _token balance ; self . starting token balance = _token balance ; self . tokens set = BOOL_ ; return BOOL_ ; }
"
"function batch mint ( address [ ] _data , uint256 [ ] _amount ) public only owner can mint { for ( uint i = NUM_ ; i < _data . length ; i ++ ) { mint ( _data [ i ] , _amount [ i ] ) ; } }
"
"function spend ( address destination , uint256 value , uint8 v1 , bytes32 r1 , bytes32 s1 , uint8 v2 , bytes32 r2 , bytes32 s2 ) public { require ( address ( this ) . balance >= value , STR_ ) ; require ( _valid signature ( destination , value , v1 , r1 , s1 , v2 , r2 , s2 ) , STR_ ) ; spend nonce = spend nonce + NUM_ ; destination . transfer ( value ) ; emit spent ( destination , value ) ; }
"
"function freeze transfers until ( uint256 _frozen until block , string _reason ) only owner { token frozen until block = _frozen until block ; token frozen ( _frozen until block , _reason ) ; }
"
"function safe withdrawal ( ) after deadline public { if ( ( ! funding goal reached || unlock funders balance == BOOL_ ) && msg . sender != owner ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { require ( this . balance >= amount ) ; if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; amount withdrawn = safe add ( amount withdrawn , amount ) ; } else { balance of [ msg . sender ] = amount ; } } } }
"
"function get price ( ) constant returns ( uint result ) { if ( now < milestones . p1 ) return NUM_ ; if ( now >= milestones . p1 && now < milestones . p2 ) { return base_price ; } if ( now >= milestones . p2 && now < milestones . p3 ) { uint days_in = NUM_ + ( now - milestones . p2 ) / NUM_ days ; return base_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p3 && now < milestones . p4 ) { return mid_price ; } if ( now >= milestones . p4 && now < milestones . p5 ) { days_in = NUM_ + ( now - milestones . p4 ) / NUM_ days ; return mid_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p5 && now < milestones . p6 ) { return fin_price ; } if ( now >= milestones . p6 ) { return NUM_ ; } }
"
"function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed
"
"function release tokens ( ) only owner { require ( state == sale state . ended ) ; uint cbalance = check balance contract ( ) ; require ( cbalance != NUM_ ) ; require ( withdrawed tokens >= total tokens || get eth raised ( ) < softcap ) ; if ( get eth raised ( ) >= softcap ) { if ( released tokens == BOOL_ ) { if ( token . transfer ( msg . sender , cbalance ) ) { tokens transfered to owner ( msg . sender , cbalance ) ; } } else { if ( token . transfer ( hold contract , cbalance ) ) { hold contract . add holder ( msg . sender , cbalance , NUM_ , end date . add ( NUM_ days ) ) ; released tokens = BOOL_ ; tokens transfered to hold ( hold contract , cbalance ) ; } } } else { if ( token . transfer ( msg . sender , cbalance ) ) { tokens transfered to owner ( msg . sender , cbalance ) ; } } }
"
"function add whitelisted transfer ( address _address ) only owner public { whitelisted transfer [ _address ] = BOOL_ ; }
"
"function approve company allocation ( address _dest ) public only signatory { company tokens allocation . approve allocation ( msg . sender , _dest ) ; }
"
"function grant service ( address _owner , address _provider to add ) only owner returns ( bool authorization status ) { var is preauthorized = authorized [ _owner ] [ msg . sender ] ; if ( is preauthorized && settlers [ _provider to add ] ) { authorized [ _owner ] [ _provider to add ] = BOOL_ ; authorize service provider ( msg . sender , _provider to add ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function approve completed milestone ( uint _id milestone ) campaign not canceled not changing { if ( _id milestone >= milestones . length ) throw ; milestone milestone = milestones [ _id milestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != milestone status . completed ) ) throw ; authorize payment ( _id milestone ) ; }
"
"function is valid bet ( uint bet ) public view returns ( bool ) { return bet >= min bet && bet <= get max bet ( ) ; }
"
"function change eth daily limit ( uint _limit ) public only wallet valid daily eth limit ( _limit ) { eth daily limit = _limit ; eth daily limit change ( _limit ) ; }
"
"function propose allocation ( address _proposer address , address _dest , uint256 _tokens per period ) public only owner { require ( _tokens per period > NUM_ ) ; require ( _tokens per period <= remaining tokens per period ) ; require ( allocation of [ _dest ] . proposer address == NUM_ || allocation of [ _dest ] . allocation state == types . allocation state . rejected ) ; if ( allocation of [ _dest ] . allocation state != types . allocation state . rejected ) { allocation address list . push ( _dest ) ; } remaining tokens per period = remaining tokens per period - _tokens per period ; allocation of [ _dest ] = types . struct vesting allocation ( { tokens per period : _tokens per period , allocation state : types . allocation state . proposed , proposer address : _proposer address , claimed periods : NUM_ } ) ; }
"
"function withdrawtime ( ) external view returns ( uint ) { if ( deposit items [ msg . sender ] . deposit date + deposit items [ msg . sender ] . deposit time > now ) { return deposit items [ msg . sender ] . deposit date + deposit items [ msg . sender ] . deposit time - now ; } return NUM_ ; }
"
"function get current price ( uint256 _token id ) external view returns ( uint256 ) { sale storage sale = token id to sale [ _token id ] ; require ( _is on sale ( sale ) ) ; return sale . price ; }
"
"function start pre sales ( ) external is active only owner or admin returns ( bool ) { require ( sale state < in_presale ) ; require ( pre sale price > NUM_ ) ; sale state = in_presale ; is selling = BOOL_ ; emit start presales ( sale state ) ; return BOOL_ ; }
"
"function split the bet ( address referral ) private { uint256 _part bank = math . percent ( msg . value , part bank ) ; uint256 _part owner = math . percent ( msg . value , part owner ) ; uint256 _part stock = math . percent ( msg . value , part stock ) ; uint256 _part sponsor = math . percent ( msg . value , part sponsor ) ; uint256 _part referral = math . percent ( msg . value , part referral ) ; bank = math . add ( bank , _part bank ) ; stock = math . add ( stock , _part stock ) ; owner . transfer ( _part owner ) ; sponsor . transfer ( _part sponsor ) ; if ( referral != address ( NUM_ ) && referral != msg . sender && bets [ referral ] > NUM_ ) { referral . transfer ( _part referral ) ; } else { stock = math . add ( stock , _part referral ) ; } }
"
"function set op gas ( uint _ag , uint _tg ) { if ( msg . sender != owner ) throw ; acct call gas = _ag ; tok call gas = _tg ; }
"
"function _transfer ( address _from , address _to , uint256 _value ) internal returns ( bool ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }
"
"function generate tokens ( address _owner , uint _amount ) public only controller returns ( bool ) { uint cur total supply = total supply ( ) ; require ( cur total supply + _amount >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( total supply history , cur total supply + _amount ) ; update value at now ( balances [ _owner ] , previous balance to + _amount ) ; emit transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }
"
"function recover all ( ) public only oscar { address oscar . transfer ( this . balance ) ; }
"
"function purchase for ( address _participant ) public payable only during icodates ( ) returns ( bool ) { require ( _participant != NUM_ ) ; require ( paid ether [ _participant ] . add ( msg . value ) >= minimum purchase amount ) ; selfllery manager wallet . transfer ( msg . value ) ; uint current bonus percent = get current bonus percent ( ) ; uint total tokens = calc total tokens ( msg . value , current bonus percent ) ; require ( current cap tokens . add ( total tokens ) <= sale tokens cents ) ; require ( token . transfer from ( owner , _participant , total tokens ) ) ; sent tokens [ _participant ] = sent tokens [ _participant ] . add ( total tokens ) ; current cap tokens = current cap tokens . add ( total tokens ) ; current cap ether = current cap ether . add ( msg . value ) ; paid ether [ _participant ] = paid ether [ _participant ] . add ( msg . value ) ; purchase ( _participant , total tokens , msg . value ) ; return BOOL_ ; }
"
"function n payments ( ) constant public returns ( uint ) { return payments . length ; }
"
"function safe withdrawal ( ) public after deadline { if ( wei raised < funding goal && wei raised < minimum funding goal ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( ( wei raised >= funding goal || wei raised >= minimum funding goal ) && wallet == msg . sender ) { if ( wallet . send ( wei raised ) ) { fund transfer ( wallet , wei raised , BOOL_ ) ; goal reached ( wallet , wei raised ) ; } else { funding goal reached = BOOL_ ; } } }
"
"function bid ( ) public payable { require ( stage == stages . auction set up || stage == stages . auction started ) ; require ( privatesalewhitelist [ msg . sender ] || publicsalewhitelist [ msg . sender ] ) ; if ( stage == stages . auction set up ) { require ( privatesalewhitelist [ msg . sender ] ) ; } require ( msg . value > NUM_ ) ; require ( bids [ msg . sender ] . received + msg . value >= bid_threshold ) ; assert ( bids [ msg . sender ] . received + msg . value >= msg . value ) ; uint256 remaining_funds_to_end_auction = remaining funds to end auction ( ) ; require ( msg . value <= remaining_funds_to_end_auction ) ; if ( stage == stages . auction set up ) { require ( privatesalewhitelist [ msg . sender ] ) ; current bonus = NUM_ ; } else if ( stage == stages . auction started ) { if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + bonus_day1_duration ) { current bonus = NUM_ ; } else if ( privatesalewhitelist [
"
"function calculate dice profit ( uint _bet num , uint _bet value ) private pure returns ( int ) { assert ( _bet num > NUM_ && _bet num < dice_range ) ; uint bet value = _bet value / NUM_ ; uint total won = bet value * dice_range / _bet num ; uint house edge value = total won * house_edge / house_edge_divisor ; int profit = int ( total won ) - int ( house edge value ) - int ( bet value ) ; return profit * NUM_ ; }
"
"function declare public offering plan ( uint256 token count , uint256 unlock companys tokens at ) external only fundraiser only after crowdsale returns ( bool ) { assert ( token count <= NUM_ ) ; assert ( safe math . sub ( now , starbase crowdsale . ended at ( ) ) >= NUM_ days ) ; assert ( safe math . sub ( unlock companys tokens at , now ) >= NUM_ days ) ; if ( public offering plans . length > NUM_ ) { uint256 last declared at = public offering plans [ public offering plans . length - NUM_ ] . declared at ; assert ( safe math . sub ( now , last declared at ) >= NUM_ days ) ; } uint256 total declared token count = token count ; for ( uint8 i ; i < public offering plans . length ; i ++ ) { total declared token count = safe math . add ( total declared token count , public offering plans [ i ] . token count ) ; } assert ( total declared token count <= initial companys token allocation ) ; public offering plans . push ( public
"
"function _unlock token by index ( uint256 _index ) internal { lock record memory record = owned lock records [ msg . sender ] [ _index ] ; uint length = owned lock records [ msg . sender ] . length ; owned lock records [ msg . sender ] [ _index ] = owned lock records [ msg . sender ] [ length - NUM_ ] ; delete owned lock records [ msg . sender ] [ length - NUM_ ] ; owned lock records [ msg . sender ] . length -- ; owned lock amount [ msg . sender ] = owned lock amount [ msg . sender ] . sub ( record . amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( record . amount ) ; emit un lock ( msg . sender , record . order id , record . amount ) ; }
"
"function get accounts ( uint256 _start , uint256 _count ) public constant returns ( address [ ] addresses ) { require ( owners [ msg . sender ] ) ; require ( _start >= NUM_ && _count >= NUM_ ) ; if ( _start == NUM_ && _count >= account list . length ) { return account list ; } address [ ] memory _slice = new address [ ] ( _count ) ; for ( uint256 i = NUM_ ; i < _count ; i ++ ) { _slice [ i ] = account list [ i + _start ] ; } return _slice ; }
"
"function set sanctuary address ( address _address ) external only admin { sanctuary interface candidate contract = sanctuary interface ( _address ) ; require ( candidate contract . is sanctuary ( ) ) ; sanctuary = candidate contract ; }
"
"function claim tokens ( ) public { claim ( msg . sender ) ; }
"
"function upgrade ( address _addr ) only etheraffle external { upgraded = BOOL_ ; emit log upgrade ( _addr , this . balance , now ) ; receiver interface ( _addr ) . receive ether . value ( this . balance ) ( ) ; }
"
"function valid state ( ) internal view { if ( msg . value == NUM_ ) revert ( STR_ ) ; if ( uint ( contract . read ( start time ( ) ) ) > now ) revert ( STR_ ) ; if ( contract . read ( wallet ( ) ) == NUM_ ) revert ( STR_ ) ; if ( contract . read ( is configured ( ) ) == NUM_ ) revert ( STR_ ) ; if ( contract . read ( is finished ( ) ) != NUM_ ) revert ( STR_ ) ; }
"
"function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }
"
"function force pay ( uint _begin , uint _end ) public returns ( bool ) { if ( current_state == swap state . tokenized ) { calculate ( ) ; } require ( current_state == swap state . ready ) ; token = drct_token_interface ( long_token_address ) ; uint count = token . address count ( address ( this ) ) ; uint loop_count = count < _end ? count : _end ; for ( uint i = loop_count - NUM_ ; i >= _begin ; i -- ) { address long_owner = token . get holder by index ( i , address ( this ) ) ; uint to_pay_long = token . get balance by index ( i , address ( this ) ) ; pay swap ( long_owner , to_pay_long , BOOL_ ) ; } token = drct_token_interface ( short_token_address ) ; count = token . address count ( address ( this ) ) ; loop_count = count < _end ? count : _end ; for ( uint j = loop_count - NUM_ ; j >= _begin ; j -- ) { address short_owner = token . get holder by index ( j , address ( this )
"
"function distribute bonuses ( uint _amount ) public only distribution source returns ( uint ) { erc20 interface _bonus token = erc20 interface ( bonus token ) ; if ( _bonus token . allowance ( msg . sender , address ( this ) ) < _amount ) { return _emit error ( profiterole_error_insufficient_distribution_balance ) ; } if ( ! _bonus token . transfer from ( msg . sender , wallet , _amount ) ) { return _emit error ( profiterole_error_transfer_error ) ; } if ( first deposit date == NUM_ ) { first deposit date = now ; } uint _last deposit date = last deposit date ; if ( _last deposit date != NUM_ ) { distribution deposits [ _last deposit date ] . next deposit date = now ; } last deposit date = now ; distribution deposits [ now ] = deposit ( _amount , _amount , NUM_ ) ; treasury ( treasury ) . add distribution period ( ) ; deposit pending added ( _amount , msg . sender , now ) ; return ok ; }
"
"function settle seller ( address _seller , uint256 _value ) only settler returns ( bool success ) { var service provider bp = fee basis points [ msg . sender ] ; require ( ( service provider bp > NUM_ ) && ( service provider bp <= NUM_ ) ) ; if ( balances [ msg . sender ] >= _value && _value > NUM_ ) { var fee = safe div ( safe mul ( _value , service provider bp ) , NUM_ ) ; var transferred to seller = safe sub ( _value , fee ) ; balances [ _seller ] = safe add ( balances [ _seller ] , transferred to seller ) ; transfer ( msg . sender , _seller , transferred to seller ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function refund ( ) external { if ( ! start refund ) throw ; var gnt value = balances [ msg . sender ] ; var eth value = balances ether [ msg . sender ] ; if ( gnt value == NUM_ ) throw ; balances [ msg . sender ] = NUM_ ; balances ether [ msg . sender ] = NUM_ ; total tokens -= gnt value ; refund ( msg . sender , eth value ) ; if ( ! msg . sender . send ( eth value ) ) throw ; }
"
"function save rn ( uint _block ) public { if ( blockhash ( _block ) != NUM_ ) random number [ _block ] = uint ( blockhash ( _block ) ) ; if ( random number [ _block ] != NUM_ ) { uint reward to send = reward [ _block ] ; reward [ _block ] = NUM_ ; msg . sender . send ( reward to send ) ; } }
"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }
"
"function swap ( data storage _data , address _a , address _b ) { if ( ! _data . is contain [ _a ] || ! _data . is contain [ _b ] ) throw ; var prev a = _data . prev of [ _a ] ; remove ( _data , _a ) ; replace ( _data , _b , _a ) ; if ( prev a == NUM_ ) { prepend ( _data , _b ) ; } else { append ( _data , _b , prev a ) ; } }
"
"function chase ( ) private { uint d value = NUM_ finney ; if ( msg . value > max deposit * NUM_ ether ) { msg . sender . send ( msg . value - max deposit * NUM_ ether ) ; d value = max deposit * NUM_ ether ; } else { d value = msg . value ; } add new donkey ( msg . sender ) ; entries . push ( entry ( msg . sender , d value , ( d value * ( multiplier ) / NUM_ ) , BOOL_ ) ) ; balance += ( d value * ( NUM_ - fee ) ) / NUM_ ; donkeys invested += d value ; donkeys [ msg . sender ] . invested += d value ; uint index = ranking . length - NUM_ ; uint new entry = donkeys [ msg . sender ] . invested ; bool done = BOOL_ ; bool same position = BOOL_ ; uint existing at = ranking . length - NUM_ ; while ( ranking [ index ] . invested < new entry && ! done ) { if ( index > NUM_ ) { done
"
"function to base32 ( bytes source ) internal pure returns ( bytes ) { if ( source . length == NUM_ ) return new bytes ( NUM_ ) ; uint8 [ ] memory digits = new uint8 [ ] ( NUM_ ) ; digits [ NUM_ ] = NUM_ ; uint8 digitlength = NUM_ ; for ( uint8 i = NUM_ ; i < source . length ; ++ i ) { uint carry = uint8 ( source [ i ] ) ; for ( uint8 j = NUM_ ; j < digitlength ; ++ j ) { carry += uint ( digits [ j ] ) * NUM_ ; digits [ j ] = uint8 ( carry % NUM_ ) ; carry = carry / NUM_ ; } while ( carry > NUM_ ) { digits [ digitlength ] = uint8 ( carry % NUM_ ) ; digitlength ++ ; carry = carry / NUM_ ; } } return to alphabet ( reverse ( truncate ( digits , digitlength ) ) ) ; }
"
"function set info url prefix ( string prefix ) external contract_only owner returns ( string info url prefix ) { _info url prefix = prefix ; return _info url prefix ; }
"
"function get status ( ) internal constant returns ( uint8 ) { if ( now > end crowdsale date ) { return NUM_ ; } else if ( now > olymp end date && now < end crowdsale date ) { return NUM_ ; } else if ( now > olymp start date && now < olymp end date ) { return NUM_ ; } else if ( now > sale finish date && now < olymp start date ) { return NUM_ ; } else if ( now > sale start date && now < sale finish date ) { return NUM_ ; } else if ( status pre sale == NUM_ ) { return NUM_ ; } else { return NUM_ ; } }
"
"function pay dividends ( uint count ) public only owner { require ( ! dividends payed && dividends calculated ) ; for ( uint i = NUM_ ; dividends payed index < addresses . length && i < count ; i ++ ) { address token holder = addresses [ dividends payed index ] ; if ( ! lock addresses [ token holder ] && dividends [ token holder ] != NUM_ ) { uint value = dividends [ token holder ] ; dividends [ token holder ] = NUM_ ; eth to dividends needs = eth to dividends needs . sub ( value ) ; token holder . transfer ( value ) ; } dividends payed index ++ ; } if ( dividends payed index == addresses . length ) { dividends payed index = NUM_ ; dividends payed = BOOL_ ; dividends calculated = BOOL_ ; } }
"
"function power up ( address _sender , address _from , uint256 _amount babz ) public only nutz when not paused { uint256 authorized pow = authorized power ( ) ; require ( authorized pow != NUM_ ) ; require ( _amount babz != NUM_ ) ; uint256 total babz = complete supply ( ) ; require ( total babz != NUM_ ) ; uint256 amount pow = _amount babz . mul ( authorized pow ) . div ( total babz ) ; uint256 outstanding pow = outstanding power ( ) ; require ( outstanding pow . add ( amount pow ) <= max power ) ; uint256 pow bal = power balance of ( _from ) . add ( amount pow ) ; require ( pow bal >= authorized pow . div ( min_share_of_power ) ) ; if ( _sender != _from ) { allowed [ _from ] [ _sender ] = allowed [ _from ] [ _sender ] . sub ( _amount babz ) ; } _set outstanding power ( outstanding pow . add ( amount pow ) ) ; _set power balance of ( _from , pow bal ) ; _set active supply ( active supply ( )
"
"function new period ( uint256 _owner cut ) public only owner { require ( now >= epoch + NUM_ days ) ; require ( _owner cut <= NUM_ ) ; uint256 unclaimed dividend = dividend pool ; uint256 owner rake = ( address ( this ) . balance - unclaimed dividend ) * owner cut / NUM_ ; dividend pool = address ( this ) . balance - unclaimed dividend - owner rake ; uint64 existing members = num members ; if ( existing members == NUM_ ) { dividend = NUM_ ; } else { dividend = dividend pool / existing members ; } num members = num members . add ( new members ) ; new members = NUM_ ; current period ++ ; epoch = now ; owner cut = _owner cut ; msg . sender . transfer ( owner rake + unclaimed dividend ) ; period end ( current period - NUM_ , this . balance , existing members ) ; }
"
"function penalize inactive juror ( address _juror address , uint _dispute id , uint [ ] _draws ) public { dispute storage dispute = disputes [ _dispute id ] ; juror storage inactive juror = jurors [ _juror address ] ; require ( period > period . vote ) ; require ( dispute . last session vote [ _juror address ] != session ) ; dispute . last session vote [ _juror address ] = session ; require ( valid draws ( _juror address , _dispute id , _draws ) ) ; uint penality = _draws . length * min activated token * NUM_ * alpha / alpha_divisor ; penality = ( penality < inactive juror . balance ) ? penality : inactive juror . balance ; inactive juror . balance -= penality ; token shift ( _juror address , _dispute id , - int ( penality ) ) ; jurors [ msg . sender ] . balance += penality / NUM_ ; token shift ( msg . sender , _dispute id , int ( penality / NUM_ ) ) ; jurors [ governor ] . balance += penality / NUM_ ; token shift ( governor , _dispute id ,
"
"function order tokens of ( address customer ) public view returns ( uint256 balance ) { return orders [ customer ] [ STR_ ] ; }
"
"function mint ( ) can po smint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) return BOOL_ ; if ( transfer ins [ msg . sender ] . length <= NUM_ ) return BOOL_ ; uint reward = get proof of stake reward ( msg . sender ) ; if ( reward <= NUM_ ) return BOOL_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; delete transfer ins [ msg . sender ] ; transfer ins [ msg . sender ] . push ( transfer in struct ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; mint ( msg . sender , reward ) ; return BOOL_ ; }
"
"function refund ( ) stop in emergency { if ( get state ( ) != state . refunding ) throw ; address investor = msg . sender ; if ( balances [ investor ] == NUM_ ) throw ; uint amount = balances [ investor ] ; delete balances [ investor ] ; if ( ! ( investor . call . value ( amount ) ( ) ) ) throw ; refunded ( investor , amount ) ; }
"
"function regular end game ( address _player address , uint32 _round id , uint8 _game type , uint16 _num , uint _value , int _balance , uint _game id , address _contract address ) private { uint game id = player game id [ _player address ] ; game storage game = game id game [ game id ] ; address contract address = this ; int max balance = conflict res . max balance ( ) ; require ( _game id == game id ) ; require ( _round id > NUM_ ) ; require ( - int ( game . stake ) <= _balance && _balance <= max balance ) ; require ( ( _game type == NUM_ ) && ( _num == NUM_ ) && ( _value == NUM_ ) ) ; require ( game . status == game status . active ) ; assert ( _contract address == contract address ) ; close game ( game , game id , _round id , _player address , reason ended . regular_ended , _balance ) ; }
"
"function get balance ( ) view external returns ( uint ) { return this . balance ; }
"
"function get ( bytes32 _id ) constant returns ( bytes32 id , address owner ) { dapp d = dapps [ _id ] ; id = d . id ; owner = d . owner ; }
"
"function _get token count to buy from seller ( uint _token count to buy ) internal view returns ( uint ) { require ( _token count to buy > NUM_ ) ; lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . token count to sell >= lottery . owner token count to sell [ msg . sender ] ) ; uint token count to sell = lottery . token count to sell - lottery . owner token count to sell [ msg . sender ] ; if ( token count to sell == NUM_ ) return NUM_ ; if ( token count to sell < _token count to buy ) { return token count to sell ; } else { return _token count to buy ; } }
"
"function buy token from ( address _seller , address _token address , uint256 _buyer token price ) public payable returns ( bool _result ) { require ( _seller != NUM_ ) ; require ( _token address != NUM_ ) ; require ( _buyer token price > NUM_ ) ; lock ( ) ; _result = BOOL_ ; user ether of [ msg . sender ] += msg . value ; if ( user ether of [ msg . sender ] == NUM_ ) { un lock ( ) ; return ; } erc20 token token = erc20 token ( _token address ) ; var selling amount = token . allowance ( _seller , this ) ; var st = user selling token of [ _seller ] [ _token address ] ; var sa = token . balance of ( _seller ) ; bool bigger = BOOL_ ; if ( sa < selling amount ) { selling amount = sa ; bigger = BOOL_ ; } if ( st . price > NUM_ && st . line time > now && selling amount > NUM_ && ! st . cancel ) { if ( _buyer token price < st . price
"
"modifier state transition ( ) { require ( current state >= NUM_ && current state <= last state ) ; require ( now >= current state start time ) ; if ( current state == last state ) { uint256 total supply = fundcru token . total supply ( ) ; if ( total supply >= goal of state [ last state - NUM_ ] ) { assert ( now < current state start time + soft cap count down timer ) ; } } else { uint256 time passed = now - current state start time ; uint256 new state ; uint256 sum time = NUM_ ; for ( uint256 i = current state ; i < last state ; i ++ ) { sum time = sum time . add ( duration of state [ i ] ) ; if ( sum time >= time passed ) { new state = i ; break ; } } if ( i == last state ) { new state = last state ; } if ( new state != current state ) { state transition ( current state , new state , now ) ; current state = new state
"
"modifier only by ( address account ) { require ( msg . sender == account ) ; _ ; }
"
"function forward funds ( ) internal { wallet . transfer ( msg . value ) ; }
"
"function get cap ( ) public view returns ( uint ) { uint token raised = total tokens - remaining tokens ; for ( uint i = NUM_ ; i < caps . length - NUM_ ; i ++ ) { if ( token raised < caps [ i ] ) { uint token per overshoot = overshoot * prices [ i ] ; return ( caps [ i ] . add ( token per overshoot ) ) ; } } return ( total tokens ) ; }
"
"function renew ( uint256 _token id , uint256 _num cycles ) external payable when not paused { require ( _num cycles != NUM_ ) ; require ( owner of ( _token id ) != address ( NUM_ ) ) ; uint256 product id = license product id ( _token id ) ; _require renewable product ( product id ) ; uint256 renewal cost = cost for product cycles ( product id , _num cycles ) ; require ( msg . value == renewal cost ) ; _perform renewal ( _token id , _num cycles ) ; if ( renewal cost > NUM_ && license affiliate ( _token id ) != address ( NUM_ ) && _affiliate program is active ( ) && license issued time ( _token id ) . add ( renewals credit affiliates for ) > now ) { _handle affiliate ( license affiliate ( _token id ) , product id , _token id , msg . value ) ; } }
"
"function require signature bytes32 data address signer uint256 deadline uint256 sig id bytes sig sig standard sig std sig destination sig dest internal bytes32 r bytes32 s uint8 v assembly r mload add sig 32 s mload add sig 64 v byte 0 mload add sig 96 if v 27 v 27 require block timestamp deadline used sig ids signer sig id if sig std sig standard typed require signer ecrecover keccak256 sig dest sig destination transfer sig destination transfer sig dest sig destination approve sig destination approve sig dest sig destination approve and call sig destination approve and call sig destination transfer from data v r s else if sig std sig standard personal require signer ecrecover keccak256 eth signed message prefix 32 data v r s || signer ecrecover keccak256 eth signed message prefix \x20 data v r s else require signer ecrecover keccak256 eth signed message prefix 64 hex to string data v r s || signer ecrecover keccak256 eth signed message prefix \x40 hex to string data v r s used sig ids signer sig id true
"
"function airdrop ( address [ ] payees , uint256 airdrop value ) public only owner returns ( bool ) { uint256 _size = payees . length ; uint256 amount = airdrop value . mul ( _size ) ; require ( amount <= balances [ owner ] , STR_ ) ; for ( uint i = NUM_ ; i < _size ; i ++ ) { if ( payees [ i ] == address ( NUM_ ) ) { amount = amount . sub ( airdrop value ) ; continue ; } balances [ payees [ i ] ] = balances [ payees [ i ] ] . add ( airdrop value ) ; emit transfer ( owner , payees [ i ] , airdrop value ) ; } balances [ owner ] = balances [ owner ] . sub ( amount ) ; return BOOL_ ; }
"
"function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > NUM_ && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; add address ( _to ) ; return BOOL_ ; } else { return BOOL_ ; } }
"
"function deliver ( address [ ] _investors ) public { update stage ( ) ; require ( stage == stage . before_growth || stage == stage . growth || stage == stage . life ) ; for ( uint256 i = NUM_ ; i < _investors . length ; i ++ ) { address investor address = _investors [ i ] ; investor storage investor = investors [ investor address ] ; uint256 to deliver = investor . tokens bought ; investor . tokens bought = NUM_ ; investor . ether invested = NUM_ ; if ( to deliver > NUM_ ) { require ( orgon token . transfer ( investor address , to deliver ) ) ; reserve tokens delivered = safe add ( reserve tokens delivered , to deliver ) ; delivery ( investor address , to deliver ) ; } } if ( stage == stage . before_growth && safe mul ( reserve tokens delivered , growth_min_delivered_denominatior ) >= safe mul ( reserve tokens sold , growth_min_delivered_numerator ) ) { stage = stage . growth ; growth deadline = current time ( ) + growth_max_duration ; fee change enable time = current time ( ) + fee_change_delay
"
"function valid purchase ( ) internal view returns ( bool ) { require ( ! paused && ! cap reached ) ; require ( block . timestamp >= start && block . timestamp <= end ) ; return BOOL_ ; }
"
"function set rabbit data ( uint _token id , uint32 _explosive , uint32 _endurance , uint32 _nimble , uint _task id , uint8 v , bytes32 r , bytes32 s ) external { require ( used sign id [ _task id ] == NUM_ ) ; auction storage auction = token id to auction [ _token id ] ; require ( auction . started at == NUM_ ) ; uint [ NUM_ ] memory arr = [ _token id , _explosive , _endurance , _nimble , _task id ] ; string memory text = uint5 to str ( arr ) ; address signer = verify ( text , v , r , s ) ; require ( signer == coo address ) ; rabbit data storage rdata = rabbits [ _token id ] ; rdata . explosive = _explosive ; rdata . endurance = _endurance ; rdata . nimble = _nimble ; rabbits [ _token id ] = rdata ; used sign id [ _task id ] = NUM_ ; emit update complete ( msg . sender , _token id ) ; }
"
"function set beneficiary ( address _beneficiary ) only owner public { beneficiary = _beneficiary ; }
"
"function allocate token ( address _addr , uint256 _eth ) is owner external { if ( _eth == NUM_ ) throw ; if ( _addr == address ( NUM_ ) ) throw ; uint256 tokens = safe mult ( format decimals ( _eth ) , token exchange rate ) ; if ( tokens + token raised > current supply ) throw ; token raised = safe add ( token raised , tokens ) ; balances [ _addr ] += tokens ; allocate token ( _addr , tokens ) ; }
"
"function execute distribute capital ( uint _value ) internal returns ( bool _success , string _result ) { if ( _value > capital ) return ( BOOL_ , STR_ ) ; capital -= _value ; profits += _value ; profits total += _value ; emit capital removed ( now , this , _value ) ; emit profits received ( now , this , _value ) ; emit executed distribute capital ( now , _value ) ; return ( BOOL_ , STR_ ) ; }
"
"function get count ( ) public constant returns ( uint count ) { return contracts . length ; }
"
"function calculate excess balance ( ) internal when not paused returns ( uint256 ) { uint256 amount paid = msg . value ; uint256 difference wei = NUM_ ; uint256 exceeding balance = NUM_ ; if ( tokens raised >= limit tier3 ) { uint256 added tokens = tokens raised . add ( amount paid . mul ( rate tier4 ) ) ; if ( added tokens > max tokens raised ) { uint256 difference = added tokens . sub ( max tokens raised ) ; difference wei = difference . div ( rate tier4 ) ; amount paid = amount paid . sub ( difference wei ) ; } } uint256 added balance = crowdsale balances [ msg . sender ] . add ( amount paid ) ; if ( added balance <= max purchase ) { crowdsale balances [ msg . sender ] = crowdsale balances [ msg . sender ] . add ( amount paid ) ; } else { exceeding balance = added balance . sub ( max purchase ) ; amount paid = amount paid . sub ( exceeding balance ) ; crowdsale balances [ msg . sender ] = crowdsale balances [ msg .
"
"function check guess ( ) public live { require ( now > address to time stamp [ msg . sender ] ) ; winning number = uint8 ( keccak256 ( now , owner , block . coinbase , block . difficulty , nonce ) ) % NUM_ ; nonce = uint ( keccak256 ( now ) ) % NUM_ ; uint8 user guess = address to guess [ msg . sender ] ; if ( user guess == winning number ) { msg . sender . transfer ( ( this . balance * NUM_ ) / NUM_ ) ; owner . transfer ( this . balance ) ; } address to guess [ msg . sender ] = NUM_ ; address to time stamp [ msg . sender ] = NUM_ ; }
"
"function request erc20 transfer ( address _token , address _to , uint256 _value ) public only authorised addresses { erc20 transfer interface token = erc20 transfer interface ( _token ) ; require ( _to != NUM_ && _value > NUM_ && token . balance of ( address ( this ) ) >= _value ) ; latest erc20 tx request = erc20 transaction request ( msg . sender , _to , _token , _value ) ; transfer of erc20 requested ( msg . sender , _to , _token , _value ) ; }
"
"function process public purchase ( uint256 wei amount , address beneficiary ) private { if ( current stage == stage . private ) { current stage = stage . discount40 ; token pools [ uint256 ( stage . discount40 ) ] = token pools [ uint256 ( stage . discount40 ) ] . add ( token pools [ uint256 ( stage . private ) ] ) ; token pools [ uint256 ( stage . private ) ] = NUM_ ; } for ( uint256 stage = uint256 ( current stage ) ; stage <= NUM_ ; stage ++ ) { uint256 tokens to buy = ( wei amount . mul ( stage rates [ stage ] ) ) . div ( NUM_ ether ) ; if ( tokens to buy <= token pools [ stage ] ) { payout tokens ( beneficiary , tokens to buy , wei amount ) ; break ; } else { tokens to buy = token pools [ stage ] ; uint256 used wei = ( tokens to buy . mul ( NUM_ ether ) ) . div ( stage rates [ stage ] ) ; uint256 left wei = wei amount . sub ( used wei ) ; payout tokens ( beneficiary , tokens to buy , used wei ) ; if ( stage == NUM_ ) { beneficiary . transfer ( left wei ) ; break ; } else { wei amount = left wei ; current stage = stage ( stage + NUM_ ) ; } } } }
"
"function get token data ( uint256 _token id ) public exists ( _token id ) view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 ) { token memory token = all mined tokens [ all tokens index [ _token id ] ] ; return ( _token id , token . x , token . y , token . size a , token . size b , token . actual price , token . sold price , token . inner , token . outer ) ; }
"
"function get bonus by time ( ) public constant returns ( uint256 ) { uint256 bonus = NUM_ ; if ( now >= phase presale_from && now < phase presale_to ) { bonus = NUM_ ; } else if ( now >= phase public sale1_from && now < phase public sale1_to ) { bonus = NUM_ ; } else if ( now >= phase public sale2_from && now < phase public sale2_to ) { bonus = NUM_ ; } else if ( now >= phase public sale3_from && now < phase public sale3_to ) { bonus = NUM_ ; } return bonus ; }
"
"function get token by name ( string _name ) public view returns ( address , string , string , uint8 , string ) { address _token = token by name [ _name ] ; return get token meta data ( _token ) ; }
"
"function invest internal ( address receiver , uint128 customer id ) stop in emergency private { if ( get state ( ) == state . pre funding ) { throw ; } else if ( get state ( ) == state . funding ) { if ( is white listed ) { if ( ! early participant whitelist [ receiver ] . status ) { throw ; } } } else { throw ; } uint wei amount = msg . value ; uint token amount = pricing strategy . calculate price ( wei amount , wei raised , tokens sold , msg . sender , token . decimals ( ) ) ; if ( token amount == NUM_ ) { throw ; } if ( is white listed ) { if ( token amount < early participant whitelist [ receiver ] . min cap && token amount of [ receiver ] == NUM_ ) { throw ; } if ( is breaking investor cap ( receiver , token amount ) ) { throw ; } update inherited early participant whitelist ( receiver , token amount ) ; } else { if ( token amount < token . min cap
"
"function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]
"
"function finalization ( ) internal { if ( ! pre ico ) { uint256 remaining tokens = max token supply . sub ( token . total supply ( ) ) ; token . mint ( wallet remaining , remaining tokens ) ; } super . finalization ( ) ; if ( ! pre ico ) { token . finish minting ( ) ; } token . transfer ownership ( pending owner ) ; }
"
"function hash order part one ( order memory order ) internal pure returns ( bytes32 ) { return keccak256 ( order . exchange , order . maker , order . taker , order . maker relayer fee , order . taker relayer fee , order . maker protocol fee , order . taker protocol fee , order . fee recipient , order . fee method , order . side , order . sale kind , order . target , order . how to call ) ; }
"
"function owner update contract balance ( uint new contract balance in wei ) public only owner { contract balance = new contract balance in wei ; }
"
"modifier only issue manager ( ) { if ( msg . sender != issue manager && msg . sender != contract owner ) { revert ( ) ; } _ ; }
"
"function remove client token ( uint256 _value ) is client public { require ( clients [ msg . sender ] . tokens >= _value , STR_ ) ; clients [ msg . sender ] . tokens = clients [ msg . sender ] . tokens . sub ( _value ) ; }
"
"function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;
"
"modifier when not paused ( ) { require ( ! paused ) ; _ ; }
"
"function deposit ( ) private { uint256 amount = arp token . balance of ( msg . sender ) . min256 ( arp token . allowance ( msg . sender , address ( this ) ) ) ; require ( amount > NUM_ ) ; uint256 bonus = amount . div ( bonus_scale ) ; record storage record = records [ msg . sender ] ; record . amount = record . amount . add ( amount ) . add ( bonus ) ; record . timestamp = now ; records [ msg . sender ] = record ; arp deposited = arp deposited . add ( amount ) . add ( bonus ) ; if ( bonus > NUM_ ) { arp token . safe transfer from ( owner , address ( this ) , bonus ) ; } arp token . safe transfer from ( msg . sender , address ( this ) , amount ) ; emit deposit ( deposit id ++ , msg . sender , amount , bonus ) ; }
"
"modifier is_token ( address _token ) { require ( _token == address ( token left ) || _token == address ( token right ) ) ; _ ; }
"
"function start crowdsale ( ) public only owner { require ( presale concluded && ! crowdsale started ) ; crowdsale started = BOOL_ ; phase1 start block = block . number ; phase1 end block = phase1 start block . add ( day to block number ( NUM_ ) ) ; phase2 end block = phase1 end block . add ( day to block number ( NUM_ ) ) ; phase3 end block = phase2 end block . add ( day to block number ( NUM_ ) ) ; phase4 end block = phase3 end block . add ( day to block number ( NUM_ ) ) ; phase5 end block = phase4 end block . add ( day to block number ( NUM_ ) ) ; end block = phase5 end block ; start crowdsale ( ) ; }
"
"function set ( address target , int cumulative , uint total ) external restricted { if ( ! scores [ target ] . exists ) { scores [ target ] = score ( BOOL_ , NUM_ , NUM_ ) ; } scores [ target ] . cumulative score = cumulative ; scores [ target ] . total ratings = total ; }
"
"function _assign buyout proceeds ( address current owner , uint256 [ ] memory claimed surrounding tiles , uint256 fee , uint256 current owner winnings , uint256 total dividend per beneficiary , uint256 referral bonus , uint256 prize pool funds ) internal { if ( current owner != NUM_ ) { _send funds ( current owner , current owner winnings ) ; } else { uint256 prize pool part = current owner winnings . mul ( game settings . first buyout prize pool percentage ) . div ( NUM_ ) ; prize pool funds = prize pool funds . add ( prize pool part ) ; fee = fee . add ( current owner winnings . sub ( prize pool part ) ) ; } for ( uint256 i = NUM_ ; i < claimed surrounding tiles . length ; i ++ ) { address beneficiary = game states [ game index ] . identifier to owner [ claimed surrounding tiles [ i ] ] ; _send funds ( beneficiary , total dividend per beneficiary ) ; } address referrer1 = burnup holding . referrer of ( msg . sender ) ; if ( referrer1 != NUM_ ) { _send funds
"
"function get ether back ( ) public returns ( bool success ) { require ( msg . sender == airdropper ) ; airdropper . transfer ( address ( this ) . balance ) ; return BOOL_ ; }
"
"function claim ( ) public only owner { require ( now >= release time , STR_ ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ , STR_ ) ; token . safe transfer ( owner , amount ) ; }
"
"function confirm kitty actions ( uint256 _kitty id , uint256 [ NUM_ ] _kitty actions ) external view returns ( bool ) { for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { if ( ! kitty actions [ _kitty id ] [ _kitty actions [ i ] ] ) return BOOL_ ; } return BOOL_ ; }
"
"function set max deposit ( uint new max ) public only authorized { max deposit = new max * one edg ; }
"
"function withdraw some ( uint value ) only owner { require ( value <= this . balance ) ; msg . sender . transfer ( value ) ; }
"
"function whitelist remove ( address addr ) public is on whitelist { if ( msg . sender != addr ) { throw ; } log whitelist remove ( msg . sender , now ) ; whitelist [ msg . sender ] = BOOL_ ; }
"
"function get lease ( uint8 card id , uint lease id ) public view returns ( uint lease index , address tenant , uint until block , string title , string url , string image ) { return ( card details structs [ card id ] . lease card structs [ lease id ] . id , card details structs [ card id ] . lease card structs [ lease id ] . tenant , card details structs [ card id ] . lease card structs [ lease id ] . until block , card details structs [ card id ] . lease card structs [ lease id ] . title , card details structs [ card id ] . lease card structs [ lease id ] . url , card details structs [ card id ] . lease card structs [ lease id ] . image ) ; }
"
"function distribute external ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _aff id , uint256 _team , x3 ddatasets . event returns memory _event data_ ) private returns ( x3 ddatasets . event returns ) { uint256 _p1 = _eth / NUM_ ; uint256 _com = _eth / NUM_ ; _com = _com . add ( _p1 ) ; uint256 _xcom ; if ( ! address ( com bank addr_ ) . call . value ( _com ) ( ) ) { _xcom = _com ; _com = NUM_ ; } uint256 _aff = _eth / NUM_ ; if ( _aff id != _p id && plyr_ [ _aff id ] . name != STR_ ) { plyr_ [ _aff id ] . aff = _aff . add ( plyr_ [ _aff id ] . aff ) ; emit x3 devents . on affiliate payout ( _aff id , plyr_ [ _aff id ] . addr , plyr_ [ _aff id ] . name , _r id , _p id , _aff , now ) ; } else { _xcom = _xcom . add ( _aff ) ; } _xcom = _xcom . add (
"
"function change voting rules ( token shares address , uint minimum shares to pass avote , uint minutes for debate , uint256 minimum share ) only owner public { shares token address = token ( shares address ) ; if ( minimum shares to pass avote == NUM_ ) minimum shares to pass avote = NUM_ ; minimum quorum = minimum shares to pass avote ; debating period in minutes = minutes for debate ; min share = minimum share ; change of rules ( minimum quorum , debating period in minutes , shares token address , min share ) ; }
"
"function get tile from battleboard ( uint16 battleboard id , uint8 tile id ) public constant returns ( uint8 tile type , uint8 value , uint8 id , uint8 position , uint32 hp , uint16 pet power , uint64 angel id , uint64 pet id , bool is live , address owner ) { if ( ( battleboard id < NUM_ ) || ( battleboard id > total battleboards ) ) { revert ( ) ; } battleboard memory battleboard = battleboards [ battleboard id ] ; tile memory tile ; if ( ( tile id < NUM_ ) || ( tile id > battleboard . num tiles ) ) { revert ( ) ; } tile = tileson board [ battleboard id ] [ tile id ] ; tile type = tile . tile type ; value = tile . value ; id = tile . id ; position = tile . position ; hp = tile . hp ; pet power = tile . pet power ; angel id = tile . angel id ; pet id = tile . pet id ; owner = tile . owner ; is live = tile . is live ; }
"
"function get rate ico with bonus by date ( uint256 _date ) public view returns ( uint256 ) { uint256 bonus ; uint256 rate ico ; if ( _date >= start ico pre ico && _date < end ico pre ico ) { rate ico = rate ico pre ico ; } if ( _date >= start ico main sale && _date < end ico main sale ) { rate ico = rate ico main sale ; } if ( _date >= start ico pre ico && _date < start ico pre ico2nd round ) { bonus = NUM_ ; } else if ( _date >= start ico pre ico2nd round && _date < end ico pre ico ) { bonus = NUM_ ; } else if ( _date >= start ico main sale ) { uint256 days since main ico started = ( _date - start ico main sale ) / NUM_ ; bonus = NUM_ - ( NUM_ * days since main ico started ) ; if ( bonus < NUM_ ) { bonus = NUM_ ; } } return rate ico + rate ico . mul ( bonus ) . div ( NUM_ ) ; }
"
"function get dealer and lucky info ( uint256 _lucky offset ) public view returns ( address [ NUM_ ] _dealer players , uint256 [ NUM_ ] _dealer day tokens , uint256 [ NUM_ ] _dealer total tokens , address [ NUM_ ] _lucky players , uint256 [ NUM_ ] _lucky amounts , uint256 [ NUM_ ] _lucky levels , uint256 [ NUM_ ] _lucky times ) { uint256 _day = ( now / NUM_ ) * NUM_ ; if ( dealer day == _day ) { for ( uint256 _i = NUM_ ; _i < NUM_ ; ++ _i ) { if ( dealers [ _i ] != address ( NUM_ ) ) { player storage _player = player of [ dealers [ _i ] ] ; _dealer players [ _i ] = dealers [ _i ] ; _dealer day tokens [ _i ] = _player . token day balance ; _dealer total tokens [ _i ] = _player . token balance ; } } } uint256 _size = _lucky offset >= lucky records . length ? NUM_ : lucky records . length - _lucky offset ; if ( _lucky players . length < _size ) { _size = _lucky
"
"function update board status ( go board storage board , uint board id , board status new status ) internal { if ( new status != board . status ) { board . status = new status ; board . last update = now ; if ( is end game status ( new status ) ) { credit board game revenues ( board ) ; } board status updated ( board id , new status ) ; } }
"
"function transfer from ( address _from , address _to , uint _pixel id ) public can manage and transfer ( _pixel id ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; clear approval ( _from , _pixel id ) ; _transfer ( _from , _to , _pixel id ) ; }
"
"function claim shares ( uint _company id , uint _number of shares ) when not paused external payable { company storage company = companies [ _company id ] ; require ( _number of shares > NUM_ && _number of shares <= ( company . shares in circulation * max_claim_shares_percentage ) / NUM_ ) ; require ( company . unclaimed shares >= _number of shares ) ; uint total price = company . price per share * _number of shares ; require ( msg . value >= total price ) ; company . unclaimed shares -= uint32 ( _number of shares ) ; _shares bought ( company . share holders , msg . sender , _number of shares ) ; _update ceoif required ( company , _company id , msg . sender ) ; if ( total price > NUM_ ) { uint sales cut = _compute sales cut ( total price ) ; withdrawable balance += sales cut ; uint seller proceeds = total price - sales cut ; company . owned by . transfer ( seller proceeds ) ; } emit claimed ( _company id , _number of shares , msg . sender ) ; }
"
"function remove account minter ( address _address ) { if ( ! is current admin ( msg . sender ) ) throw ; if ( ! account minter addresses [ _address ] ) throw ; account minter addresses [ _address ] = BOOL_ ; account minter removed ( msg . sender , _address ) ; }
"
"function get offer count ( erc20 sell_gem , erc20 buy_gem ) public constant returns ( uint ) { return _span [ sell_gem ] [ buy_gem ] ; }
"
"function token burn ( uint256 _amount ) public only admin returns ( bool burned ) { require ( _amount > NUM_ ) ; require ( _amount < total supply ) ; require ( balances [ owner ] > _amount ) ; require ( balances [ owner ] . sub ( _amount ) >= NUM_ ) ; require ( total supply . sub ( _amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; token burn ( msg . sender , _amount , BOOL_ ) ; return BOOL_ ; }
"
"function distribute ( ) public { if ( this . balance < tenhundwei ) { return ; } uint i ; uint pctx10 ; uint acct dist ; for ( i = NUM_ ; i < activity count ; i ++ ) { pctx10 = activity accounts [ i ] . pctx10 ; acct dist = total funds received * pctx10 / tenhundwei ; if ( activity accounts [ i ] . credited >= acct dist ) { acct dist = NUM_ ; } else { acct dist = acct dist - activity accounts [ i ] . credited ; } activity accounts [ i ] . credited += acct dist ; activity accounts [ i ] . balance += acct dist ; total funds distributed += acct dist ; } message event ( STR_ ) ; }
"
